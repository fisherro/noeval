;------------------------------------------------------------------------------
; Exception propagation tests

; Test that exceptions propagate through nested calls
(define error-thrower (lambda () (first 42)))
(define error-wrapper (lambda () (error-thrower)))
(test-error (error-wrapper) "exceptions should propagate through function calls")

; Test exception in vau operative
(define error-vau (vau (x) env (rest "invalid")))
(test-error (error-vau dummy) "exceptions should propagate from vau operatives")

; Test exception in wrapped operative
(define error-op (vau (x) env (first x)))  ; Will fail if x is not a list
(define wrapped-error (wrap error-op))
(test-error (wrapped-error 42) "exceptions should propagate from wrapped operatives")

; Test exception in lambda
(define error-lambda (lambda (x) (+ x "invalid")))
(test-error (error-lambda 5) "exceptions should propagate from lambda functions")

; Test exception in higher-order function usage
(define apply-func (lambda (f x) (f x)))
(define bad-func (lambda (n) (/ n "zero")))
(test-error (apply-func bad-func 10) "exceptions should propagate through higher-order functions")

;------------------------------------------------------------------------------
; Recovery tests using try

; Test basic exception recovery
(define-mutable recovery-test 0)
(try (do (set! recovery-test 1)
         (first "invalid"))
  (lambda* (error)
    (set! recovery-test 99)))
(test-assert
    (= recovery-test 99)
  "try should allow recovery from exceptions")

; Test that try-block executes normally when no error
(define-mutable normal-execution 0)
(try (set! normal-execution 42)
  (lambda* (error) (set! normal-execution -1)))
(test-assert
    (= normal-execution 42)
  "try should execute normally when no exception occurs")

; Test exception information is passed to handler
(define-mutable error-info "")
(try (rest 123)
  (lambda* (error)
    (set! error-info (first (rest error)))))  ; Get error message
(test-assert
    (not (= error-info ""))
  "try should pass error information to handler")

; Test nested try blocks
(define-mutable nested-result 0)
(try (try (first "outer-error")
       (lambda* (e) (set! nested-result 1)))
  (lambda* (e) (set! nested-result 2)))
(test-assert
    (= nested-result 1)
  "nested try blocks should work correctly")

; Test try with finally clause
(define-mutable finally-executed 0)
(define-mutable try-result "")
(define result (try "success-value"
                   (lambda* (error) "error-value")
                 (lambda* (value)
                   (set! finally-executed 1)
                   (set! try-result value)
                   value)))
(test-assert
    (and (= finally-executed 1) (= try-result "success-value"))
  "try with finally should execute finally clause on success")

; Test try/finally with exception
(define-mutable finally-on-error 0)
(try (first 42)
  (lambda* (error) "handled")
  (lambda* (result)
    (set! finally-on-error 1)
    result))
(test-assert
    (= finally-on-error 1)
  "try with finally should execute finally clause on error")
