; Test suite for the vau language library
; This file contains tests that are run after loading the standard library

; Set up test variables
(define-mutable test-failures 0)
(define-mutable test-count 0)

; Test helper functions
(define test-assert
  (vau (condition message) env
    (do
      (set! test-count (+ test-count 1))
      (if (eval condition env)
          (do
            (display "✓ ")
            (display message)
            (display "\n")
            "PASS")
          (do
            (set! test-failures (+ test-failures 1))
            (display "\e[31m✗ ")
            (display message)
            (display "\e[0m\n")
            message)))))

; Helper operative to create unevaluated expressions for testing
(define make-expr
  (vau args env args))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Test nested skip blocks

#skip
(displayln bogus1)
#skip
(displayln bogus2)
#end
(displayln bogus3)
#end

;------------------------------------------------------------------------------

; Test: Basic quoting
(test-assert 
  (= (first (q (+ 1 2))) (q +))
  "q should prevent evaluation of expressions")

; Test list function
(test-assert 
  (nil? (list))
  "empty list should return nil")

; Test eval-list function with unevaluated expressions
(define unevaluated-exprs (make-expr (+ 1 2) (* 3 4)))
(define result-list (eval-list unevaluated-exprs env))
(test-assert 
  (= (first result-list) 3)
  "eval-list should evaluate first element")

(test-assert 
  (= (first (rest result-list)) 12)
  "eval-list should evaluate second element")

(test-assert 
  (= (first (list 42)) 42)
  "single element list should work")

; Test wrap functionality
(define simple-op (vau (x y) env (cons x (cons y ()))))
(define wrapped-simple (wrap simple-op))

; Test that wrap evaluates arguments
(define a 1)
(define b 2)
(test-assert 
  (nil? (rest (rest (wrapped-simple a b))))
  "wrap should create proper list structure")

; Test wrap with built-in operatives
(define wrapped-plus (wrap +))
(define x 5)
(define y 10)
(test-assert 
  (= (wrapped-plus x y) 15)
  "wrapped + should evaluate arguments and add them")

(test-assert 
  (= (wrapped-plus (+ 1 2) 4) 7)
  "wrapped + should evaluate complex arguments")

; Test wrap with environment-dependent operatives
(define env-dependent-op 
  (vau (x) env 
    (eval x env)))  ; This needs the environment parameter to work

(define wrapped-env-op (wrap env-dependent-op))
(define test-var 42)

(test-assert 
  (= (wrapped-env-op (q test-var)) 42)
  "wrap should preserve environment context for user-defined operatives")

;------------------------------------------------------------------------------
; vau* tests

; Test 1: Basic vau* with multiple expressions
(define-mutable vau-side-effect 0)
(define basic-vau* 
  (vau* (x) env
    (set! vau-side-effect (+ vau-side-effect 1))
    (set! vau-side-effect (* vau-side-effect 2))
    x))  ; Return the unevaluated argument

; Test the side effects occurred
(basic-vau* dummy-expr)
(test-assert 
  (= vau-side-effect 2)
  "vau* should execute multiple expressions for side effects")

; Test 2: vau* with environment parameter usage  
(define env-using-vau*
  (vau* (expr) dyn-env
    (define temp-var 42)
    (define result (eval expr dyn-env))
    (* result 2)))
(test-assert 
  (= (env-using-vau* (+ 3 4)) 14)
  "vau* should be able to use environment parameter")

; Test 3: vau* with no expressions (empty body)
(define empty-vau* (vau* (x) env))
(test-assert 
  (nil? (empty-vau* hello))
  "vau* with empty body should return nil")

; Test 4: vau* with multiple parameters - test that it accepts them
(define multi-param-vau*
  (vau* (a b c) env
    (define first-arg a)
    (define second-arg b) 
    (define third-arg c)
    first-arg))  ; Just return first arg to test it works
(test-assert 
  (= (multi-param-vau* 42 y z) 42)
  "vau* should handle multiple parameters correctly")

; Test 5: vau* that evaluates some arguments selectively  
(define selective-eval-vau*
  (vau* (first-expr second-expr) dyn-env
    (define first-val (eval first-expr dyn-env))
    first-val))  ; Just return evaluated first arg
(test-assert 
  (= (selective-eval-vau* (+ 2 3) (+ 4 5)) 5)
  "vau* should allow selective evaluation of arguments")

; Test 6: Compare vau* vs regular vau behavior
(define regular-vau-multi
  (vau (x) env
    (do (define temp x)
        (* 2 2)
        temp)))
(define equivalent-vau*
  (vau* (x) env
    (define temp x)
    (* 2 2)
    temp))

; Test that both return the same unevaluated expression by using them with numbers
(test-assert 
  (= (regular-vau-multi 123) (equivalent-vau* 123))
  "vau* should behave equivalently to vau with do block")

; Test 7: vau* with conditional logic
(define conditional-vau*
  (vau* (test-expr then-expr else-expr) dyn-env
    (define test-result (eval test-expr dyn-env))
    (if test-result
        then-expr
        else-expr)))
(test-assert 
  (= (conditional-vau* (= 1 1) 42 99) 42)
  "vau* should work with conditional logic - true case")

(test-assert 
  (= (conditional-vau* (= 1 2) 42 99) 99)  
  "vau* should work with conditional logic - false case")

; Test 8: vau* with single expression (should work like regular vau)
(define single-expr-vau* (vau* (x) env x))
(test-assert 
  (= (single-expr-vau* 777) 777)
  "vau* with single expression should work like regular vau")

; Test 9: vau* with complex expression sequencing  
(define-mutable sequence-counter 0)
(define sequence-test-vau*
  (vau* (x) env
    (set! sequence-counter (+ sequence-counter 1))  ; Side effect
    (set! sequence-counter (+ sequence-counter 10)) ; Side effect  
    x))  ; Return unevaluated x

(define seq-result (sequence-test-vau* final-expr))
(test-assert 
  (and (= sequence-counter 11) (= seq-result (q final-expr)))
  "vau* should execute all expressions and return last value")

; vau used in higher-order context
(define test-vau (vau (x) env (eval x env)))
(define higher-order-test (lambda (op arg) (op arg)))

(displayln "(higher-order-test test-vau 123): " (higher-order-test test-vau 123))
(test-assert 
  (= (higher-order-test test-vau 123) 123)
  "vau should work when passed to and called from other functions")

; Test 10: vau* used in higher-order context
(define test-vau* (vau* (x) env (eval x env)))
(define higher-order-test (lambda (op arg) (op arg)))

(test-assert 
  (= (higher-order-test test-vau* 123) 123)
  "vau* should work when passed to and called from other functions")

; Test 11: vau* with recursive pattern (simplified)
(define recursive-vau*
  (vau* (x) dyn-env
    (define helper-result x)  ; Simplified - just pass through
    helper-result))
(test-assert 
  (= (recursive-vau* test-expr) (q test-expr))
  "vau* should work with internal definitions")

; Test 12: Test that vau* creates proper operative (doesn't evaluate args)
(define-mutable arg-eval-test 0)
(define arg-test-vau*
  (vau* (expr) env
    (set! arg-eval-test 999)
    expr))

; The argument (+ arg-eval-test 1) should NOT be evaluated
(define unevald-result (arg-test-vau* (+ arg-eval-test 1)))
(test-assert 
  (= arg-eval-test 999)  ; Should be 999 from vau* body, not from argument
  "vau* should not evaluate its arguments")

;------------------------------------------------------------------------------
; Lambda tests

; Test 1: Basic lambda creation and invocation
(define add-two (lambda (x) (+ x 2)))
(test-assert 
  (= (add-two 5) 7)
  "basic lambda should work with single parameter")

(test-assert 
  (= (add-two 10) 12)
  "lambda should work with different arguments")

; Test 2: Lambda with multiple parameters
(define multiply (lambda (x y) (* x y)))
(test-assert 
  (= (multiply 3 4) 12)
  "lambda should work with multiple parameters")

(test-assert 
  (= (multiply 7 8) 56)
  "lambda with multiple parameters should work consistently")

; Test 3: Lambda with no parameters
(define get-constant (lambda () 42))
(test-assert 
  (= (get-constant) 42)
  "lambda with no parameters should work")

; Test 4: Lambda that uses closure variables
(define closure-var 100)
(define add-closure-var (lambda (y) (+ closure-var y)))
(test-assert 
  (= (add-closure-var 23) 123)
  "lambda should capture closure variables")

; ! This test fails!
; Test 5: Nested lambda expressions
(define make-adder (lambda (n) (lambda (x) (+ x n))))
(define add-five (make-adder 5))
(test-assert 
  (= (add-five 10) 15)
  "nested lambdas should work")

(test-assert 
  (= (add-five 7) 12)
  "nested lambdas should work consistently")

; Test 6: Lambda arguments are evaluated (unlike vau)
(define eval-and-double (lambda (x) (* x 2)))
(test-assert 
  (= (eval-and-double (+ 3 4)) 14)
  "lambda should evaluate its arguments")

; Test 7: Compare with vau - lambda evaluates args, vau doesn't
(define vau-version (vau (x) env x))
(define lambda-version (lambda (x) x))

; Create test expressions
(define test-expr (make-expr (+ 1 2)))
(define vau-result (vau-version (+ 1 2)))
(define lambda-result (lambda-version (+ 1 2)))

(test-assert 
  (= lambda-result 3)
  "lambda should evaluate arguments before passing to body")

; Test 8: Lambda with complex body expressions
(define complex-calc (lambda (a b) (+ (* a a) (* b b))))
(test-assert 
  (= (complex-calc 3 4) 25)
  "lambda should handle complex expressions in body")

; Test 9: Lambda used with higher-order functions
(define apply-twice (lambda (f x) (f (f x))))
(define increment (lambda (n) (+ n 1)))
(test-assert 
  (= (apply-twice increment 5) 7)
  "lambda should work as higher-order function")

; Test 10: Lambda with conditional logic
(define abs-positive (lambda (x) (if (= x 0) 0 x)))
(test-assert 
  (= (abs-positive 5) 5)
  "lambda should work with conditionals")

(test-assert 
  (= (abs-positive 0) 0)
  "lambda conditional should handle zero case")

; Test 11: Lambda that returns another lambda
(define curry-add (lambda (x) (lambda (y) (+ x y))))
(define add-ten (curry-add 10))
(test-assert 
  (= (add-ten 5) 15)
  "lambda should support currying")

; Test 12: Test lambda via square function
(define square (lambda (x) (* x x)))

(test-assert 
  (= (square 4) 16)
  "library square function should work")

(test-assert 
  (= (square 7) 49)
  "library square function should work consistently")

; Test 13: Immediate lambda invocation
(test-assert 
  (= ((lambda (x y) (+ x y)) 8 9) 17)
  "immediate lambda invocation should work")

(test-assert 
  (= ((lambda () (* 6 7))) 42)
  "immediate parameterless lambda invocation should work")

; Test 14: Lambda parameter shadowing
(define outer-var 999)
(define shadow-test (lambda (outer-var) (* outer-var 2)))
(test-assert 
  (= (shadow-test 5) 10)
  "lambda parameters should shadow outer variables")

(test-assert 
  (= outer-var 999)
  "lambda parameter shadowing should not affect outer scope")

; Test 15: Lambda composition
(define double (lambda (x) (* x 2)))
(define add-one (lambda (x) (+ x 1)))
(define double-then-add-one (lambda (x) (add-one (double x))))
(test-assert 
  (= (double-then-add-one 5) 11)
  "lambda composition should work")

;------------------------------------------------------------------------------
; lambda* tests (multi-expression lambda)

; Test 1: Basic lambda* with single expression (should work like regular lambda)
(define simple-lambda* (lambda* (x) (+ x 5)))
(test-assert 
  (= (simple-lambda* 10) 15)
  "lambda* should work with single expression")

; Test 2: lambda* with multiple expressions
(define-mutable side-effect-counter 0)
(define multi-expr-lambda* 
  (lambda* (x) 
    (set! side-effect-counter (+ side-effect-counter 1))
    (set! side-effect-counter (+ side-effect-counter x))
    (* x 2)))
(test-assert 
  (= (multi-expr-lambda* 3) 6)
  "lambda* should return value of last expression")

(test-assert 
  (= side-effect-counter 4)  ; 1 + 3 = 4
  "lambda* should execute all expressions for side effects")

; Test 3: lambda* with no parameters and multiple expressions
(define-mutable global-var 100)
(define no-params-lambda* 
  (lambda* ()
    (set! global-var 200)
    (set! global-var (+ global-var 50))
    global-var))
(test-assert 
  (= (no-params-lambda* ) 250)
  "lambda* with no parameters should work with multiple expressions")

; Test 4: lambda* with multiple parameters and expressions
(define complex-lambda* 
  (lambda* (a b c)
    (define-mutable temp (+ a b))
    (set! temp (+ temp c))
    (* temp 2)))
(test-assert 
  (= (complex-lambda* 1 2 3) 12)  ; ((1+2)+3)*2 = 12
  "lambda* should work with multiple parameters and expressions")

; Test 5: Nested lambda* expressions
(define make-counter 
  (lambda* (start)
    (define-mutable count start)
    (lambda* ()
      (set! count (+ count 1))
      count)))
(define counter (make-counter 10))
(test-assert 
  (= (counter) 11)
  "nested lambda* should work - first call")

(test-assert 
  (= (counter) 12)
  "nested lambda* should work - second call")

; Test 6: lambda* with conditionals and multiple expressions
(define conditional-lambda* 
  (lambda* (x)
    (define-mutable result 0)
    (if (= x 0)
        (set! result 100)
        (set! result (* x 10)))
    (set! result (+ result 5))
    result))
(test-assert 
  (= (conditional-lambda* 0) 105)  ; 100 + 5
  "lambda* with conditionals should work - zero case")

(test-assert 
  (= (conditional-lambda* 3) 35)   ; (3*10) + 5
  "lambda* with conditionals should work - non-zero case")

; Test 7: lambda* used as higher-order function
(define apply-with-logging 
  (lambda* (func x)
    (define-mutable log-var 0)
    (set! log-var x)
    (define result (func x))
    (set! log-var (+ log-var result))
    result))
(define double (lambda (n) (* n 2)))
(test-assert 
  (= (apply-with-logging double 7) 14)
  "lambda* should work as higher-order function")

; Test 8: lambda* with recursive helper
(define factorial-lambda* 
  (lambda* (n)
    (define factorial-helper 
      (lambda (x acc)
        (if (= x 0)
            acc
            (factorial-helper (- x 1) (* acc x)))))
    (factorial-helper n 1)))
(test-assert 
  (= (factorial-lambda* 5) 120)
  "lambda* should work with recursive helpers")

; Test 9: Immediate lambda* invocation
(test-assert 
  (= ((lambda* (x y)
        (define temp (+ x y))
        (* temp 3)) 4 6) 30)  ; (4+6)*3 = 30
  "immediate lambda* invocation should work")

; Test 10: lambda* parameter shadowing with multiple expressions
(define outer-shadow-var 999)
(define shadow-lambda* 
  (lambda* (outer-shadow-var)
    (define-mutable temp outer-shadow-var)
    (set! temp (+ temp 1))
    temp))
(test-assert 
  (= (shadow-lambda* 5) 6)
  "lambda* parameter shadowing should work")

(test-assert 
  (= outer-shadow-var 999)
  "lambda* parameter shadowing should not affect outer scope")

; Test 11: lambda* with define-mutable in body
(define closure-lambda* 
  (lambda* (initial)
    (define-mutable state initial)
    (lambda* (delta)
      (set! state (+ state delta))
      state)))
(define stateful-func (closure-lambda* 100))
(test-assert 
  (= (stateful-func 10) 110)
  "lambda* with define-mutable should create stateful closures")

(test-assert 
  (= (stateful-func 5) 115)
  "lambda* stateful closure should maintain state")

; Test 12: Compare lambda vs lambda* behavior
(define regular-lambda-test (lambda (x) x))
(define lambda*-test (lambda* (x) x))
(test-assert 
  (= (regular-lambda-test 42) (lambda*-test 42))
  "lambda* should behave like lambda for single expressions")

; Test 13: lambda* with for-each (using library function)
(define-mutable sum-accumulator 0)
(define sum-list-lambda* 
  (lambda* (lyst)
    (set! sum-accumulator 0)
    (for-each (lambda (x) (set! sum-accumulator (+ sum-accumulator x))) lyst)
    sum-accumulator))
(test-assert 
  (= (sum-list-lambda* (list 1 2 3 4)) 10)
  "lambda* should work with library functions like for-each")

; Test 14: Empty body lambda* (should be equivalent to returning ())
(define empty-body-lambda* (lambda* (x)))
(test-assert 
  (nil? (empty-body-lambda* 42))
  "lambda* with empty body should return nil")

; Test 15: lambda* with complex expression sequencing
(define sequence-test-lambda* 
  (lambda* (x)
    (+ x 1)      ; This result is discarded
    (+ x 2)      ; This result is discarded  
    (+ x 3)))    ; This result is returned
(test-assert 
  (= (sequence-test-lambda* 5) 8)  ; 5 + 3 = 8
  "lambda* should return only the last expression's value")

;------------------------------------------------------------------------------
; foldr tests

; Test 1: Basic foldr with addition
(test-assert 
  (= (foldr + (list 1 2 3) 0) 6)
  "foldr should sum list elements")

; Test 2: Empty list should return init value
(test-assert 
  (= (foldr + () 42) 42)
  "foldr with empty list should return init value")

; Test 3: Single element list
(test-assert 
  (= (foldr + (list 5) 0) 5)
  "foldr with single element should work")

; Test 4: foldr with multiplication
(test-assert 
  (= (foldr * (list 2 3 4) 1) 24)
  "foldr should multiply list elements")

; Test 5: foldr with cons (should reconstruct the list)
(define reconstructed (foldr cons (list 1 2 3) ()))
(test-assert 
  (= (first reconstructed) 1)
  "foldr with cons should reconstruct list - first element")

(test-assert 
  (= (first (rest reconstructed)) 2)
  "foldr with cons should reconstruct list - second element")

(test-assert 
  (= (first (rest (rest reconstructed))) 3)
  "foldr with cons should reconstruct list - third element")

; Test 6: foldr with lambda function
(define subtract-from-acc (lambda (x acc) (- acc x)))
(test-assert 
  (= (foldr subtract-from-acc (list 1 2 3) 10) 4)
  "foldr should work with lambda functions")

; Test 7: foldr order matters (right associative)
; (foldr - (list 1 2 3) 0) = (- 1 (- 2 (- 3 0))) = (- 1 (- 2 3)) = (- 1 -1) = 2
(test-assert 
  (= (foldr - (list 1 2 3) 0) 2)
  "foldr should be right-associative")

; Test 8: foldr with wrapped operatives
(define wrapped-mult (wrap *))
(test-assert 
  (= (foldr wrapped-mult (list 2 3 4) 1) 24)
  "foldr should work with wrapped operatives")

; Test 9: foldr with different init values
(test-assert 
  (= (foldr + (list 1 2 3) 10) 16)
  "foldr should add init value to sum")

; Test 10: foldr with nested function calls
(define double-and-add (lambda (x acc) (+ (* x 2) acc)))
(test-assert 
  (= (foldr double-and-add (list 1 2 3) 0) 12)
  "foldr should work with complex functions")

;------------------------------------------------------------------------------
; Cond tests

; Test 1: Basic cond with true first condition
(test-assert 
  (= (cond ((= 1 1) 42))
     42)
  "cond should return value when first condition is true")

; Test 2: Basic cond with false first condition, true second
(test-assert
  (= (cond ((= 1 2) 10)
           ((= 2 2) 20))
     20)
  "cond should skip false conditions and return first true")

; Test 3: Multiple conditions, second one true
(test-assert
  (= (cond ((= 5 6) 100)
           ((= 3 3) 200)
           ((= 7 7) 300))
     200)
  "cond should return first true condition, not evaluate later ones")

; Test 4: No true conditions - should return nil
(test-assert
  (nil? (cond ((= 1 2) 10)
              ((= 3 4) 20)))
  "cond should return nil when no conditions are true")

; Test 5: Empty cond - should return nil
(test-assert 
  (nil? (cond))
  "cond with no clauses should return nil")

; Test 6: Complex expressions in conditions and results
(test-assert
  (= (cond ((= (+ 1 2) 4) (* 2 3))
           ((= (* 2 2) 4) (+ 10 5)))
     15)
  "cond should handle complex expressions in both test and result")

; Test 7: Side effects should only occur for evaluated branches
(define-mutable test-counter 0)
(define increment-counter (lambda () (set! test-counter (+ test-counter 1))))
(cond ((= 1 1) (increment-counter))
      ((= 2 2) (increment-counter)))
(test-assert 
  (= test-counter 1)
  "cond should only evaluate the first true branch")

; Test 8: Using Church Booleans directly
(test-assert 
  (= (cond (true "correct") 
           (false "wrong")) 
     "correct")
  "cond should work with Church Boolean values")

; Test 9: Variable references in conditions
(define x 5)
(define y 10)
(test-assert
  (= (cond ((= x 3) "no")
           ((= y 10) "yes")
           ((= x 5) "maybe"))
     "yes")
  "cond should work with variable references")

; Test 10: Nested cond expressions
(define nested-result 
  (cond ((= 1 2) "outer-false")
        ((= 2 2) (cond ((= 3 4) "inner-false")
                       ((= 5 5) "inner-true")))))
(test-assert 
  (= nested-result "inner-true")
  "cond should work when nested inside other cond expressions")

; Test 11: Short-circuit evaluation - later conditions shouldn't be evaluated
(define side-effect-var 0)
(define make-side-effect 
  (lambda () (define side-effect-var (+ side-effect-var 1))))
(cond ((= 1 1) "found")
      ((make-side-effect) "should not reach here"))
(test-assert 
  (= side-effect-var 0)
  "cond should not evaluate conditions after finding a true one")

; Test 12: Using cond with wrapped functions
(define wrapped-equal (wrap =))
(test-assert 
  (= (cond ((wrapped-equal 1 2) "no") ((wrapped-equal 3 3) "yes")) "yes")
  "cond should work with wrapped operatives")

; Test 13: Return values can be any type
(define string-result (cond ((= 1 2) 42) ((= 2 2) "string")))
(define number-result (cond ((= 1 1) 99) ((= 2 2) "string")))
(test-assert 
  (= string-result "string")
  "cond should return string values correctly")
(test-assert 
  (= number-result 99)
  "cond should return number values correctly")

; Test 14: Single clause cond
(test-assert 
  (= (cond ((= 7 7) "single")) "single")
  "cond with single true clause should work")

(test-assert 
  (nil? (cond ((= 7 8) "single")))
  "cond with single false clause should return nil")

; Test 15: Complex realistic example
(define classify-number
  (lambda (n)
    (cond ((= n 0) "zero")
          ((= n 1) "one") 
          ((= n 2) "two")
          ((nil? ()) "other"))))  ; Always true as fallback

(test-assert 
  (= (classify-number 0) "zero")
  "cond classifier should work for zero")

(test-assert 
  (= (classify-number 1) "one")
  "cond classifier should work for one")

(test-assert 
  (= (classify-number 99) "other")
  "cond classifier should work for default case")

;------------------------------------------------------------------------------
; get-current-environment tests

; Test 1: Environment capture
(define captured-env (get-current-environment))
(define test-var-in-env 123)
(test-assert 
  (= (eval (q test-var-in-env) captured-env) 123)
  "get-current-environment should capture current bindings")

;------------------------------------------------------------------------------
; for-each tests

; Test 1: Basic for-each
(define-mutable for-each-sum 0)
(define add-to-sum (lambda (x) (set! for-each-sum (+ for-each-sum x))))
(for-each add-to-sum (list 1 2 3))
(test-assert 
  (= for-each-sum 6)
  "for-each should apply function to each list element")

;------------------------------------------------------------------------------
; and/or/not tests

(test-assert (and) "(and) should return true")
(test-assert (and true) "(and true) should return true")
(test-assert (not (and false)) "(and false) should return false") 
(test-assert (and true true true)
  "(and true true true) should return true")
(test-assert (not (and false false false)) 
  "(and false false false) should return false")
(test-assert (not (and true false true))
  "(and true false true) should return false")

(define-mutable boolean-test-int 0)
(define boolean-test-set! (lambda* (n) (set! boolean-test-int n) true))

(and false (boolean-test-set! 1))
(test-assert (= 0 boolean-test-int)
  "and should short-circuit")

(test-assert (not (or))
  "(or) should return false")
(test-assert (or true) "(or true) should return true")
(test-assert (not (or false)) "(or false) should return false")
(test-assert (or true true true)
  "(or true true true) should return true")
(test-assert (not (or false false false))
  "(or false false false) shoud return false")
(test-assert (or false true false)
  "(or false true false) should return true")

(set! boolean-test-int 0)
(or true (boolean-test-int 1))
(test-assert (= 0 boolean-test-int)
  "or should short-circuit")

(test-assert (not (not true))
  "(not true) should return false")
(test-assert (not false)
  "(not false) should return true")

; Nested operations
(test-assert (and (or true false) (not false))
  "nested boolean operations should work")
(test-assert (or (and false true) (not false))
  "complex nested operations should work")

; Test with Church Boolean expressions
(test-assert (and (= 1 1) (nil? ()))
  "and should work with Church Boolean expressions")
(test-assert (or (= 1 2) (= 2 2))
  "or should work with Church Boolean expressions")
(test-assert (not (= 1 2))
  "not should work with Church Boolean expressions")

; Many arguments
(test-assert (and true true true true true true)
  "and should handle many true arguments")
(test-assert (not (and true true false true true))
  "and should handle false anywhere in many arguments")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Show test results
(if (= test-failures 0)
    "All library tests passed!"
    (do
      (define message "Library tests failed!")
      test-failures))