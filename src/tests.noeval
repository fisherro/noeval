; Test suite for the vau language library
; This file contains tests that are run after loading the standard library

; Set up test variables
(define-mutable test-failures 0)
(define-mutable test-count 0)

; Test helper functions
(define test-assert
  (vau (condition message) env
    (do
      (set! test-count (+ test-count 1))
      (try
        (if (eval condition env)
            (do
              (display "✓ ")
              (display message)
              (display "\n")
              "PASS")
            (do
              (set! test-failures (+ test-failures 1))
              (display "\e[31m✗ ")
              (display message)
              (display "\e[0m\n")
              message))
        (lambda* (error)
          (set! test-failures (+ test-failures 1))
          (display "\e[31m✗ ")
          (display message)
          (display "\n\t")
          (display error)
          (display "\e[0m\n"))))))

(define test-error
  (vau (expr message) env
    (do
      (define-mutable thrown 0)
      (try
        (eval expr env)
        (lambda (e) (set! thrown 1)))
      (if (= 1 thrown)
        (do
          (display "✓ ")
          (display message)
          (display "\n")
          "PASS")
        (do
          (set! test-failures (+ test-failures 1))
          (display "\e[31m✗ ")
          (display message)
          (display "\e[0m\n")
          message)))))

; Helper operative to create unevaluated expressions for testing
(define make-expr
  (vau args env args))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Test nested skip blocks

#skip
(displayln bogus1)
#skip
(displayln bogus2)
#end
(displayln bogus3)
#end

;------------------------------------------------------------------------------
; Try tests

(define-mutable try-happened 0)
(define-mutable error-happened 0)
(define-mutable finally-happened 0)

(try (set! try-happened 1)
     (lambda (e) (set! error-happened 1)))
(test-assert (and (= 1 try-happened)
                  (not (= 1 error-happened))
                  (not (= 1 finally-happened)))
             "try: if no error, error handler should not be evaluated")

(try (do (set! try-happened 2)
         (first 1))
     (lambda (e) (set! error-happened 2)))
(test-assert (and (= 2 try-happened)
                  (= 2 error-happened)
                  (not (= 2 finally-happened)))
             "try: if error, error handler should be evaluated")

(try (set! try-happened 3)
     (lambda (e) (set! error-happened 3))
     (lambda (r) (do (set! finally-happened 3)
                     r)))
(test-assert (and (= 3 try-happened)
                  (not (= 3 error-happened))
                  (= 3 finally-happened))
             "try: if no error, error handler should not be evaluated; finally, should")

(try (do (set! try-happened 4)
         (first 1))
     (lambda (e) (set! error-happened 4))
     (lambda (r) (do (set! finally-happened 4)
                     r)))
(test-assert (and (= 4 try-happened)
                  (= 4 error-happened)
                  (= 4 finally-happened))
             "try: if error, error and finally handlers should be evaluated")

;------------------------------------------------------------------------------

; Test: Basic quoting
(test-assert 
  (= (first (q (+ 1 2))) (q +))
  "q should prevent evaluation of expressions")

; Test list function
(test-assert 
  (nil? (list))
  "empty list should return nil")

;------------------------------------------------------------------------------
; eval-list tests

; Test eval-list function with unevaluated expressions
(define unevaluated-exprs (make-expr (+ 1 2) (* 3 4)))
(define result-list (eval-list unevaluated-exprs env))
(test-assert 
  (= (first result-list) 3)
  "eval-list should evaluate first element")

(test-assert 
  (= (first (rest result-list)) 12)
  "eval-list should evaluate second element")

(test-assert 
  (= (first (list 42)) 42)
  "single element list should work")

; Test 1: Basic eval-list with simple expressions
(define simple-exprs (list (q (+ 1 2)) (q (* 3 4))))
(define simple-results (eval-list simple-exprs (get-current-environment)))
(test-assert 
  (= (first simple-results) 3)
  "eval-list should evaluate first expression correctly")

(test-assert 
  (= (first (rest simple-results)) 12)
  "eval-list should evaluate second expression correctly")

; Test 2: eval-list with single expression
(define single-expr (list (q (+ 10 20))))
(define single-result (eval-list single-expr (get-current-environment)))
(test-assert 
  (= (first single-result) 30)
  "eval-list should work with single expression")

; Test 3: eval-list with empty list
(define empty-results (eval-list () (get-current-environment)))
(test-assert 
  (nil? empty-results)
  "eval-list with empty list should return nil")

; Test 4: eval-list with variable references
(define test-var-for-eval 42)
(define var-exprs (list (q test-var-for-eval) (q (+ test-var-for-eval 8))))
(define var-results (eval-list var-exprs (get-current-environment)))
(test-assert 
  (= (first var-results) 42)
  "eval-list should evaluate variable references")

(test-assert 
  (= (first (rest var-results)) 50)
  "eval-list should evaluate expressions with variables")

; Test 5: eval-list with nested expressions
(define nested-exprs (list (q (+ 1 (+ 2 3))) (q (* (- 10 5) 2))))
(define nested-results (eval-list nested-exprs (get-current-environment)))
(test-assert 
  (= (first nested-results) 6)
  "eval-list should handle nested expressions - first")

(test-assert 
  (= (first (rest nested-results)) 10)
  "eval-list should handle nested expressions - second")

; Test 6: eval-list with side effects - expressions should be evaluated once each
(define-mutable eval-list-counter 0)
(define increment-expr (q (do (set! eval-list-counter (+ eval-list-counter 1)) eval-list-counter)))
(define side-effect-exprs (list increment-expr (q (+ eval-list-counter 100))))

; This test may reveal the invoke issue if eval-list-helper evaluates expressions multiple times
(define side-effect-results (eval-list side-effect-exprs (get-current-environment)))
(test-assert 
  (= (first side-effect-results) 1)
  "eval-list should evaluate side-effect expressions exactly once - first result")

(test-assert 
  (= (first (rest side-effect-results)) 101)
  "eval-list should evaluate expressions in order with proper side effects")

; Test 7: eval-list with quoted expressions  
(define quote-exprs (list (q (q hello)) (q (q world))))
(define quote-results (eval-list quote-exprs (get-current-environment)))
(test-assert 
  (= (first quote-results) (q hello))
  "eval-list should handle quoted expressions")

(test-assert 
  (= (first (rest quote-results)) (q world))
  "eval-list should handle multiple quoted expressions")

; Test 8: eval-list with mixed expression types
(define mixed-exprs (list (q 42) (q (+ 2 3)) (q test-var-for-eval)))
(define mixed-results (eval-list mixed-exprs (get-current-environment)))
(test-assert 
  (= (first mixed-results) 42)
  "eval-list should handle mixed types - literal")

(test-assert 
  (= (first (rest mixed-results)) 5)
  "eval-list should handle mixed types - expression")

(test-assert 
  (= (first (rest (rest mixed-results))) 42)
  "eval-list should handle mixed types - variable")

; Test 9: eval-list should work with library functions
(define lib-exprs (list (q (first (list 1 2 3))) (q (rest (list 4 5 6)))))
(define lib-results (eval-list lib-exprs (get-current-environment)))
(test-assert 
  (= (first lib-results) 1)
  "eval-list should work with library functions - first")

(test-assert 
  (= (first (first (rest lib-results))) 5)
  "eval-list should work with library functions - rest result")

; Test 10: Error case that demonstrates the invoke issue
; This might fail due to the incorrect invoke usage in eval-list-helper
(define error-prone-exprs (list (q (+ 1 2)) (q (display "TEST")) (q (* 3 4))))

; This test might reveal issues if the invoke problem causes expressions to be 
; evaluated incorrectly or multiple times
(define complex-results (eval-list error-prone-exprs (get-current-environment)))
(test-assert 
  (= (first complex-results) 3)
  "eval-list should handle complex expression list - first")

(test-assert 
  (= (first (rest (rest complex-results))) 12)
  "eval-list should handle complex expression list - third")

;------------------------------------------------------------------------------
; Wrap tests

; Test wrap functionality
(define simple-op (vau (x y) env (cons x (cons y ()))))
(define wrapped-simple (wrap simple-op))

; Test that wrap evaluates arguments
(define a 1)
(define b 2)
(test-assert 
  (nil? (rest (rest (wrapped-simple a b))))
  "wrap should create proper list structure")

; Test wrap with built-in operatives
(define wrapped-plus (wrap +))
(define x 5)
(define y 10)
(test-assert 
  (= (wrapped-plus x y) 15)
  "wrapped + should evaluate arguments and add them")

(test-assert 
  (= (wrapped-plus (+ 1 2) 4) 7)
  "wrapped + should evaluate complex arguments")

; Test wrap with environment-dependent operatives
(define env-dependent-op 
  (vau (x) env 
    (eval x env)))  ; This needs the environment parameter to work

(define wrapped-env-op (wrap env-dependent-op))
(define test-var 42)

(test-assert 
  (= (wrapped-env-op (q test-var)) 42)
  "wrap should preserve environment context for user-defined operatives")

;------------------------------------------------------------------------------
; vau* tests

; Test 1: Basic vau* with multiple expressions
(define-mutable vau-side-effect 0)
(define basic-vau* 
  (vau* (x) env
    (set! vau-side-effect (+ vau-side-effect 1))
    (set! vau-side-effect (* vau-side-effect 2))
    x))  ; Return the unevaluated argument

; Test the side effects occurred
(basic-vau* dummy-expr)
(test-assert 
  (= vau-side-effect 2)
  "vau* should execute multiple expressions for side effects")

; Test 2: vau* with environment parameter usage  
(define env-using-vau*
  (vau* (expr) dyn-env
    (define temp-var 42)
    (define result (eval expr dyn-env))
    (* result 2)))
(test-assert 
  (= (env-using-vau* (+ 3 4)) 14)
  "vau* should be able to use environment parameter")

; Test 3: vau* with no expressions (empty body)
(define empty-vau* (vau* (x) env))
(test-assert 
  (nil? (empty-vau* hello))
  "vau* with empty body should return nil")

; Test 4: vau* with multiple parameters - test that it accepts them
(define multi-param-vau*
  (vau* (a b c) env
    (define first-arg a)
    (define second-arg b) 
    (define third-arg c)
    first-arg))  ; Just return first arg to test it works
(test-assert 
  (= (multi-param-vau* 42 y z) 42)
  "vau* should handle multiple parameters correctly")

; Test 5: vau* that evaluates some arguments selectively  
(define selective-eval-vau*
  (vau* (first-expr second-expr) dyn-env
    (define first-val (eval first-expr dyn-env))
    first-val))  ; Just return evaluated first arg
(test-assert 
  (= (selective-eval-vau* (+ 2 3) (+ 4 5)) 5)
  "vau* should allow selective evaluation of arguments")

; Test 6: Compare vau* vs regular vau behavior
(define regular-vau-multi
  (vau (x) env
    (do (define temp x)
        (* 2 2)
        temp)))
(define equivalent-vau*
  (vau* (x) env
    (define temp x)
    (* 2 2)
    temp))

; Test that both return the same unevaluated expression by using them with numbers
(test-assert 
  (= (regular-vau-multi 123) (equivalent-vau* 123))
  "vau* should behave equivalently to vau with do block")

; Test 7: vau* with conditional logic
(define conditional-vau*
  (vau* (test-expr then-expr else-expr) dyn-env
    (define test-result (eval test-expr dyn-env))
    (if test-result
        then-expr
        else-expr)))
(test-assert 
  (= (conditional-vau* (= 1 1) 42 99) 42)
  "vau* should work with conditional logic - true case")

(test-assert 
  (= (conditional-vau* (= 1 2) 42 99) 99)  
  "vau* should work with conditional logic - false case")

; Test 8: vau* with single expression (should work like regular vau)
(define single-expr-vau* (vau* (x) env x))
(test-assert 
  (= (single-expr-vau* 777) 777)
  "vau* with single expression should work like regular vau")

; Test 9: vau* with complex expression sequencing  
(define-mutable sequence-counter 0)
(define sequence-test-vau*
  (vau* (x) env
    (set! sequence-counter (+ sequence-counter 1))  ; Side effect
    (set! sequence-counter (+ sequence-counter 10)) ; Side effect  
    x))  ; Return unevaluated x

(define seq-result (sequence-test-vau* final-expr))
(test-assert 
  (and (= sequence-counter 11) (= seq-result (q final-expr)))
  "vau* should execute all expressions and return last value")

; vau used in higher-order context
(define test-vau (vau (x) env (eval x env)))
(define higher-order-test (lambda (op arg) (op arg)))

(test-assert 
  (= (higher-order-test test-vau 123) 123)
  "vau should work when passed to and called from other functions")

; Test 10: vau* used in higher-order context
(define test-vau* (vau* (x) env (eval x env)))
(define higher-order-test (lambda (op arg) (op arg)))

(test-assert 
  (= (higher-order-test test-vau* 123) 123)
  "vau* should work when passed to and called from other functions")

; Test 11: vau* with recursive pattern (simplified)
(define recursive-vau*
  (vau* (x) dyn-env
    (define helper-result x)  ; Simplified - just pass through
    helper-result))
(test-assert 
  (= (recursive-vau* test-expr) (q test-expr))
  "vau* should work with internal definitions")

; Test 12: Test that vau* creates proper operative (doesn't evaluate args)
(define-mutable arg-eval-test 0)
(define arg-test-vau*
  (vau* (expr) env
    (set! arg-eval-test 999)
    expr))

; The argument (+ arg-eval-test 1) should NOT be evaluated
(define unevald-result (arg-test-vau* (+ arg-eval-test 1)))
(test-assert 
  (= arg-eval-test 999)  ; Should be 999 from vau* body, not from argument
  "vau* should not evaluate its arguments")

;------------------------------------------------------------------------------
; Lambda tests

; Test 1: Basic lambda creation and invocation
(define add-two (lambda (x) (+ x 2)))
(test-assert 
  (= (add-two 5) 7)
  "basic lambda should work with single parameter")

(test-assert 
  (= (add-two 10) 12)
  "lambda should work with different arguments")

; Test 2: Lambda with multiple parameters
(define multiply (lambda (x y) (* x y)))
(test-assert 
  (= (multiply 3 4) 12)
  "lambda should work with multiple parameters")

(test-assert 
  (= (multiply 7 8) 56)
  "lambda with multiple parameters should work consistently")

; Test 3: Lambda with no parameters
(define get-constant (lambda () 42))
(test-assert 
  (= (get-constant) 42)
  "lambda with no parameters should work")

; Test 4: Lambda that uses closure variables
(define closure-var 100)
(define add-closure-var (lambda (y) (+ closure-var y)))
(test-assert 
  (= (add-closure-var 23) 123)
  "lambda should capture closure variables")

; ! This test fails!
; Test 5: Nested lambda expressions
(define make-adder (lambda (n) (lambda (x) (+ x n))))
(define add-five (make-adder 5))
(test-assert 
  (= (add-five 10) 15)
  "nested lambdas should work")

(test-assert 
  (= (add-five 7) 12)
  "nested lambdas should work consistently")

; Test 6: Lambda arguments are evaluated (unlike vau)
(define eval-and-double (lambda (x) (* x 2)))
(test-assert 
  (= (eval-and-double (+ 3 4)) 14)
  "lambda should evaluate its arguments")

; Test 7: Compare with vau - lambda evaluates args, vau doesn't
(define vau-version (vau (x) env x))
(define lambda-version (lambda (x) x))

; Create test expressions
(define test-expr (make-expr (+ 1 2)))
(define vau-result (vau-version (+ 1 2)))
(define lambda-result (lambda-version (+ 1 2)))

(test-assert 
  (= lambda-result 3)
  "lambda should evaluate arguments before passing to body")

; Test 8: Lambda with complex body expressions
(define complex-calc (lambda (a b) (+ (* a a) (* b b))))
(test-assert 
  (= (complex-calc 3 4) 25)
  "lambda should handle complex expressions in body")

; Test 9: Lambda used with higher-order functions
(define apply-twice (lambda (f x) (f (f x))))
(define increment (lambda (n) (+ n 1)))
(test-assert 
  (= (apply-twice increment 5) 7)
  "lambda should work as higher-order function")

; Test 10: Lambda with conditional logic
(define abs-positive (lambda (x) (if (= x 0) 0 x)))
(test-assert 
  (= (abs-positive 5) 5)
  "lambda should work with conditionals")

(test-assert 
  (= (abs-positive 0) 0)
  "lambda conditional should handle zero case")

; Test 11: Lambda that returns another lambda
(define curry-add (lambda (x) (lambda (y) (+ x y))))
(define add-ten (curry-add 10))
(test-assert 
  (= (add-ten 5) 15)
  "lambda should support currying")

; Test 12: Test lambda via square function
(define square (lambda (x) (* x x)))

(test-assert 
  (= (square 4) 16)
  "library square function should work")

(test-assert 
  (= (square 7) 49)
  "library square function should work consistently")

; Test 13: Immediate lambda invocation
(test-assert 
  (= ((lambda (x y) (+ x y)) 8 9) 17)
  "immediate lambda invocation should work")

(test-assert 
  (= ((lambda () (* 6 7))) 42)
  "immediate parameterless lambda invocation should work")

; Test 14: Lambda parameter shadowing
(define outer-var 999)
(define shadow-test (lambda (outer-var) (* outer-var 2)))
(test-assert 
  (= (shadow-test 5) 10)
  "lambda parameters should shadow outer variables")

(test-assert 
  (= outer-var 999)
  "lambda parameter shadowing should not affect outer scope")

; Test 15: Lambda composition
(define double (lambda (x) (* x 2)))
(define add-one (lambda (x) (+ x 1)))
(define double-then-add-one (lambda (x) (add-one (double x))))
(test-assert 
  (= (double-then-add-one 5) 11)
  "lambda composition should work")

;------------------------------------------------------------------------------
; lambda* tests (multi-expression lambda)

; Test 1: Basic lambda* with single expression (should work like regular lambda)
(define simple-lambda* (lambda* (x) (+ x 5)))
(test-assert 
  (= (simple-lambda* 10) 15)
  "lambda* should work with single expression")

; Test 2: lambda* with multiple expressions
(define-mutable side-effect-counter 0)
(define multi-expr-lambda* 
  (lambda* (x) 
    (set! side-effect-counter (+ side-effect-counter 1))
    (set! side-effect-counter (+ side-effect-counter x))
    (* x 2)))
(test-assert 
  (= (multi-expr-lambda* 3) 6)
  "lambda* should return value of last expression")

(test-assert 
  (= side-effect-counter 4)  ; 1 + 3 = 4
  "lambda* should execute all expressions for side effects")

; Test 3: lambda* with no parameters and multiple expressions
(define-mutable global-var 100)
(define no-params-lambda* 
  (lambda* ()
    (set! global-var 200)
    (set! global-var (+ global-var 50))
    global-var))
(test-assert 
  (= (no-params-lambda* ) 250)
  "lambda* with no parameters should work with multiple expressions")

; Test 4: lambda* with multiple parameters and expressions
(define complex-lambda* 
  (lambda* (a b c)
    (define-mutable temp (+ a b))
    (set! temp (+ temp c))
    (* temp 2)))
(test-assert 
  (= (complex-lambda* 1 2 3) 12)  ; ((1+2)+3)*2 = 12
  "lambda* should work with multiple parameters and expressions")

; Test 5: Nested lambda* expressions
(define make-counter 
  (lambda* (start)
    (define-mutable count start)
    (lambda* ()
      (set! count (+ count 1))
      count)))
(define counter (make-counter 10))
(test-assert 
  (= (counter) 11)
  "nested lambda* should work - first call")

(test-assert 
  (= (counter) 12)
  "nested lambda* should work - second call")

; Test 6: lambda* with conditionals and multiple expressions
(define conditional-lambda* 
  (lambda* (x)
    (define-mutable result 0)
    (if (= x 0)
        (set! result 100)
        (set! result (* x 10)))
    (set! result (+ result 5))
    result))
(test-assert 
  (= (conditional-lambda* 0) 105)  ; 100 + 5
  "lambda* with conditionals should work - zero case")

(test-assert 
  (= (conditional-lambda* 3) 35)   ; (3*10) + 5
  "lambda* with conditionals should work - non-zero case")

; Test 7: lambda* used as higher-order function
(define apply-with-logging 
  (lambda* (func x)
    (define-mutable log-var 0)
    (set! log-var x)
    (define result (func x))
    (set! log-var (+ log-var result))
    result))
(define double (lambda (n) (* n 2)))
(test-assert 
  (= (apply-with-logging double 7) 14)
  "lambda* should work as higher-order function")

; Test 8: lambda* with recursive helper
(define factorial-lambda* 
  (lambda* (n)
    (define factorial-helper 
      (lambda (x acc)
        (if (= x 0)
            acc
            (factorial-helper (- x 1) (* acc x)))))
    (factorial-helper n 1)))
(test-assert 
  (= (factorial-lambda* 5) 120)
  "lambda* should work with recursive helpers")

; Test 9: Immediate lambda* invocation
(test-assert 
  (= ((lambda* (x y)
        (define temp (+ x y))
        (* temp 3)) 4 6) 30)  ; (4+6)*3 = 30
  "immediate lambda* invocation should work")

; Test 10: lambda* parameter shadowing with multiple expressions
(define outer-shadow-var 999)
(define shadow-lambda* 
  (lambda* (outer-shadow-var)
    (define-mutable temp outer-shadow-var)
    (set! temp (+ temp 1))
    temp))
(test-assert 
  (= (shadow-lambda* 5) 6)
  "lambda* parameter shadowing should work")

(test-assert 
  (= outer-shadow-var 999)
  "lambda* parameter shadowing should not affect outer scope")

; Test 11: lambda* with define-mutable in body
(define closure-lambda* 
  (lambda* (initial)
    (define-mutable state initial)
    (lambda* (delta)
      (set! state (+ state delta))
      state)))
(define stateful-func (closure-lambda* 100))
(test-assert 
  (= (stateful-func 10) 110)
  "lambda* with define-mutable should create stateful closures")

(test-assert 
  (= (stateful-func 5) 115)
  "lambda* stateful closure should maintain state")

; Test 12: Compare lambda vs lambda* behavior
(define regular-lambda-test (lambda (x) x))
(define lambda*-test (lambda* (x) x))
(test-assert 
  (= (regular-lambda-test 42) (lambda*-test 42))
  "lambda* should behave like lambda for single expressions")

; Test 13: lambda* with for-each (using library function)
(define-mutable sum-accumulator 0)
(define sum-list-lambda* 
  (lambda* (lyst)
    (set! sum-accumulator 0)
    (for-each (lambda (x) (set! sum-accumulator (+ sum-accumulator x))) lyst)
    sum-accumulator))
(test-assert 
  (= (sum-list-lambda* (list 1 2 3 4)) 10)
  "lambda* should work with library functions like for-each")

; Test 14: Empty body lambda* (should be equivalent to returning ())
(define empty-body-lambda* (lambda* (x)))
(test-assert 
  (nil? (empty-body-lambda* 42))
  "lambda* with empty body should return nil")

; Test 15: lambda* with complex expression sequencing
(define sequence-test-lambda* 
  (lambda* (x)
    (+ x 1)      ; This result is discarded
    (+ x 2)      ; This result is discarded  
    (+ x 3)))    ; This result is returned
(test-assert 
  (= (sequence-test-lambda* 5) 8)  ; 5 + 3 = 8
  "lambda* should return only the last expression's value")

;------------------------------------------------------------------------------
; foldr tests

; Test 1: Basic foldr with addition
(test-assert 
  (= (foldr + (list 1 2 3) 0) 6)
  "foldr should sum list elements")

; Test 2: Empty list should return init value
(test-assert 
  (= (foldr + () 42) 42)
  "foldr with empty list should return init value")

; Test 3: Single element list
(test-assert 
  (= (foldr + (list 5) 0) 5)
  "foldr with single element should work")

; Test 4: foldr with multiplication
(test-assert 
  (= (foldr * (list 2 3 4) 1) 24)
  "foldr should multiply list elements")

; Test 5: foldr with cons (should reconstruct the list)
(define reconstructed (foldr cons (list 1 2 3) ()))
(test-assert 
  (= (first reconstructed) 1)
  "foldr with cons should reconstruct list - first element")

(test-assert 
  (= (first (rest reconstructed)) 2)
  "foldr with cons should reconstruct list - second element")

(test-assert 
  (= (first (rest (rest reconstructed))) 3)
  "foldr with cons should reconstruct list - third element")

; Test 6: foldr with lambda function
(define subtract-from-acc (lambda (x acc) (- acc x)))
(test-assert 
  (= (foldr subtract-from-acc (list 1 2 3) 10) 4)
  "foldr should work with lambda functions")

; Test 7: foldr order matters (right associative)
; (foldr - (list 1 2 3) 0) = (- 1 (- 2 (- 3 0))) = (- 1 (- 2 3)) = (- 1 -1) = 2
(test-assert 
  (= (foldr - (list 1 2 3) 0) 2)
  "foldr should be right-associative")

; Test 8: foldr with wrapped operatives
(define wrapped-mult (wrap *))
(test-assert 
  (= (foldr wrapped-mult (list 2 3 4) 1) 24)
  "foldr should work with wrapped operatives")

; Test 9: foldr with different init values
(test-assert 
  (= (foldr + (list 1 2 3) 10) 16)
  "foldr should add init value to sum")

; Test 10: foldr with nested function calls
(define double-and-add (lambda (x acc) (+ (* x 2) acc)))
(test-assert 
  (= (foldr double-and-add (list 1 2 3) 0) 12)
  "foldr should work with complex functions")

;------------------------------------------------------------------------------
; foldl tests

; Test 1: Basic foldl with addition
(test-assert 
  (= (foldl + 0 (list 1 2 3)) 6)
  "foldl should sum list elements")

; Test 2: Empty list should return init value
(test-assert 
  (= (foldl + 42 ()) 42)
  "foldl with empty list should return init value")

; Test 3: Single element list
(test-assert 
  (= (foldl + 0 (list 5)) 5)
  "foldl with single element should work")

; Test 4: foldl with multiplication
(test-assert 
  (= (foldl * 1 (list 2 3 4)) 24)
  "foldl should multiply list elements")

; Test 5: foldl with lambda function
(define accumulate-subtract (lambda (acc x) (- acc x)))
(test-assert 
  (= (foldl accumulate-subtract 10 (list 1 2 3)) 4)
  "foldl should work with lambda functions")

; Test 6: foldl order matters (left associative)
; (foldl - 0 (list 1 2 3)) = (- (- (- 0 1) 2) 3) = (- (- -1 2) 3) = (- -3 3) = -6
(test-assert 
  (= (foldl - 0 (list 1 2 3)) -6)
  "foldl should be left-associative")

; Test 7: Compare foldl vs foldr associativity
; foldl: (- (- (- 0 1) 2) 3) = -6
; foldr: (- 1 (- 2 (- 3 0))) = (- 1 (- 2 3)) = (- 1 -1) = 2
(test-assert 
  (not (= (foldl - 0 (list 1 2 3)) (foldr - (list 1 2 3) 0)))
  "foldl and foldr should give different results for non-associative operations")

; Test 8: foldl with wrapped operatives
(define wrapped-mult (wrap *))
(test-assert 
  (= (foldl wrapped-mult 1 (list 2 3 4)) 24)
  "foldl should work with wrapped operatives")

; Test 9: foldl with different init values
(test-assert 
  (= (foldl + 10 (list 1 2 3)) 16)
  "foldl should include init value in accumulation")

; Test 10: foldl with complex functions
(define double-and-add (lambda (acc x) (+ acc (* x 2))))
(test-assert 
  (= (foldl double-and-add 0 (list 1 2 3)) 12)
  "foldl should work with complex functions")

; Test 11: foldl building a reversed list (classic use case)
(define reverse-via-foldl (lambda (lyst) (foldl (lambda (acc x) (cons x acc)) () lyst)))
(define reversed (reverse-via-foldl (list 1 2 3)))
(test-assert 
  (= (first reversed) 3)
  "foldl should build reversed list - first element")

(test-assert 
  (= (first (rest reversed)) 2)
  "foldl should build reversed list - second element")

(test-assert 
  (= (first (rest (rest reversed))) 1)
  "foldl should build reversed list - third element")

; Test 12: foldl with string concatenation (if we had string concat)
; Using display capture would be complex, so we'll test with numbers instead
(define number-concat (lambda (acc x) (+ (* acc 10) x)))
(test-assert 
  (= (foldl number-concat 0 (list 1 2 3)) 123)
  "foldl should work for accumulative concatenation-like operations")

; Test 13: foldl with side effects
(define-mutable foldl-side-effect 0)
(define increment-and-add (lambda* (acc x) 
  (set! foldl-side-effect (+ foldl-side-effect 1))
  (+ acc x)))
(test-assert 
  (= (foldl increment-and-add 0 (list 10 20 30)) 60)
  "foldl should work with side effects - result")

(test-assert 
  (= foldl-side-effect 3)
  "foldl should work with side effects - side effect count")

; Test 14: foldl parameter order consistency check
; foldl takes (func init list) while foldr takes (func list init)
; Let's verify the parameter order is correct
(define test-func (lambda (acc elem) (cons elem acc)))
(define foldl-result (foldl test-func () (list 1 2 3)))
(test-assert 
  (= (first foldl-result) 3)
  "foldl parameter order should be (func init list)")

; Test 15: foldl with nested function calls
(define complex-accumulator 
  (lambda (acc x) 
    (+ acc (if (= (/ x 2) 1) (* x 2) x))))
(test-assert 
  (= (foldl complex-accumulator 0 (list 1 2 3))
     (complex-accumulator (complex-accumulator (complex-accumulator 0 1) 2) 3))
  "foldl should work with nested conditionals in accumulator")
(test-assert 
  (= (foldl complex-accumulator 0 (list 1 2 3)) 11)
  "foldl should work with nested conditionals in accumulator")

;------------------------------------------------------------------------------
; prepend tests (list* equivalent)

; Test 1: Basic prepend with single final argument
(test-assert 
  (= (first (prepend 1 (list 2 3))) 1)
  "prepend should add element to front of list")

(test-assert 
  (= (first (rest (prepend 1 (list 2 3)))) 2)
  "prepend should preserve existing list elements")

; Test 2: Multiple elements prepended
(define result-list (prepend 1 2 3 (list 4 5)))
(test-assert 
  (= (first result-list) 1)
  "prepend should handle multiple elements - first")

(test-assert 
  (= (first (rest result-list)) 2)
  "prepend should handle multiple elements - second")

(test-assert 
  (= (first (rest (rest result-list))) 3)
  "prepend should handle multiple elements - third")

(test-assert 
  (= (first (rest (rest (rest result-list)))) 4)
  "prepend should preserve final list - first element")

; Test 3: Prepend to empty list
(test-assert 
  (= (first (prepend 42 ())) 42)
  "prepend should work with empty final list")

(test-assert 
  (nil? (rest (prepend 42 ())))
  "prepend with empty list should create single-element list")

#skip
; Skipping this test because `=` doesn't support lists.
; Test 4: Single argument (should return the argument itself)
(test-assert 
  (= (prepend 123) 123)
  "prepend with single argument should return that argument")

(test-assert 
  (= (prepend (list 1 2 3)) (list 1 2 3))
  "prepend with single list argument should return the list")
#end

; Test 5: No arguments (should return empty)
(test-assert 
  (nil? (prepend))
  "prepend with no arguments should return nil")

; Test 6: Argument evaluation - expressions should be evaluated once
(define-mutable prepend-eval-counter 0)
(define increment-and-return 
  (lambda* (n) 
    (set! prepend-eval-counter (+ prepend-eval-counter 1))
    n))

(define prepend-result (prepend (increment-and-return 10) 
                               (increment-and-return 20) 
                               (list 30)))
(test-assert 
  (= prepend-eval-counter 2)
  "prepend should evaluate each argument exactly once")

(test-assert 
  (= (first prepend-result) 10)
  "prepend should use evaluated argument values - first")

(test-assert 
  (= (first (rest prepend-result)) 20)
  "prepend should use evaluated argument values - second")

; Test 7: Complex expressions as arguments
(test-assert 
  (= (first (prepend (+ 1 2) (list 4 5))) 3)
  "prepend should evaluate complex expressions")

; Test 8: Nested prepend calls
(test-assert 
  (= (first (prepend 1 (prepend 2 (list 3)))) 1)
  "prepend should work when nested")

; Test 9: prepend with different data types
(define mixed-result (prepend "hello" 42 (list "world" 99)))
(test-assert 
  (= (first mixed-result) "hello")
  "prepend should work with mixed data types - string")

(test-assert 
  (= (first (rest mixed-result)) 42)
  "prepend should work with mixed data types - number")

(test-assert 
  (= (first (rest (rest mixed-result))) "world")
  "prepend should work with mixed data types - final list string")

; Test 10: prepend compared to manual cons chains
(define manual-chain (cons 1 (cons 2 (cons 3 (list 4 5)))))
(define prepend-chain (prepend 1 2 3 (list 4 5)))
(test-assert 
  (= (first manual-chain) (first prepend-chain))
  "prepend should be equivalent to manual cons chain - first")

(test-assert 
  (= (first (rest manual-chain)) (first (rest prepend-chain)))
  "prepend should be equivalent to manual cons chain - second")

(test-assert 
  (= (first (rest (rest manual-chain))) (first (rest (rest prepend-chain))))
  "prepend should be equivalent to manual cons chain - third")

;------------------------------------------------------------------------------
; Cond tests

; Test 1: Basic cond with true first condition
(test-assert 
  (= (cond ((= 1 1) 42))
     42)
  "cond should return value when first condition is true")

; Test 2: Basic cond with false first condition, true second
(test-assert
  (= (cond ((= 1 2) 10)
           ((= 2 2) 20))
     20)
  "cond should skip false conditions and return first true")

; Test 3: Multiple conditions, second one true
(test-assert
  (= (cond ((= 5 6) 100)
           ((= 3 3) 200)
           ((= 7 7) 300))
     200)
  "cond should return first true condition, not evaluate later ones")

; Test 4: No true conditions - should return nil
(test-assert
  (nil? (cond ((= 1 2) 10)
              ((= 3 4) 20)))
  "cond should return nil when no conditions are true")

; Test 5: Empty cond - should return nil
(test-assert 
  (nil? (cond))
  "cond with no clauses should return nil")

; Test 6: Complex expressions in conditions and results
(test-assert
  (= (cond ((= (+ 1 2) 4) (* 2 3))
           ((= (* 2 2) 4) (+ 10 5)))
     15)
  "cond should handle complex expressions in both test and result")

; Test 7: Side effects should only occur for evaluated branches
(define-mutable test-counter 0)
(define increment-counter (lambda () (set! test-counter (+ test-counter 1))))
(cond ((= 1 1) (increment-counter))
      ((= 2 2) (increment-counter)))
(test-assert 
  (= test-counter 1)
  "cond should only evaluate the first true branch")

; Test 8: Using Church Booleans directly
(test-assert 
  (= (cond (true "correct") 
           (false "wrong")) 
     "correct")
  "cond should work with Church Boolean values")

; Test 9: Variable references in conditions
(define x 5)
(define y 10)
(test-assert
  (= (cond ((= x 3) "no")
           ((= y 10) "yes")
           ((= x 5) "maybe"))
     "yes")
  "cond should work with variable references")

; Test 10: Nested cond expressions
(define nested-result 
  (cond ((= 1 2) "outer-false")
        ((= 2 2) (cond ((= 3 4) "inner-false")
                       ((= 5 5) "inner-true")))))
(test-assert 
  (= nested-result "inner-true")
  "cond should work when nested inside other cond expressions")

; Test 11: Short-circuit evaluation - later conditions shouldn't be evaluated
(define side-effect-var 0)
(define make-side-effect 
  (lambda () (define side-effect-var (+ side-effect-var 1))))
(cond ((= 1 1) "found")
      ((make-side-effect) "should not reach here"))
(test-assert 
  (= side-effect-var 0)
  "cond should not evaluate conditions after finding a true one")

; Test 12: Using cond with wrapped functions
(define wrapped-equal (wrap =))
(test-assert 
  (= (cond ((wrapped-equal 1 2) "no") ((wrapped-equal 3 3) "yes")) "yes")
  "cond should work with wrapped operatives")

; Test 13: Return values can be any type
(define string-result (cond ((= 1 2) 42) ((= 2 2) "string")))
(define number-result (cond ((= 1 1) 99) ((= 2 2) "string")))
(test-assert 
  (= string-result "string")
  "cond should return string values correctly")
(test-assert 
  (= number-result 99)
  "cond should return number values correctly")

; Test 14: Single clause cond
(test-assert 
  (= (cond ((= 7 7) "single")) "single")
  "cond with single true clause should work")

(test-assert 
  (nil? (cond ((= 7 8) "single")))
  "cond with single false clause should return nil")

; Test 15: Complex realistic example
(define classify-number
  (lambda (n)
    (cond ((= n 0) "zero")
          ((= n 1) "one") 
          ((= n 2) "two")
          ((nil? ()) "other"))))  ; Always true as fallback

(test-assert 
  (= (classify-number 0) "zero")
  "cond classifier should work for zero")

(test-assert 
  (= (classify-number 1) "one")
  "cond classifier should work for one")

(test-assert 
  (= (classify-number 99) "other")
  "cond classifier should work for default case")

;------------------------------------------------------------------------------
; get-current-environment tests

; Test 1: Environment capture
(define captured-env (get-current-environment))
(define test-var-in-env 123)
(test-assert 
  (= (eval (q test-var-in-env) captured-env) 123)
  "get-current-environment should capture current bindings")

;------------------------------------------------------------------------------
; for-each tests

; Test 1: Basic for-each
(define-mutable for-each-sum 0)
(define add-to-sum (lambda (x) (set! for-each-sum (+ for-each-sum x))))
(for-each add-to-sum (list 1 2 3))
(test-assert 
  (= for-each-sum 6)
  "for-each should apply function to each list element")

;------------------------------------------------------------------------------
; and/or/not tests

(test-assert (and) "(and) should return true")
(test-assert (and true) "(and true) should return true")
(test-assert (not (and false)) "(and false) should return false") 
(test-assert (and true true true)
  "(and true true true) should return true")
(test-assert (not (and false false false)) 
  "(and false false false) should return false")
(test-assert (not (and true false true))
  "(and true false true) should return false")

(define-mutable boolean-test-int 0)
(define boolean-test-set! (lambda* (n) (set! boolean-test-int n) true))

(and false (boolean-test-set! 1))
(test-assert (= 0 boolean-test-int)
  "and should short-circuit")

(test-assert (not (or))
  "(or) should return false")
(test-assert (or true) "(or true) should return true")
(test-assert (not (or false)) "(or false) should return false")
(test-assert (or true true true)
  "(or true true true) should return true")
(test-assert (not (or false false false))
  "(or false false false) shoud return false")
(test-assert (or false true false)
  "(or false true false) should return true")

(set! boolean-test-int 0)
(or true (boolean-test-int 1))
(test-assert (= 0 boolean-test-int)
  "or should short-circuit")

(test-assert (not (not true))
  "(not true) should return false")
(test-assert (not false)
  "(not false) should return true")

; Nested operations
(test-assert (and (or true false) (not false))
  "nested boolean operations should work")
(test-assert (or (and false true) (not false))
  "complex nested operations should work")

; Test with Church Boolean expressions
(test-assert (and (= 1 1) (nil? ()))
  "and should work with Church Boolean expressions")
(test-assert (or (= 1 2) (= 2 2))
  "or should work with Church Boolean expressions")
(test-assert (not (= 1 2))
  "not should work with Church Boolean expressions")

; Many arguments
(test-assert (and true true true true true true)
  "and should handle many true arguments")
(test-assert (not (and true true false true true))
  "and should handle false anywhere in many arguments")

;------------------------------------------------------------------------------
; Error condition tests (now that we have try/test-error)

; Test arithmetic errors
(test-error (+ 1 "hello") "arithmetic operations should reject non-numeric arguments")
(test-error (- "world" 5) "subtraction should reject string arguments")
(test-error (* true 3) "multiplication should reject boolean arguments")
(test-error (/ 10 "two") "division should reject non-numeric arguments")

; Test list operation errors  
(test-error (first 42) "first should reject non-list arguments")
(test-error (rest "hello") "rest should reject non-list arguments")
(test-error (cons) "cons should require exactly 2 arguments")
(test-error (cons 1) "cons should require exactly 2 arguments") 
(test-error (cons 1 2 3) "cons should require exactly 2 arguments")

; Test undefined variable errors
(test-error undefined-variable-name "accessing undefined variables should throw")
(test-error (+ undefined-var 5) "undefined variables in expressions should throw")

; Test eval errors
(test-error (eval) "eval should require exactly 2 arguments")
(test-error (eval 42) "eval should require exactly 2 arguments")
(test-error (eval 1 2 3) "eval should require exactly 2 arguments")
(test-error (eval 42 "not-env") "eval should reject non-environment second argument")

; Test vau parameter errors
(test-error (vau) "vau should require exactly 3 arguments")
(test-error (vau (x)) "vau should require exactly 3 arguments")
(test-error (vau (x) env) "vau should require exactly 3 arguments")
(test-error (vau "not-list" env body) "vau should reject non-list parameter list")
(test-error (vau (123) env body) "vau should reject non-symbol parameters")

; Test define errors
(test-error (define) "define should require exactly 2 arguments")
(test-error (define x) "define should require exactly 2 arguments")
(test-error (define x 1 2) "define should require exactly 2 arguments")
(test-error (define 123 "value") "define should reject non-symbol names")
(test-error (define "string" 42) "define should reject string names")

; Test define-mutable errors
(test-error (define-mutable) "define-mutable should require exactly 2 arguments")
(test-error (define-mutable x) "define-mutable should require exactly 2 arguments") 
(test-error (define-mutable 42 "value") "define-mutable should reject non-symbol names")

; Test set! errors
(test-error (set!) "set! should require exactly 2 arguments")
(test-error (set! x) "set! should require exactly 2 arguments")
(test-error (set! "string" 42) "set! should reject non-symbol names")
(test-error (set! 123 "value") "set! should reject numeric names")

; Test set! on immutable bindings
(define immutable-var 42)
(test-error (set! immutable-var 99) "set! should reject immutable bindings")

; Test set! on undefined variables
(test-error (set! completely-undefined 123) "set! should reject undefined variables")

; Test wrap errors
(test-error (wrap) "wrap should require exactly 1 argument")
(test-error (wrap +  *) "wrap should require exactly 1 argument")
#skip
; I think we'd need to implement an operative? predicate to do this.
(test-error (wrap 42) "wrap should reject non-operative arguments")
(test-error (wrap "string") "wrap should reject non-operative arguments")
#end

; Test invoke errors  
(test-error (invoke) "invoke should require at least 1 argument")
(test-error (invoke 42 (list 1 2)) "invoke should reject non-operative first argument")
(test-error (invoke + "not-list") "invoke should reject non-list second argument")

; Test comparison operator edge cases
(test-error (=) "= should require at least 2 arguments")
(test-error (= 1) "= should require at least 2 arguments")

; Test Church Boolean edge cases - operatives called as values
(test-error (42 "true-branch" "false-branch") "integers are not operatives")
(test-error ("hello" 1 2) "strings are not operatives")
(test-error (() 1 2) "nil is not an operative")

;------------------------------------------------------------------------------
; Exception propagation tests

; Test that exceptions propagate through nested calls
(define error-thrower (lambda () (first 42)))
(define error-wrapper (lambda () (error-thrower)))
(test-error (error-wrapper) "exceptions should propagate through function calls")

; Test exception in vau operative
(define error-vau (vau (x) env (rest "invalid")))
(test-error (error-vau dummy) "exceptions should propagate from vau operatives")

; Test exception in wrapped operative
(define error-op (vau (x) env (first x)))  ; Will fail if x is not a list
(define wrapped-error (wrap error-op))
(test-error (wrapped-error 42) "exceptions should propagate from wrapped operatives")

; Test exception in lambda
(define error-lambda (lambda (x) (+ x "invalid")))
(test-error (error-lambda 5) "exceptions should propagate from lambda functions")

; Test exception in higher-order function usage
(define apply-func (lambda (f x) (f x)))
(define bad-func (lambda (n) (/ n "zero")))
(test-error (apply-func bad-func 10) "exceptions should propagate through higher-order functions")

;------------------------------------------------------------------------------
; Recovery tests using try

; Test basic exception recovery
(define-mutable recovery-test 0)
(try (do (set! recovery-test 1)
         (first "invalid"))
     (lambda* (error)
       (set! recovery-test 99)))
(test-assert 
  (= recovery-test 99)
  "try should allow recovery from exceptions")

; Test that try-block executes normally when no error
(define-mutable normal-execution 0)
(try (set! normal-execution 42)
     (lambda* (error) (set! normal-execution -1)))
(test-assert 
  (= normal-execution 42)
  "try should execute normally when no exception occurs")

; Test exception information is passed to handler
(define-mutable error-info "")
(try (rest 123)
     (lambda* (error)
       (set! error-info (first (rest error)))))  ; Get error message
(test-assert 
  (not (= error-info ""))
  "try should pass error information to handler")

; Test nested try blocks
(define-mutable nested-result 0)
(try (try (first "outer-error")
          (lambda* (e) (set! nested-result 1)))
     (lambda* (e) (set! nested-result 2)))
(test-assert 
  (= nested-result 1)
  "nested try blocks should work correctly")

; Test try with finally clause
(define-mutable finally-executed 0)
(define-mutable try-result "")
(define result (try "success-value"
                    (lambda* (error) "error-value")
                    (lambda* (value) 
                      (set! finally-executed 1)
                      (set! try-result value)
                      value)))
(test-assert 
  (and (= finally-executed 1) (= try-result "success-value"))
  "try with finally should execute finally clause on success")

; Test try/finally with exception
(define-mutable finally-on-error 0)
(try (first 42)
     (lambda* (error) "handled")
     (lambda* (result) 
       (set! finally-on-error 1)
       result))
(test-assert 
  (= finally-on-error 1)
  "try with finally should execute finally clause on error")

;------------------------------------------------------------------------------
; Environment isolation tests

#skip
; I'm not sure about this one.
; We could have `try` introduce a new environment.
; But maybe we should leave that up to the user.
; (Especially once we've implemented let.)

; Test that errors don't corrupt environment
(define test-env-var 100)
(try (do (define test-env-var 200)  ; This should fail...
         (rest "invalid"))          ; ...before this error
     (lambda* (error) "caught"))
; The original binding should be preserved
(test-assert 
  (= test-env-var 100)
  "exceptions should not corrupt environment bindings")
#end

; Test exception in environment parameter usage
(define env-error-vau (vau (expr) env (eval expr "not-an-env")))
(test-error (env-error-vau (+ 1 2)) "invalid environment usage should throw")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Show test results
(if (= test-failures 0)
    "All library tests passed!"
    (do
      (define message "Library tests failed!")
      test-failures))