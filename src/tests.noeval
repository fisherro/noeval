; Test suite for the vau language library
; This file contains tests that are run after loading the standard library

(define verbose false)

; Set up test variables
(define-mutable test-failures 0)
(define-mutable test-count 0)
(define-mutable test-dots 0)

; Test helper functions
(define test-assert
  (vau (condition message) env
    (do
      (set! test-count (+ test-count 1))
      (try
        (if (eval condition env)
            (if verbose
                (do
                  (display "✓ ")
                  (display message)
                  (display "\n")
                  "PASS")
                (do
                  (display ".")
                  (flush)
                  (set! test-dots (+ test-dots 1))
                  "PASS"))
            (do
              (set! test-failures (+ test-failures 1))
              (when (not (= 0 test-dots))
                (do (displayln "")
                    (set! test-dots 0)))
              (display "\e[31m✗ ")
              (display message)
              (display "\e[0m\n")
              message))
        (lambda* (error)
          (set! test-failures (+ test-failures 1))
          (display "\e[31m✗ ")
          (display message)
          (display "\n\t")
          (display error)
          (display "\e[0m\n"))))))

(define test-error
  (vau (expr message) env
    (do
      (define-mutable thrown 0)
      (try
        (eval expr env)
        (lambda (e) (set! thrown 1)))
      (if (= 1 thrown)
        (if verbose
            (do
              (display "✓ ")
              (display message)
              (display "\n")
              "PASS")
            (do
              (display ".")
              (flush)
              (set! test-dots (+ test-dots 1))
              "PASS"))
        (do
          (set! test-failures (+ test-failures 1))
          (when (not (= 0 test-dots))
            (do (displayln "")
                (set! test-dots 0)))
          (display "\e[31m✗ ")
          (display message)
          (display "\e[0m\n")
          message)))))

; Helper operative to create unevaluated expressions for testing
(define make-expr
  (vau args env args))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Test nested skip blocks

#skip
(displayln bogus1)
#skip
(displayln bogus2)
#end
(displayln bogus3)
#end

;------------------------------------------------------------------------------
; = tests
; = is a builtin operative, but we want to test it here
(lndisplayln "= tests")

; Test = argument checking
(test-error (=)       "= cannot be called without arguments")
(test-error (= 1)     "= cannot be called with only one argument")
(test-error (= 1 2 3) "= cannot be called with three or more arguments")
(test-error (= 1 "1") "= should raise an error for mixed types")

; Test = with numbers
(test-assert (= 1 1) "= should return true for the same number")
(test-assert (not (= 1 2)) "= should return false for different numbers")

; Test = with strings
(test-assert (= "hello" "hello")
  "= should return true for the same string")
(test-assert (not (= "hello" "world"))
  "= should return false for the different strings")

; Test = with symbols
(test-assert (= (q hello) (q hello))
  "= should return true for the same symbol")
(test-assert (not (= (q hello) (q world)))
  "= should return false for the different symbols")

; Test = with mutable bindings
(test-assert ((lambda* ()
                (define-mutable x 1)
                (define-mutable y 1)
                (= x y)))
  "= should return true for mutable bindings with the same value")

(test-assert ((lambda* ()
                (define-mutable x 1)
                (define-mutable y 2)
                (not (= x y))))
  "= should return false for mutable bindings with the different values")

(test-assert ((lambda* ()
                (define-mutable x 1)
                (= x 1)))
  "= should return true for a mutable binding and the same value")

(test-assert ((lambda* ()
                (define-mutable x 1)
                (not (= x 2))))
  "= should return false for a mutable binding and a different value")

; Test = with lists
(test-assert (= () ())
  "(= () ()) should return true")

(test-assert (not (= () (list 1)))
  "= should return false for () and a non-empty list")

(test-assert (= (list 1 2 3) (list 1 2 3))
  "= should return true for identical lists")

(test-assert (not (= (list 1 2 3) (list 1 2 4)))
  "= should return false for different lists")

(test-assert (= (list (list 1 2 3)
                      (list 4 5 6))
                (list (list 1 2 3)
                      (list 4 5 6)))
  "= should return true for identical nested lists")

(test-assert (not (= (list (list 1 2 3)
                           (list 4 5 6))
                     (list (list 1 2 3)
                           (list 4 1 6))))
  "= should return false for different nested lists")

; Test = with environments
(test-assert ((vau () env (= env env)))
  "= should return true for the same environment")

(test-assert ((vau () outer-env
                ((vau () inner-env
                   (not (= outer-env inner-env))))))
  "= should return false for different environments")

; Test Booleans
(test-assert (= true true)
  "(= true true) should return true")

(test-assert (= false false)
  "(= false false) should return true")

(test-assert (not (= true false))
  "(= true false) should return false")

(test-assert (not (= true false))
  "(= false true) should return false")

;------------------------------------------------------------------------------
; Try tests
(lndisplayln "try tests")

(define-mutable try-happened 0)
(define-mutable error-happened 0)
(define-mutable finally-happened 0)

(try (set! try-happened 1)
     (lambda (e) (set! error-happened 1)))
(test-assert (and (= 1 try-happened)
                  (not (= 1 error-happened))
                  (not (= 1 finally-happened)))
             "try: if no error, error handler should not be evaluated")

(try (do (set! try-happened 2)
         (first 1))
     (lambda (e) (set! error-happened 2)))
(test-assert (and (= 2 try-happened)
                  (= 2 error-happened)
                  (not (= 2 finally-happened)))
             "try: if error, error handler should be evaluated")

(try (set! try-happened 3)
     (lambda (e) (set! error-happened 3))
     (lambda (r) (do (set! finally-happened 3)
                     r)))
(test-assert (and (= 3 try-happened)
                  (not (= 3 error-happened))
                  (= 3 finally-happened))
             "try: if no error, error handler should not be evaluated; finally, should")

(try (do (set! try-happened 4)
         (first 1))
     (lambda (e) (set! error-happened 4))
     (lambda (r) (do (set! finally-happened 4)
                     r)))
(test-assert (and (= 4 try-happened)
                  (= 4 error-happened)
                  (= 4 finally-happened))
             "try: if error, error and finally handlers should be evaluated")

;------------------------------------------------------------------------------
; Exception propagation tests

; Test that exceptions propagate through nested calls
(define error-thrower (lambda () (first 42)))
(define error-wrapper (lambda () (error-thrower)))
(test-error (error-wrapper) "exceptions should propagate through function calls")

; Test exception in vau operative
(define error-vau (vau (x) env (rest "invalid")))
(test-error (error-vau dummy) "exceptions should propagate from vau operatives")

; Test exception in wrapped operative
(define error-op (vau (x) env (first x)))  ; Will fail if x is not a list
(define wrapped-error (wrap error-op))
(test-error (wrapped-error 42) "exceptions should propagate from wrapped operatives")

; Test exception in lambda
(define error-lambda (lambda (x) (+ x "invalid")))
(test-error (error-lambda 5) "exceptions should propagate from lambda functions")

; Test exception in higher-order function usage
(define apply-func (lambda (f x) (f x)))
(define bad-func (lambda (n) (/ n "zero")))
(test-error (apply-func bad-func 10) "exceptions should propagate through higher-order functions")

;------------------------------------------------------------------------------
; Recovery tests using try

; Test basic exception recovery
(define-mutable recovery-test 0)
(try (do (set! recovery-test 1)
         (first "invalid"))
     (lambda* (error)
       (set! recovery-test 99)))
(test-assert 
  (= recovery-test 99)
  "try should allow recovery from exceptions")

; Test that try-block executes normally when no error
(define-mutable normal-execution 0)
(try (set! normal-execution 42)
     (lambda* (error) (set! normal-execution -1)))
(test-assert 
  (= normal-execution 42)
  "try should execute normally when no exception occurs")

; Test exception information is passed to handler
(define-mutable error-info "")
(try (rest 123)
     (lambda* (error)
       (set! error-info (first (rest error)))))  ; Get error message
(test-assert 
  (not (= error-info ""))
  "try should pass error information to handler")

; Test nested try blocks
(define-mutable nested-result 0)
(try (try (first "outer-error")
          (lambda* (e) (set! nested-result 1)))
     (lambda* (e) (set! nested-result 2)))
(test-assert 
  (= nested-result 1)
  "nested try blocks should work correctly")

; Test try with finally clause
(define-mutable finally-executed 0)
(define-mutable try-result "")
(define result (try "success-value"
                    (lambda* (error) "error-value")
                    (lambda* (value) 
                      (set! finally-executed 1)
                      (set! try-result value)
                      value)))
(test-assert 
  (and (= finally-executed 1) (= try-result "success-value"))
  "try with finally should execute finally clause on success")

; Test try/finally with exception
(define-mutable finally-on-error 0)
(try (first 42)
     (lambda* (error) "handled")
     (lambda* (result) 
       (set! finally-on-error 1)
       result))
(test-assert 
  (= finally-on-error 1)
  "try with finally should execute finally clause on error")

;------------------------------------------------------------------------------
; raise tests
(lndisplayln "raise tests")

; Test 1: Basic raise with string message
(define-mutable raise-test-result "")
(try (raise "test error message")
     (lambda (error)
       (set! raise-test-result (first (rest error)))))
(test-assert 
  (= raise-test-result "test error message")
  "raise should create error with string message")

; Test 2: raise with non-string message (should convert to string representation)
(define-mutable raise-number-result "")
(try (raise 42)
     (lambda (error)
       (set! raise-number-result (first (rest error)))))
(test-assert 
  (= raise-number-result "42")
  "raise should convert non-string messages to string representation")

; Test 3: raise interrupts execution flow
(define-mutable raise-flow-test 0)
(try (do (set! raise-flow-test 1)
         (raise "stop here")
         (set! raise-flow-test 2))  ; This should not execute
     (lambda (error)
       (set! raise-flow-test (+ raise-flow-test 10))))
(test-assert 
  (= raise-flow-test 11)  ; 1 + 10, not 12
  "raise should interrupt execution flow")

; Test 4: raise error structure - should be (error message context stack-trace)
(define-mutable error-structure ())
(try (raise "structure test")
     (lambda (error)
       (set! error-structure error)))
(test-assert 
  (= (first error-structure) (q error))
  "raise should create error with 'error tag")

(test-assert 
  (= (first (rest error-structure)) "structure test")
  "raise should include message as second element")

(test-assert 
  (= (length error-structure) 4)
  "raise should create 4-element error structure")

; Test 5: raise with symbol message
(define-mutable raise-symbol-result "")
(try (raise (q test-symbol))
     (lambda (error)
       (set! raise-symbol-result (first (rest error)))))
(test-assert 
  (= raise-symbol-result "test-symbol")
  "raise should handle symbol messages")

; Test 6: raise propagates through function calls
(define error-throwing-func 
  (lambda (msg) (raise msg)))
(define wrapper-func 
  (lambda (msg) (error-throwing-func msg)))

(define-mutable propagation-result "")
(try (wrapper-func "propagated error")
     (lambda (error)
       (set! propagation-result (first (rest error)))))
(test-assert 
  (= propagation-result "propagated error")
  "raise should propagate through function call stack")

; Test 7: raise in vau operative
(define error-vau 
  (vau (msg) env (raise (eval msg env))))

(define-mutable vau-error-result "")
(try (error-vau "vau error")
     (lambda (error)
       (set! vau-error-result (first (rest error)))))
(test-assert 
  (= vau-error-result "vau error")
  "raise should work from within vau operatives")

; Test 8: raise with wrapped operative
(define wrapped-raiser (wrap (vau (msg) env (raise msg))))

(define-mutable wrapped-error-result "")
(try (wrapped-raiser "wrapped error")
     (lambda (error)
       (set! wrapped-error-result (first (rest error)))))
(test-assert 
  (= wrapped-error-result "wrapped error")
  "raise should work from wrapped operatives")

; Test 9: raise with complex message (list)
(define-mutable complex-msg-result "")
(try (raise (list "error" "with" "details"))
     (lambda (error)
       (set! complex-msg-result (first (rest error)))))
(test-assert 
  (not (= complex-msg-result ""))
  "raise should handle complex message types")

; Test 10: Multiple raise calls - only first should be caught
(define-mutable multi-raise-count 0)
(try (do (raise "first error")
         (raise "second error"))  ; Should not reach here
     (lambda (error)
       (set! multi-raise-count (+ multi-raise-count 1))))
(test-assert 
  (= multi-raise-count 1)
  "only first raise should be caught per try block")

; Test 11: raise in nested try blocks - inner catch should handle
(define-mutable nested-raise-result "")
(try (try (raise "inner error")
          (lambda (inner-error)
            (set! nested-raise-result "caught inner")
            (raise "outer error")))
     (lambda (outer-error)
       (set! nested-raise-result "caught outer")))
(test-assert 
  (= nested-raise-result "caught outer")
  "raise should work correctly in nested try blocks")

; Test 12: raise with side effects before raising
(define-mutable side-effect-before-raise 0)
(try (do (set! side-effect-before-raise 42)
         (raise "after side effect"))
     (lambda (error)
       (set! side-effect-before-raise (+ side-effect-before-raise 8))))
(test-assert 
  (= side-effect-before-raise 50)  ; 42 + 8
  "side effects before raise should be preserved")

; Test 13: raise with higher-order functions
(define map-with-raiser 
  (lambda (lst)
    (map (lambda (x) 
           (if (= x 3) 
               (raise "found three")
               (* x 2)))
         lst)))

(define-mutable hof-raise-result "")
(try (map-with-raiser (list 1 2 3 4))
     (lambda (error)
       (set! hof-raise-result (first (rest error)))))
(test-assert 
  (= hof-raise-result "found three")
  "raise should work within higher-order functions")

; Test 14: raise error conditions
(test-error (raise) "raise should require exactly 1 argument")
(test-error (raise "msg1" "msg2") "raise should require exactly 1 argument")

; Test 15: raise with Church Boolean message
(define church-bool-msg (= 5 5))  ; This is the true operative
(define-mutable church-msg-result "")
(try (raise church-bool-msg)
     (lambda (error)
       (set! church-msg-result (first (rest error)))))
(test-assert 
  (not (= church-msg-result ""))
  "raise should handle Church Boolean messages")

; Test 16: raise with apply
(define-mutable apply-raise-result "")
(try (apply raise (list "applied error"))
     (lambda (error)
       (set! apply-raise-result (first (rest error)))))
(test-assert 
  (= apply-raise-result "applied error")
  "raise should work with apply")

; Test 17: raise with mutable variable message
(define-mutable error-msg-var "mutable error")
(define-mutable mutable-msg-result "")
(try (raise error-msg-var)
     (lambda (error)
       (set! mutable-msg-result (first (rest error)))))
(test-assert 
  (= mutable-msg-result "mutable error")
  "raise should work with mutable variable messages")

#skip
; The current design decision is that try does not create an environment
; Test 18: raise doesn't affect environment bindings
(define pre-raise-var 100)
(try (do (define pre-raise-var 200)
         (raise "environment test"))
     (lambda (error) "handled"))
(test-assert 
  (= pre-raise-var 100)
  "raise should not corrupt environment bindings")
#end

; Test 19: raise in conditional expressions
(define conditional-raiser
  (lambda (condition msg)
    (if condition
        (raise msg)
        "no error")))

(define-mutable conditional-result "")
(try (conditional-raiser true "conditional error")
     (lambda (error)
       (set! conditional-result (first (rest error)))))
(test-assert 
  (= conditional-result "conditional error")
  "raise should work in conditional expressions")

(test-assert 
  (= (conditional-raiser false "should not raise") "no error")
  "raise should not be called when condition is false")

; Test 20: raise with empty string message
(define-mutable empty-msg-result "not-set")
(try (raise "")
     (lambda (error)
       (set! empty-msg-result (first (rest error)))))
(test-assert 
  (= empty-msg-result "")
  "raise should handle empty string messages")

; Test 21: raise with finally block
(define-mutable finally-with-raise 0)
(try (raise "finally test")
     (lambda (error) "handled")
     (lambda* (result) 
       (set! finally-with-raise 42)
       result))
(test-assert 
  (= finally-with-raise 42)
  "finally block should execute even when error is raised")

; Test 22: raise interrupts lambda execution
(define interrupt-lambda 
  (lambda (x)
    (let ((result (* x 2)))
      (if (> result 10)
          (raise "result too large")
          result))))

(test-assert 
  (= (interrupt-lambda 3) 6)
  "lambda should return normally when no error")

(define-mutable interrupt-result "")
(try (interrupt-lambda 8)
     (lambda (error)
       (set! interrupt-result (first (rest error)))))
(test-assert 
  (= interrupt-result "result too large")
  "raise should interrupt lambda execution")

; Test 23: raise preserves evaluation context
(define context-test-func
  (lambda (a b)
    (let ((sum (+ a b)))
      (if (> sum 20)
          (raise "sum too large")
          sum))))

(define-mutable context-result ())
(try (context-test-func 15 10)
     (lambda (error)
       (set! context-result (first (rest error)))))
(test-assert 
  (= context-result "sum too large")
  "raise should preserve evaluation context - message")

;------------------------------------------------------------------------------
(lndisplayln "misc tests")

; Test: Basic quoting
(test-assert 
  (= (first (q (+ 1 2))) (q +))
  "q should prevent evaluation of expressions")

; Test list function
(test-assert 
  (nil? (list))
  "empty list should return nil")

;------------------------------------------------------------------------------
; get-current-environment tests

; Test 1: Environment capture
(define captured-env (get-current-environment))
(define test-var-in-env 123)
(test-assert 
  (= (eval (q test-var-in-env) captured-env) 123)
  "get-current-environment should capture current bindings")

;------------------------------------------------------------------------------
; typeof tests
(lndisplayln "typeof and derived forms tests")

; Test 1: typeof with numbers
(test-assert 
  (= (typeof 42) (q number))
  "typeof should return 'number for integers")

(test-assert 
  (= (typeof 0) (q number))
  "typeof should return 'number for zero")

(test-assert 
  (= (typeof -5) (q number))
  "typeof should return 'number for negative integers")

; Test 2: typeof with strings
(test-assert 
  (= (typeof "hello") (q string))
  "typeof should return 'string for string literals")

(test-assert 
  (= (typeof "") (q string))
  "typeof should return 'string for empty strings")

(test-assert 
  (= (typeof "multi word string") (q string))
  "typeof should return 'string for multi-word strings")

; Test 3: typeof with symbols
(test-assert 
  (= (typeof (q hello)) (q symbol))
  "typeof should return 'symbol for quoted symbols")

(test-assert 
  (= (typeof (q +)) (q symbol))
  "typeof should return 'symbol for operator symbols")

; Test 4: typeof with nil
(test-assert 
  (= (typeof ()) (q nil))
  "typeof should return 'nil for empty list")

; Test 5: typeof with cons cells
(test-assert 
  (= (typeof (list 1 2 3)) (q cons-cell))
  "typeof should return 'cons-cell for lists")

(test-assert 
  (= (typeof (cons 1 2)) (q cons-cell))
  "typeof should return 'cons-cell for cons pairs")

; Test 6: typeof with operatives
(define test-vau (vau (x) env x))
(test-assert 
  (= (typeof test-vau) (q operative))
  "typeof should return 'operative for user-defined operatives")

(test-assert 
  (= (typeof +) (q operative))
  "typeof should return 'operative for built-in operatives")

(define test-lambda (lambda (x) x))
(test-assert 
  (= (typeof test-lambda) (q operative))
  "typeof should return 'operative for lambda functions")

; Test 7: typeof with Church Booleans
(test-assert 
  (= (typeof true) (q operative))
  "typeof should return 'operative for Church Boolean true")

(test-assert 
  (= (typeof false) (q operative))
  "typeof should return 'operative for Church Boolean false")

; Test 8: typeof with environments
(test-assert 
  (= (typeof (get-current-environment)) (q environment))
  "typeof should return 'environment for environments")

(define captured-env ((vau () env env)))
(test-assert 
  (= (typeof captured-env) (q environment))
  "typeof should return 'environment for captured environments")

; Test 9: typeof with mutable bindings
(define-mutable test-mutable 42)
(test-assert 
  (= (typeof test-mutable) (q number))
  "typeof should return underlying type for mutable bindings")

; Test 10: typeof with complex expressions
(test-assert 
  (= (typeof (+ 1 2)) (q number))
  "typeof should work with evaluated expressions")

(test-assert 
  (= (typeof (list 1 2 3)) (q cons-cell))
  "typeof should work with function results")

; Test 11: typeof error conditions
(test-error (typeof) "typeof should require exactly 1 argument")
(test-error (typeof 42 extra) "typeof should require exactly 1 argument")

; Test 12: typeof with apply
(test-assert 
  (= (apply typeof (list "test")) (q string))
  "typeof should work with apply")

; Test 13: typeof with nested structures
(test-assert 
  (= (typeof (list (list 1 2) 3)) (q cons-cell))
  "typeof should return type of outer structure for nested lists")

; Test 14: typeof with library-generated values
(test-assert 
  (= (typeof (map (lambda (x) x) (list 1 2))) (q cons-cell))
  "typeof should work with library-generated lists")

(test-assert 
  (= (typeof (filter even? (list 1 2 3 4))) (q cons-cell))
  "typeof should work with filter results")

; Test 15: typeof with wrapped operatives
(define wrapped-plus (wrap +))
(test-assert 
  (= (typeof wrapped-plus) (q operative))
  "typeof should return 'operative for wrapped operatives")

;------------------------------------------------------------------------------
; number? tests

; Test 1: Basic number recognition
(test-assert 
  (= (number? 42) true)
  "number? should return true for positive integers")

(test-assert 
  (= (number? 0) true)
  "number? should return true for zero")

(test-assert 
  (= (number? -5) true)
  "number? should return true for negative integers")

; Test 2: Non-numbers should return false
(test-assert 
  (= (number? "42") false)
  "number? should return false for string representations of numbers")

(test-assert 
  (= (number? (q number)) false)
  "number? should return false for the symbol 'number")

(test-assert 
  (= (number? ()) false)
  "number? should return false for nil")

(test-assert 
  (= (number? (list 1 2 3)) false)
  "number? should return false for lists")

; Test 3: number? as Church Boolean
(test-assert 
  (= ((number? 7) "is-number" "not-number") "is-number")
  "number? should work as Church Boolean - number case")

(test-assert 
  (= ((number? "seven") "is-number" "not-number") "not-number")
  "number? should work as Church Boolean - non-number case")

; Test 4: number? with computed values
(test-assert 
  (= (number? (+ 1 2)) true)
  "number? should work with computed numbers")

(test-assert 
  (= (number? (length (list 1 2 3))) true)
  "number? should work with function results that are numbers")

; Test 5: number? with various non-numeric types
(test-assert 
  (= (number? true) false)
  "number? should return false for Church Boolean true")

(test-assert 
  (= (number? false) false)
  "number? should return false for Church Boolean false")

(test-assert 
  (= (number? (get-current-environment)) false)
  "number? should return false for environments")

; Test 6: number? with mutable bindings
(define-mutable mutable-number 123)
(test-assert 
  (= (number? mutable-number) true)
  "number? should work with mutable number bindings")

(define-mutable mutable-string "hello")
(test-assert 
  (= (number? mutable-string) false)
  "number? should work with mutable non-number bindings")

; Test 7: number? with library functions
(define numbers-list (filter number? (list 1 "two" 3 "four" 5)))
(test-assert 
  (= (first numbers-list) 1)
  "number? should work with filter - first number")

(test-assert 
  (= (first (rest (rest numbers-list))) 5)
  "number? should work with filter - last number")

; Test 8: number? error conditions
(test-error (number?) "number? should require exactly 1 argument")
(test-error (number? 42 extra) "number? should require exactly 1 argument")

; Test 9: number? with apply
(test-assert 
  (= ((apply number? (list 99)) "yes" "no") "yes")
  "number? should work with apply")

; Test 10: number? with map
(define number-checks (map number? (list 1 "two" 3)))
(test-assert 
  (= ((first number-checks) "num" "not") "num")
  "number? should work with map - first result")

(test-assert 
  (= ((first (rest number-checks)) "num" "not") "not")
  "number? should work with map - second result")

;------------------------------------------------------------------------------
; string? tests

; Test 1: Basic string recognition
(test-assert 
  (= (string? "hello") true)
  "string? should return true for string literals")

(test-assert 
  (= (string? "") true)
  "string? should return true for empty strings")

(test-assert 
  (= (string? "multi word string") true)
  "string? should return true for multi-word strings")

; Test 2: Non-strings should return false
(test-assert 
  (= (string? 42) false)
  "string? should return false for numbers")

(test-assert 
  (= (string? (q hello)) false)
  "string? should return false for symbols")

(test-assert 
  (= (string? ()) false)
  "string? should return false for nil")

(test-assert 
  (= (string? (list 1 2 3)) false)
  "string? should return false for lists")

; Test 3: string? as Church Boolean
(test-assert 
  (= ((string? "test") "is-string" "not-string") "is-string")
  "string? should work as Church Boolean - string case")

(test-assert 
  (= ((string? 42) "is-string" "not-string") "not-string")
  "string? should work as Church Boolean - non-string case")

; Test 4: string? with various types
(test-assert 
  (= (string? true) false)
  "string? should return false for Church Booleans")

(test-assert 
  (= (string? (get-current-environment)) false)
  "string? should return false for environments")

; Test 5: string? with mutable bindings
(define-mutable mutable-string "world")
(test-assert 
  (= (string? mutable-string) true)
  "string? should work with mutable string bindings")

(define-mutable mutable-number 456)
(test-assert 
  (= (string? mutable-number) false)
  "string? should work with mutable non-string bindings")

; Test 6: string? error conditions
(test-error (string?) "string? should require exactly 1 argument")
(test-error (string? "hello" extra) "string? should require exactly 1 argument")

; Test 7: string? with apply and library functions
(test-assert 
  (= ((apply string? (list "applied")) "yes" "no") "yes")
  "string? should work with apply")

(define string-checks (map string? (list "one" 2 "three")))
(test-assert 
  (= ((first string-checks) "str" "not") "str")
  "string? should work with map - first result")

;------------------------------------------------------------------------------
; symbol? tests

; Test 1: Basic symbol recognition
(test-assert 
  (= (symbol? (q hello)) true)
  "symbol? should return true for quoted symbols")

(test-assert 
  (= (symbol? (q +)) true)
  "symbol? should return true for operator symbols")

(test-assert 
  (= (symbol? (q symbol)) true)
  "symbol? should return true for the word 'symbol")

; Test 2: Non-symbols should return false
(test-assert 
  (= (symbol? "hello") false)
  "symbol? should return false for strings")

(test-assert 
  (= (symbol? 42) false)
  "symbol? should return false for numbers")

(test-assert 
  (= (symbol? ()) false)
  "symbol? should return false for nil")

(test-assert 
  (= (symbol? (list 1 2)) false)
  "symbol? should return false for lists")

; Test 3: symbol? as Church Boolean
(test-assert 
  (= ((symbol? (q test)) "is-symbol" "not-symbol") "is-symbol")
  "symbol? should work as Church Boolean - symbol case")

(test-assert 
  (= ((symbol? "test") "is-symbol" "not-symbol") "not-symbol")
  "symbol? should work as Church Boolean - non-symbol case")

; Test 4: symbol? with various types
(test-assert 
  (= (symbol? true) false)
  "symbol? should return false for Church Boolean operatives")

(test-assert 
  (= (symbol? (lambda (x) x)) false)
  "symbol? should return false for lambda functions")

; Test 5: symbol? with computed symbols
(test-assert 
  (= (symbol? (first (list (q computed) 2 3))) true)
  "symbol? should work with computed symbol values")

; Test 6: symbol? error conditions
(test-error (symbol?) "symbol? should require exactly 1 argument")
(test-error (symbol? (q test) extra) "symbol? should require exactly 1 argument")

; Test 7: symbol? with library functions
(define symbol-items (filter symbol? (list (q one) 2 (q three) "four")))
(test-assert 
  (= (first symbol-items) (q one))
  "symbol? should work with filter - first symbol")

(test-assert 
  (= (first (rest symbol-items)) (q three))
  "symbol? should work with filter - second symbol")

;------------------------------------------------------------------------------
; list? tests

; Test 1: Basic list recognition
(test-assert 
  (= (list? ()) true)
  "list? should return true for empty list (nil)")

(test-assert 
  (= (list? (list 1 2 3)) true)
  "list? should return true for proper lists")

(test-assert 
  (= (list? (cons 1 (cons 2 ()))) true)
  "list? should return true for manually constructed lists")

; Test 2: Non-lists should return false
(test-assert 
  (= (list? 42) false)
  "list? should return false for numbers")

(test-assert 
  (= (list? "hello") false)
  "list? should return false for strings")

(test-assert 
  (= (list? (q symbol)) false)
  "list? should return false for symbols")

; Test 3: list? with cons cells vs improper lists
(test-assert 
  (= (list? (cons 1 2)) true)
  "list? should return true for cons pairs (implementation treats all cons-cells as lists)")

; Test 4: list? as Church Boolean
(test-assert 
  (= ((list? (list 1 2)) "is-list" "not-list") "is-list")
  "list? should work as Church Boolean - list case")

(test-assert 
  (= ((list? 42) "is-list" "not-list") "not-list")
  "list? should work as Church Boolean - non-list case")

; Test 5: list? with various list types
(test-assert 
  (= (list? (iota 5)) true)
  "list? should work with iota-generated lists")

(test-assert 
  (= (list? (map (lambda (x) x) (list 1 2))) true)
  "list? should work with map results")

(test-assert 
  (= (list? (filter even? (list 1 2 3 4))) true)
  "list? should work with filter results")

(test-assert 
  (= (list? (reverse (list 1 2 3))) true)
  "list? should work with reverse results")

; Test 6: list? with nested structures
(test-assert 
  (= (list? (list (list 1 2) (list 3 4))) true)
  "list? should work with nested lists")

; Test 7: list? with single element lists
(test-assert 
  (= (list? (list 42)) true)
  "list? should work with single-element lists")

; Test 8: list? with operatives and environments
(test-assert 
  (= (list? (lambda (x) x)) false)
  "list? should return false for lambda functions")

(test-assert 
  (= (list? (get-current-environment)) false)
  "list? should return false for environments")

; Test 9: list? with mutable bindings
(define-mutable mutable-list (list 1 2 3))
(test-assert 
  (= (list? mutable-list) true)
  "list? should work with mutable list bindings")

(define-mutable mutable-number 789)
(test-assert 
  (= (list? mutable-number) false)
  "list? should work with mutable non-list bindings")

; Test 10: list? error conditions
(test-error (list?) "list? should require exactly 1 argument")
(test-error (list? (list 1 2) extra) "list? should require exactly 1 argument")

; Test 11: list? with apply
(test-assert 
  (= ((apply list? (list (list 1 2 3))) "yes" "no") "yes")
  "list? should work with apply")

; Test 12: list? with library-generated lists
(test-assert 
  (= (list? (append (list 1 2) (list 3 4))) true)
  "list? should work with append results")

(test-assert 
  (= (list? (prepend 1 2 (list 3 4))) true)
  "list? should work with prepend results")

; Test 13: list? used in higher-order functions
(define list-items (filter list? (list 42 (list 1 2) "string" (list 3 4))))
(test-assert 
  (= (length list-items) 2)
  "list? should work with filter to find lists")

(test-assert 
  (= (first (first list-items)) 1)
  "list? filter should find correct lists - first list")

;------------------------------------------------------------------------------
; operative? tests

; Test 1: Basic operative recognition
(test-assert 
  (= (operative? +) true)
  "operative? should return true for built-in operatives")

(test-assert 
  (= (operative? cons) true)
  "operative? should return true for built-in list operatives")

(define test-vau-op (vau (x) env x))
(test-assert 
  (= (operative? test-vau-op) true)
  "operative? should return true for user-defined vau operatives")

; Test 2: Lambda functions are operatives
(define test-lambda-op (lambda (x) x))
(test-assert 
  (= (operative? test-lambda-op) true)
  "operative? should return true for lambda functions")

(define test-lambda*-op (lambda* (x) x))
(test-assert 
  (= (operative? test-lambda*-op) true)
  "operative? should return true for lambda* functions")

; Test 3: Church Booleans are operatives
(test-assert 
  (= (operative? true) true)
  "operative? should return true for Church Boolean true")

(test-assert 
  (= (operative? false) true)
  "operative? should return true for Church Boolean false")

; Test 4: Wrapped operatives are still operatives
(define wrapped-plus (wrap +))
(test-assert 
  (= (operative? wrapped-plus) true)
  "operative? should return true for wrapped operatives")

; Test 5: Non-operatives should return false
(test-assert 
  (= (operative? 42) false)
  "operative? should return false for numbers")

(test-assert 
  (= (operative? "hello") false)
  "operative? should return false for strings")

(test-assert 
  (= (operative? (q symbol)) false)
  "operative? should return false for symbols")

(test-assert 
  (= (operative? (list 1 2 3)) false)
  "operative? should return false for lists")

(test-assert 
  (= (operative? ()) false)
  "operative? should return false for nil")

; Test 6: operative? as Church Boolean
(test-assert 
  (= ((operative? +) "is-operative" "not-operative") "is-operative")
  "operative? should work as Church Boolean - operative case")

(test-assert 
  (= ((operative? 42) "is-operative" "not-operative") "not-operative")
  "operative? should work as Church Boolean - non-operative case")

; Test 7: operative? with environments
(test-assert 
  (= (operative? (get-current-environment)) false)
  "operative? should return false for environments")

; Test 8: operative? with library-defined operatives
(test-assert 
  (= (operative? if) true)
  "operative? should return true for library-defined operatives like if")

(test-assert 
  (= (operative? cond) true)
  "operative? should return true for library-defined operatives like cond")

; Test 9: operative? with mutable bindings
(define-mutable mutable-op (lambda (x) x))
(test-assert 
  (= (operative? mutable-op) true)
  "operative? should work with mutable operative bindings")

(define-mutable mutable-value 123)
(test-assert 
  (= (operative? mutable-value) false)
  "operative? should work with mutable non-operative bindings")

; Test 10: operative? error conditions
(test-error (operative?) "operative? should require exactly 1 argument")
(test-error (operative? + extra) "operative? should require exactly 1 argument")

; Test 11: operative? with apply
(test-assert 
  (= ((apply operative? (list +)) "yes" "no") "yes")
  "operative? should work with apply")

; Test 12: operative? with higher-order usage
(define operatives-list (filter operative? (list 42 + "string" (lambda (x) x))))
(test-assert 
  (= (length operatives-list) 2)
  "operative? should work with filter to find operatives")

; Test 13: operative? with various operative types
(define vau*-test (vau* (x) env x))
(test-assert 
  (= (operative? vau*-test) true)
  "operative? should return true for vau* operatives")

; Test 14: operative? with Church Boolean operatives used as functions
(test-assert 
  (= (operative? (= 1 1)) true)
  "operative? should return true for Church Boolean results from comparisons")

;------------------------------------------------------------------------------
; environment? tests

; Test 1: Basic environment recognition
(test-assert 
  (= (environment? (get-current-environment)) true)
  "environment? should return true for current environment")

; Test 2: Captured environments are environments
(define captured-env ((vau () env env)))
(test-assert 
  (= (environment? captured-env) true)
  "environment? should return true for captured environments")

; Test 3: Non-environments should return false
(test-assert 
  (= (environment? 42) false)
  "environment? should return false for numbers")

(test-assert 
  (= (environment? "hello") false)
  "environment? should return false for strings")

(test-assert 
  (= (environment? (q symbol)) false)
  "environment? should return false for symbols")

(test-assert 
  (= (environment? (list 1 2 3)) false)
  "environment? should return false for lists")

(test-assert 
  (= (environment? ()) false)
  "environment? should return false for nil")

; Test 4: environment? with operatives
(test-assert 
  (= (environment? +) false)
  "environment? should return false for operatives")

(test-assert 
  (= (environment? (lambda (x) x)) false)
  "environment? should return false for lambda functions")

; Test 5: environment? as Church Boolean
(test-assert 
  (= ((environment? (get-current-environment)) "is-env" "not-env") "is-env")
  "environment? should work as Church Boolean - environment case")

(test-assert 
  (= ((environment? 42) "is-env" "not-env") "not-env")
  "environment? should work as Church Boolean - non-environment case")

; Test 6: environment? with mutable bindings
(define-mutable mutable-env (get-current-environment))
(test-assert 
  (= (environment? mutable-env) true)
  "environment? should work with mutable environment bindings")

(define-mutable mutable-other "not-env")
(test-assert 
  (= (environment? mutable-other) false)
  "environment? should work with mutable non-environment bindings")

; Test 7: environment? error conditions
(test-error (environment?) "environment? should require exactly 1 argument")
(test-error (environment? (get-current-environment) extra) "environment? should require exactly 1 argument")

; Test 8: environment? with apply
(test-assert 
  (= ((apply environment? (list (get-current-environment))) "yes" "no") "yes")
  "environment? should work with apply")

; Test 9: environment? with nested vau environment capture
(define nested-env-test
  (vau () outer-env
    (vau () inner-env
      (list (environment? outer-env) (environment? inner-env)))))
(define env-test-results ((nested-env-test)))
(test-assert 
  (= ((first env-test-results) "yes" "no") "yes")
  "environment? should work with outer environment capture")

(test-assert 
  (= ((first (rest env-test-results)) "yes" "no") "yes")
  "environment? should work with inner environment capture")

; Test 10: environment? with library usage
(define env-items (filter environment? (list 42 (get-current-environment) "test")))
(test-assert 
  (= (length env-items) 1)
  "environment? should work with filter to find environments")

; Test 11: Multiple environment instances
(define env1 (get-current-environment))
(define env2 ((vau () env env)))
(test-assert 
  (= (environment? env1) true)
  "environment? should work with first environment instance")

(test-assert 
  (= (environment? env2) true)
  "environment? should work with second environment instance")

;------------------------------------------------------------------------------
; Type predicate integration tests

; Test 1: All predicates with the same value
(define test-value 42)
(test-assert 
  (and (number? test-value)
       (not (string? test-value))
       (not (symbol? test-value))
       (not (list? test-value))
       (not (operative? test-value))
       (not (environment? test-value)))
  "type predicates should be mutually exclusive for numbers")

; Test 2: Type predicate composition
(define classify-value
  (lambda (x)
    (cond ((number? x) "number")
          ((string? x) "string")
          ((symbol? x) "symbol")
          ((list? x) "list")
          ((operative? x) "operative")
          ((environment? x) "environment")
          (else "unknown"))))

(test-assert 
  (= (classify-value 42) "number")
  "type classification should work for numbers")

(test-assert 
  (= (classify-value "hello") "string")
  "type classification should work for strings")

(test-assert 
  (= (classify-value (q symbol)) "symbol")
  "type classification should work for symbols")

(test-assert 
  (= (classify-value (list 1 2)) "list")
  "type classification should work for lists")

(test-assert 
  (= (classify-value +) "operative")
  "type classification should work for operatives")

(test-assert 
  (= (classify-value (get-current-environment)) "environment")
  "type classification should work for environments")

; Test 3: Type predicates with map
(define mixed-values (list 1 "two" (q three) (list 4) + (get-current-environment)))
(define type-map (map classify-value mixed-values))
(test-assert 
  (= (first type-map) "number")
  "type classification with map - number")

(test-assert 
  (= (first (rest type-map)) "string")
  "type classification with map - string")

(test-assert 
  (= (first (rest (rest type-map))) "symbol")
  "type classification with map - symbol")

; Test 4: Type predicates consistency with typeof
(define check-consistency
  (lambda (val expected-type)
    (= (typeof val) expected-type)))

(test-assert 
  (and (number? 42) (check-consistency 42 (q number)))
  "number? should be consistent with typeof")

(test-assert 
  (and (string? "test") (check-consistency "test" (q string)))
  "string? should be consistent with typeof")

(test-assert 
  (and (symbol? (q test)) (check-consistency (q test) (q symbol)))
  "symbol? should be consistent with typeof")

(test-assert 
  (and (list? (list 1 2)) (check-consistency (list 1 2) (q cons-cell)))
  "list? should be consistent with typeof for cons-cell")

; Test 5: Type predicates with fold operations
(define count-types
  (lambda (values)
    (foldl (lambda (acc val)
             (cond ((number? val) (list (+ (first acc) 1) (second acc)))
                   ((string? val) (list (first acc) (+ (second acc) 1)))
                   (else acc)))
           (list 0 0)  ; [number-count, string-count]
           values)))

(define type-counts (count-types (list 1 2 "hello" 3 "world")))
(test-assert 
  (= (first type-counts) 3)
  "type predicates should work in fold operations - number count")

(test-assert 
  (= (second type-counts) 2)
  "type predicates should work in fold operations - string count")

;------------------------------------------------------------------------------
; eval-list tests
(lndisplayln "wrap/eval-list/lambda/lambda*/vau* tests")

#skip
; TODO: The definition of `result-list` assumes `env` exists
; Test eval-list function with unevaluated expressions
(define unevaluated-exprs (make-expr (+ 1 2) (* 3 4)))
(define result-list (eval-list unevaluated-exprs env))
(test-assert 
  (= (first result-list) 3)
  "eval-list should evaluate first element")

(test-assert 
  (= (first (rest result-list)) 12)
  "eval-list should evaluate second element")
#end

(test-assert 
  (= (first (list 42)) 42)
  "single element list should work")

; Test 1: Basic eval-list with simple expressions
(define simple-exprs (list (q (+ 1 2)) (q (* 3 4))))
(define simple-results (eval-list simple-exprs (get-current-environment)))
(test-assert 
  (= (first simple-results) 3)
  "eval-list should evaluate first expression correctly")

(test-assert 
  (= (first (rest simple-results)) 12)
  "eval-list should evaluate second expression correctly")

; Test 2: eval-list with single expression
(define single-expr (list (q (+ 10 20))))
(define single-result (eval-list single-expr (get-current-environment)))
(test-assert 
  (= (first single-result) 30)
  "eval-list should work with single expression")

; Test 3: eval-list with empty list
(define empty-results (eval-list () (get-current-environment)))
(test-assert 
  (nil? empty-results)
  "eval-list with empty list should return nil")

; Test 4: eval-list with variable references
(define test-var-for-eval 42)
(define var-exprs (list (q test-var-for-eval) (q (+ test-var-for-eval 8))))
(define var-results (eval-list var-exprs (get-current-environment)))
(test-assert 
  (= (first var-results) 42)
  "eval-list should evaluate variable references")

(test-assert 
  (= (first (rest var-results)) 50)
  "eval-list should evaluate expressions with variables")

; Test 5: eval-list with nested expressions
(define nested-exprs (list (q (+ 1 (+ 2 3))) (q (* (- 10 5) 2))))
(define nested-results (eval-list nested-exprs (get-current-environment)))
(test-assert 
  (= (first nested-results) 6)
  "eval-list should handle nested expressions - first")

(test-assert 
  (= (first (rest nested-results)) 10)
  "eval-list should handle nested expressions - second")

; Test 6: eval-list with side effects - expressions should be evaluated once each
(define-mutable eval-list-counter 0)
(define increment-expr (q (do (set! eval-list-counter (+ eval-list-counter 1)) eval-list-counter)))
(define side-effect-exprs (list increment-expr (q (+ eval-list-counter 100))))

; This test may reveal the invoke issue if eval-list-helper evaluates expressions multiple times
(define side-effect-results (eval-list side-effect-exprs (get-current-environment)))
(test-assert 
  (= (first side-effect-results) 1)
  "eval-list should evaluate side-effect expressions exactly once - first result")

(test-assert 
  (= (first (rest side-effect-results)) 101)
  "eval-list should evaluate expressions in order with proper side effects")

; Test 7: eval-list with quoted expressions  
(define quote-exprs (list (q (q hello)) (q (q world))))
(define quote-results (eval-list quote-exprs (get-current-environment)))
(test-assert 
  (= (first quote-results) (q hello))
  "eval-list should handle quoted expressions")

(test-assert 
  (= (first (rest quote-results)) (q world))
  "eval-list should handle multiple quoted expressions")

; Test 8: eval-list with mixed expression types
(define mixed-exprs (list (q 42) (q (+ 2 3)) (q test-var-for-eval)))
(define mixed-results (eval-list mixed-exprs (get-current-environment)))
(test-assert 
  (= (first mixed-results) 42)
  "eval-list should handle mixed types - literal")

(test-assert 
  (= (first (rest mixed-results)) 5)
  "eval-list should handle mixed types - expression")

(test-assert 
  (= (first (rest (rest mixed-results))) 42)
  "eval-list should handle mixed types - variable")

; Test 9: eval-list should work with library functions
(define lib-exprs (list (q (first (list 1 2 3))) (q (rest (list 4 5 6)))))
(define lib-results (eval-list lib-exprs (get-current-environment)))
(test-assert 
  (= (first lib-results) 1)
  "eval-list should work with library functions - first")

(test-assert 
  (= (first (first (rest lib-results))) 5)
  "eval-list should work with library functions - rest result")

#skip
; Skipping this test because it uses displayln.
; Test 10: Error case that demonstrates the invoke issue
; This might fail due to the incorrect invoke usage in eval-list-helper
(define error-prone-exprs (list (q (+ 1 2)) (q (display "TEST")) (q (* 3 4))))

; This test might reveal issues if the invoke problem causes expressions to be 
; evaluated incorrectly or multiple times
(define complex-results (eval-list error-prone-exprs (get-current-environment)))
(test-assert 
  (= (first complex-results) 3)
  "eval-list should handle complex expression list - first")

(test-assert 
  (= (first (rest (rest complex-results))) 12)
  "eval-list should handle complex expression list - third")
#end

;------------------------------------------------------------------------------
; Wrap tests

; Test wrap functionality
(define simple-op (vau (x y) env (cons x (cons y ()))))
(define wrapped-simple (wrap simple-op))

; Test that wrap evaluates arguments
(define a 1)
(define b 2)
(test-assert 
  (nil? (rest (rest (wrapped-simple a b))))
  "wrap should create proper list structure")

; Test wrap with built-in operatives
(define wrapped-plus (wrap +))
(define x 5)
(define y 10)
(test-assert 
  (= (wrapped-plus x y) 15)
  "wrapped + should evaluate arguments and add them")

(test-assert 
  (= (wrapped-plus (+ 1 2) 4) 7)
  "wrapped + should evaluate complex arguments")

; Test wrap with environment-dependent operatives
(define env-dependent-op 
  (vau (x) env 
    (eval x env)))  ; This needs the environment parameter to work

(define wrapped-env-op (wrap env-dependent-op))
(define test-var 42)

(test-assert 
  (= (wrapped-env-op (q test-var)) 42)
  "wrap should preserve environment context for user-defined operatives")

;------------------------------------------------------------------------------
; Lambda tests

; Test 1: Basic lambda creation and invocation
(define add-two (lambda (x) (+ x 2)))
(test-assert 
  (= (add-two 5) 7)
  "basic lambda should work with single parameter")

(test-assert 
  (= (add-two 10) 12)
  "lambda should work with different arguments")

; Test 2: Lambda with multiple parameters
(define multiply (lambda (x y) (* x y)))
(test-assert 
  (= (multiply 3 4) 12)
  "lambda should work with multiple parameters")

(test-assert 
  (= (multiply 7 8) 56)
  "lambda with multiple parameters should work consistently")

; Test 3: Lambda with no parameters
(define get-constant (lambda () 42))
(test-assert 
  (= (get-constant) 42)
  "lambda with no parameters should work")

; Test 4: Lambda that uses closure variables
(define closure-var 100)
(define add-closure-var (lambda (y) (+ closure-var y)))
(test-assert 
  (= (add-closure-var 23) 123)
  "lambda should capture closure variables")

; ! This test fails!
; Test 5: Nested lambda expressions
(define make-adder (lambda (n) (lambda (x) (+ x n))))
(define add-five (make-adder 5))
(test-assert 
  (= (add-five 10) 15)
  "nested lambdas should work")

(test-assert 
  (= (add-five 7) 12)
  "nested lambdas should work consistently")

; Test 6: Lambda arguments are evaluated (unlike vau)
(define eval-and-double (lambda (x) (* x 2)))
(test-assert 
  (= (eval-and-double (+ 3 4)) 14)
  "lambda should evaluate its arguments")

; Test 7: Compare with vau - lambda evaluates args, vau doesn't
(define vau-version (vau (x) env x))
(define lambda-version (lambda (x) x))

; Create test expressions
(define test-expr (make-expr (+ 1 2)))
(define vau-result (vau-version (+ 1 2)))
(define lambda-result (lambda-version (+ 1 2)))

(test-assert 
  (= lambda-result 3)
  "lambda should evaluate arguments before passing to body")

; Test 8: Lambda with complex body expressions
(define complex-calc (lambda (a b) (+ (* a a) (* b b))))
(test-assert 
  (= (complex-calc 3 4) 25)
  "lambda should handle complex expressions in body")

; Test 9: Lambda used with higher-order functions
(define apply-twice (lambda (f x) (f (f x))))
(define increment (lambda (n) (+ n 1)))
(test-assert 
  (= (apply-twice increment 5) 7)
  "lambda should work as higher-order function")

; Test 10: Lambda with conditional logic
(define abs-positive (lambda (x) (if (= x 0) 0 x)))
(test-assert 
  (= (abs-positive 5) 5)
  "lambda should work with conditionals")

(test-assert 
  (= (abs-positive 0) 0)
  "lambda conditional should handle zero case")

; Test 11: Lambda that returns another lambda
(define curry-add (lambda (x) (lambda (y) (+ x y))))
(define add-ten (curry-add 10))
(test-assert 
  (= (add-ten 5) 15)
  "lambda should support currying")

; Test 12: Test lambda via square function
(define square (lambda (x) (* x x)))

(test-assert 
  (= (square 4) 16)
  "library square function should work")

(test-assert 
  (= (square 7) 49)
  "library square function should work consistently")

; Test 13: Immediate lambda invocation
(test-assert 
  (= ((lambda (x y) (+ x y)) 8 9) 17)
  "immediate lambda invocation should work")

(test-assert 
  (= ((lambda () (* 6 7))) 42)
  "immediate parameterless lambda invocation should work")

; Test 14: Lambda parameter shadowing
(define outer-var 999)
(define shadow-test (lambda (outer-var) (* outer-var 2)))
(test-assert 
  (= (shadow-test 5) 10)
  "lambda parameters should shadow outer variables")

(test-assert 
  (= outer-var 999)
  "lambda parameter shadowing should not affect outer scope")

; Test 15: Lambda composition
(define double (lambda (x) (* x 2)))
(define add-one (lambda (x) (+ x 1)))
(define double-then-add-one (lambda (x) (add-one (double x))))
(test-assert 
  (= (double-then-add-one 5) 11)
  "lambda composition should work")

;------------------------------------------------------------------------------
; lambda* tests (multi-expression lambda)

; Test 1: Basic lambda* with single expression (should work like regular lambda)
(define simple-lambda* (lambda* (x) (+ x 5)))
(test-assert 
  (= (simple-lambda* 10) 15)
  "lambda* should work with single expression")

; Test 2: lambda* with multiple expressions
(define-mutable side-effect-counter 0)
(define multi-expr-lambda* 
  (lambda* (x) 
    (set! side-effect-counter (+ side-effect-counter 1))
    (set! side-effect-counter (+ side-effect-counter x))
    (* x 2)))
(test-assert 
  (= (multi-expr-lambda* 3) 6)
  "lambda* should return value of last expression")

(test-assert 
  (= side-effect-counter 4)  ; 1 + 3 = 4
  "lambda* should execute all expressions for side effects")

; Test 3: lambda* with no parameters and multiple expressions
(define-mutable global-var 100)
(define no-params-lambda* 
  (lambda* ()
    (set! global-var 200)
    (set! global-var (+ global-var 50))
    global-var))
(test-assert 
  (= (no-params-lambda* ) 250)
  "lambda* with no parameters should work with multiple expressions")

; Test 4: lambda* with multiple parameters and expressions
(define complex-lambda* 
  (lambda* (a b c)
    (define-mutable temp (+ a b))
    (set! temp (+ temp c))
    (* temp 2)))
(test-assert 
  (= (complex-lambda* 1 2 3) 12)  ; ((1+2)+3)*2 = 12
  "lambda* should work with multiple parameters and expressions")

; Test 5: Nested lambda* expressions
(define make-counter 
  (lambda* (start)
    (define-mutable count start)
    (lambda* ()
      (set! count (+ count 1))
      count)))
(define counter (make-counter 10))
(test-assert 
  (= (counter) 11)
  "nested lambda* should work - first call")

(test-assert 
  (= (counter) 12)
  "nested lambda* should work - second call")

; Test 6: lambda* with conditionals and multiple expressions
(define conditional-lambda* 
  (lambda* (x)
    (define-mutable result 0)
    (if (= x 0)
        (set! result 100)
        (set! result (* x 10)))
    (set! result (+ result 5))
    result))
(test-assert 
  (= (conditional-lambda* 0) 105)  ; 100 + 5
  "lambda* with conditionals should work - zero case")

(test-assert 
  (= (conditional-lambda* 3) 35)   ; (3*10) + 5
  "lambda* with conditionals should work - non-zero case")

; Test 7: lambda* used as higher-order function
(define apply-with-logging 
  (lambda* (func x)
    (define-mutable log-var 0)
    (set! log-var x)
    (define result (func x))
    (set! log-var (+ log-var result))
    result))
(define double (lambda (n) (* n 2)))
(test-assert 
  (= (apply-with-logging double 7) 14)
  "lambda* should work as higher-order function")

; Test 8: lambda* with recursive helper
(define factorial-lambda* 
  (lambda* (n)
    (define factorial-helper 
      (lambda (x acc)
        (if (= x 0)
            acc
            (factorial-helper (- x 1) (* acc x)))))
    (factorial-helper n 1)))
(test-assert 
  (= (factorial-lambda* 5) 120)
  "lambda* should work with recursive helpers")

; Test 9: Immediate lambda* invocation
(test-assert 
  (= ((lambda* (x y)
        (define temp (+ x y))
        (* temp 3)) 4 6) 30)  ; (4+6)*3 = 30
  "immediate lambda* invocation should work")

; Test 10: lambda* parameter shadowing with multiple expressions
(define outer-shadow-var 999)
(define shadow-lambda* 
  (lambda* (outer-shadow-var)
    (define-mutable temp outer-shadow-var)
    (set! temp (+ temp 1))
    temp))
(test-assert 
  (= (shadow-lambda* 5) 6)
  "lambda* parameter shadowing should work")

(test-assert 
  (= outer-shadow-var 999)
  "lambda* parameter shadowing should not affect outer scope")

; Test 11: lambda* with define-mutable in body
(define closure-lambda* 
  (lambda* (initial)
    (define-mutable state initial)
    (lambda* (delta)
      (set! state (+ state delta))
      state)))
(define stateful-func (closure-lambda* 100))
(test-assert 
  (= (stateful-func 10) 110)
  "lambda* with define-mutable should create stateful closures")

(test-assert 
  (= (stateful-func 5) 115)
  "lambda* stateful closure should maintain state")

; Test 12: Compare lambda vs lambda* behavior
(define regular-lambda-test (lambda (x) x))
(define lambda*-test (lambda* (x) x))
(test-assert 
  (= (regular-lambda-test 42) (lambda*-test 42))
  "lambda* should behave like lambda for single expressions")

; Test 13: lambda* with for-each (using library function)
(define-mutable sum-accumulator 0)
(define sum-list-lambda* 
  (lambda* (lyst)
    (set! sum-accumulator 0)
    (for-each (lambda (x) (set! sum-accumulator (+ sum-accumulator x))) lyst)
    sum-accumulator))
(test-assert 
  (= (sum-list-lambda* (list 1 2 3 4)) 10)
  "lambda* should work with library functions like for-each")

; Test 14: Empty body lambda* (should be equivalent to returning ())
(define empty-body-lambda* (lambda* (x)))
(test-assert 
  (nil? (empty-body-lambda* 42))
  "lambda* with empty body should return nil")

; Test 15: lambda* with complex expression sequencing
(define sequence-test-lambda* 
  (lambda* (x)
    (+ x 1)      ; This result is discarded
    (+ x 2)      ; This result is discarded  
    (+ x 3)))    ; This result is returned
(test-assert 
  (= (sequence-test-lambda* 5) 8)  ; 5 + 3 = 8
  "lambda* should return only the last expression's value")

;------------------------------------------------------------------------------
; vau* tests

; Test 1: Basic vau* with multiple expressions
(define-mutable vau-side-effect 0)
(define basic-vau* 
  (vau* (x) env
    (set! vau-side-effect (+ vau-side-effect 1))
    (set! vau-side-effect (* vau-side-effect 2))
    x))  ; Return the unevaluated argument

; Test the side effects occurred
(basic-vau* dummy-expr)
(test-assert 
  (= vau-side-effect 2)
  "vau* should execute multiple expressions for side effects")

; Test 2: vau* with environment parameter usage  
(define env-using-vau*
  (vau* (expr) dyn-env
    (define temp-var 42)
    (define result (eval expr dyn-env))
    (* result 2)))
(test-assert 
  (= (env-using-vau* (+ 3 4)) 14)
  "vau* should be able to use environment parameter")

; Test 3: vau* with no expressions (empty body)
(define empty-vau* (vau* (x) env))
(test-assert 
  (nil? (empty-vau* hello))
  "vau* with empty body should return nil")

; Test 4: vau* with multiple parameters - test that it accepts them
(define multi-param-vau*
  (vau* (a b c) env
    (define first-arg a)
    (define second-arg b) 
    (define third-arg c)
    first-arg))  ; Just return first arg to test it works
(test-assert 
  (= (multi-param-vau* 42 y z) 42)
  "vau* should handle multiple parameters correctly")

; Test 5: vau* that evaluates some arguments selectively  
(define selective-eval-vau*
  (vau* (first-expr second-expr) dyn-env
    (define first-val (eval first-expr dyn-env))
    first-val))  ; Just return evaluated first arg
(test-assert 
  (= (selective-eval-vau* (+ 2 3) (+ 4 5)) 5)
  "vau* should allow selective evaluation of arguments")

; Test 6: Compare vau* vs regular vau behavior
(define regular-vau-multi
  (vau (x) env
    (do (define temp x)
        (* 2 2)
        temp)))
(define equivalent-vau*
  (vau* (x) env
    (define temp x)
    (* 2 2)
    temp))

; Test that both return the same unevaluated expression by using them with numbers
(test-assert 
  (= (regular-vau-multi 123) (equivalent-vau* 123))
  "vau* should behave equivalently to vau with do block")

; Test 7: vau* with conditional logic
(define conditional-vau*
  (vau* (test-expr then-expr else-expr) dyn-env
    (define test-result (eval test-expr dyn-env))
    (if test-result
        then-expr
        else-expr)))
(test-assert 
  (= (conditional-vau* (= 1 1) 42 99) 42)
  "vau* should work with conditional logic - true case")

(test-assert 
  (= (conditional-vau* (= 1 2) 42 99) 99)  
  "vau* should work with conditional logic - false case")

; Test 8: vau* with single expression (should work like regular vau)
(define single-expr-vau* (vau* (x) env x))
(test-assert 
  (= (single-expr-vau* 777) 777)
  "vau* with single expression should work like regular vau")

; Test 9: vau* with complex expression sequencing  
(define-mutable sequence-counter 0)
(define sequence-test-vau*
  (vau* (x) env
    (set! sequence-counter (+ sequence-counter 1))  ; Side effect
    (set! sequence-counter (+ sequence-counter 10)) ; Side effect  
    x))  ; Return unevaluated x

(define seq-result (sequence-test-vau* final-expr))
(test-assert 
  (and (= sequence-counter 11) (= seq-result (q final-expr)))
  "vau* should execute all expressions and return last value")

; vau used in higher-order context
(define test-vau (vau (x) env (eval x env)))
(define higher-order-test (lambda (op arg) (op arg)))

(test-assert 
  (= (higher-order-test test-vau 123) 123)
  "vau should work when passed to and called from other functions")

; Test 10: vau* used in higher-order context
(define test-vau* (vau* (x) env (eval x env)))
(define higher-order-test (lambda (op arg) (op arg)))

(test-assert 
  (= (higher-order-test test-vau* 123) 123)
  "vau* should work when passed to and called from other functions")

; Test 11: vau* with recursive pattern (simplified)
(define recursive-vau*
  (vau* (x) dyn-env
    (define helper-result x)  ; Simplified - just pass through
    helper-result))
(test-assert 
  (= (recursive-vau* test-expr) (q test-expr))
  "vau* should work with internal definitions")

; Test 12: Test that vau* creates proper operative (doesn't evaluate args)
(define-mutable arg-eval-test 0)
(define arg-test-vau*
  (vau* (expr) env
    (set! arg-eval-test 999)
    expr))

; The argument (+ arg-eval-test 1) should NOT be evaluated
(define unevald-result (arg-test-vau* (+ arg-eval-test 1)))
(test-assert 
  (= arg-eval-test 999)  ; Should be 999 from vau* body, not from argument
  "vau* should not evaluate its arguments")

;------------------------------------------------------------------------------
; prepend tests (list* equivalent)
(lndisplayln "list functions tests")

; Test 1: Basic prepend with single final argument
(test-assert 
  (= (first (prepend 1 (list 2 3))) 1)
  "prepend should add element to front of list")

(test-assert 
  (= (first (rest (prepend 1 (list 2 3)))) 2)
  "prepend should preserve existing list elements")

; Test 2: Multiple elements prepended
(define result-list (prepend 1 2 3 (list 4 5)))
(test-assert 
  (= (first result-list) 1)
  "prepend should handle multiple elements - first")

(test-assert 
  (= (first (rest result-list)) 2)
  "prepend should handle multiple elements - second")

(test-assert 
  (= (first (rest (rest result-list))) 3)
  "prepend should handle multiple elements - third")

(test-assert 
  (= (first (rest (rest (rest result-list)))) 4)
  "prepend should preserve final list - first element")

; Test 3: Prepend to empty list
(test-assert 
  (= (first (prepend 42 ())) 42)
  "prepend should work with empty final list")

(test-assert 
  (nil? (rest (prepend 42 ())))
  "prepend with empty list should create single-element list")

; Skipping this test because `=` doesn't support lists.
; Test 4: Single argument (should return the argument itself)
(test-assert 
  (= (prepend 123) 123)
  "prepend with single argument should return that argument")

(test-assert 
  (= (prepend (list 1 2 3)) (list 1 2 3))
  "prepend with single list argument should return the list")

; Test 5: No arguments (should return empty)
(test-assert 
  (nil? (prepend))
  "prepend with no arguments should return nil")

; Test 6: Argument evaluation - expressions should be evaluated once
(define-mutable prepend-eval-counter 0)
(define increment-and-return 
  (lambda* (n) 
    (set! prepend-eval-counter (+ prepend-eval-counter 1))
    n))

(define prepend-result (prepend (increment-and-return 10) 
                               (increment-and-return 20) 
                               (list 30)))
(test-assert 
  (= prepend-eval-counter 2)
  "prepend should evaluate each argument exactly once")

(test-assert 
  (= (first prepend-result) 10)
  "prepend should use evaluated argument values - first")

(test-assert 
  (= (first (rest prepend-result)) 20)
  "prepend should use evaluated argument values - second")

; Test 7: Complex expressions as arguments
(test-assert 
  (= (first (prepend (+ 1 2) (list 4 5))) 3)
  "prepend should evaluate complex expressions")

; Test 8: Nested prepend calls
(test-assert 
  (= (first (prepend 1 (prepend 2 (list 3)))) 1)
  "prepend should work when nested")

; Test 9: prepend with different data types
(define mixed-result (prepend "hello" 42 (list "world" 99)))
(test-assert 
  (= (first mixed-result) "hello")
  "prepend should work with mixed data types - string")

(test-assert 
  (= (first (rest mixed-result)) 42)
  "prepend should work with mixed data types - number")

(test-assert 
  (= (first (rest (rest mixed-result))) "world")
  "prepend should work with mixed data types - final list string")

; Test 10: prepend compared to manual cons chains
(define manual-chain (cons 1 (cons 2 (cons 3 (list 4 5)))))
(define prepend-chain (prepend 1 2 3 (list 4 5)))
(test-assert 
  (= (first manual-chain) (first prepend-chain))
  "prepend should be equivalent to manual cons chain - first")

(test-assert 
  (= (first (rest manual-chain)) (first (rest prepend-chain)))
  "prepend should be equivalent to manual cons chain - second")

(test-assert 
  (= (first (rest (rest manual-chain))) (first (rest (rest prepend-chain))))
  "prepend should be equivalent to manual cons chain - third")

;------------------------------------------------------------------------------
; for-each tests

; Test 1: Basic for-each
(define-mutable for-each-sum 0)
(define add-to-sum (lambda (x) (set! for-each-sum (+ for-each-sum x))))
(for-each add-to-sum (list 1 2 3))
(test-assert 
  (= for-each-sum 6)
  "for-each should apply function to each list element")

;------------------------------------------------------------------------------
; foldr tests

; Test 1: Basic foldr with addition
(test-assert 
  (= (foldr + (list 1 2 3) 0) 6)
  "foldr should sum list elements")

; Test 2: Empty list should return init value
(test-assert 
  (= (foldr + () 42) 42)
  "foldr with empty list should return init value")

; Test 3: Single element list
(test-assert 
  (= (foldr + (list 5) 0) 5)
  "foldr with single element should work")

; Test 4: foldr with multiplication
(test-assert 
  (= (foldr * (list 2 3 4) 1) 24)
  "foldr should multiply list elements")

; Test 5: foldr with cons (should reconstruct the list)
(define reconstructed (foldr cons (list 1 2 3) ()))
(test-assert 
  (= (first reconstructed) 1)
  "foldr with cons should reconstruct list - first element")

(test-assert 
  (= (first (rest reconstructed)) 2)
  "foldr with cons should reconstruct list - second element")

(test-assert 
  (= (first (rest (rest reconstructed))) 3)
  "foldr with cons should reconstruct list - third element")

; Test 6: foldr with lambda function
(define subtract-from-acc (lambda (x acc) (- acc x)))
(test-assert 
  (= (foldr subtract-from-acc (list 1 2 3) 10) 4)
  "foldr should work with lambda functions")

; Test 7: foldr order matters (right associative)
; (foldr - (list 1 2 3) 0) = (- 1 (- 2 (- 3 0))) = (- 1 (- 2 3)) = (- 1 -1) = 2
(test-assert 
  (= (foldr - (list 1 2 3) 0) 2)
  "foldr should be right-associative")

; Test 8: foldr with wrapped operatives
(define wrapped-mult (wrap *))
(test-assert 
  (= (foldr wrapped-mult (list 2 3 4) 1) 24)
  "foldr should work with wrapped operatives")

; Test 9: foldr with different init values
(test-assert 
  (= (foldr + (list 1 2 3) 10) 16)
  "foldr should add init value to sum")

; Test 10: foldr with nested function calls
(define double-and-add (lambda (x acc) (+ (* x 2) acc)))
(test-assert 
  (= (foldr double-and-add (list 1 2 3) 0) 12)
  "foldr should work with complex functions")

;------------------------------------------------------------------------------
; foldl tests

; Test 1: Basic foldl with addition
(test-assert 
  (= (foldl + 0 (list 1 2 3)) 6)
  "foldl should sum list elements")

; Test 2: Empty list should return init value
(test-assert 
  (= (foldl + 42 ()) 42)
  "foldl with empty list should return init value")

; Test 3: Single element list
(test-assert 
  (= (foldl + 0 (list 5)) 5)
  "foldl with single element should work")

; Test 4: foldl with multiplication
(test-assert 
  (= (foldl * 1 (list 2 3 4)) 24)
  "foldl should multiply list elements")

; Test 5: foldl with lambda function
(define accumulate-subtract (lambda (acc x) (- acc x)))
(test-assert 
  (= (foldl accumulate-subtract 10 (list 1 2 3)) 4)
  "foldl should work with lambda functions")

; Test 6: foldl order matters (left associative)
; (foldl - 0 (list 1 2 3)) = (- (- (- 0 1) 2) 3) = (- (- -1 2) 3) = (- -3 3) = -6
(test-assert 
  (= (foldl - 0 (list 1 2 3)) -6)
  "foldl should be left-associative")

; Test 7: Compare foldl vs foldr associativity
; foldl: (- (- (- 0 1) 2) 3) = -6
; foldr: (- 1 (- 2 (- 3 0))) = (- 1 (- 2 3)) = (- 1 -1) = 2
(test-assert 
  (not (= (foldl - 0 (list 1 2 3)) (foldr - (list 1 2 3) 0)))
  "foldl and foldr should give different results for non-associative operations")

; Test 8: foldl with wrapped operatives
(define wrapped-mult (wrap *))
(test-assert 
  (= (foldl wrapped-mult 1 (list 2 3 4)) 24)
  "foldl should work with wrapped operatives")

; Test 9: foldl with different init values
(test-assert 
  (= (foldl + 10 (list 1 2 3)) 16)
  "foldl should include init value in accumulation")

; Test 10: foldl with complex functions
(define double-and-add (lambda (acc x) (+ acc (* x 2))))
(test-assert 
  (= (foldl double-and-add 0 (list 1 2 3)) 12)
  "foldl should work with complex functions")

; Test 11: foldl building a reversed list (classic use case)
(define reverse-via-foldl (lambda (lyst) (foldl (lambda (acc x) (cons x acc)) () lyst)))
(define reversed (reverse-via-foldl (list 1 2 3)))
(test-assert 
  (= (first reversed) 3)
  "foldl should build reversed list - first element")

(test-assert 
  (= (first (rest reversed)) 2)
  "foldl should build reversed list - second element")

(test-assert 
  (= (first (rest (rest reversed))) 1)
  "foldl should build reversed list - third element")

; Test 12: foldl with string concatenation (if we had string concat)
; Using display capture would be complex, so we'll test with numbers instead
(define number-concat (lambda (acc x) (+ (* acc 10) x)))
(test-assert 
  (= (foldl number-concat 0 (list 1 2 3)) 123)
  "foldl should work for accumulative concatenation-like operations")

; Test 13: foldl with side effects
(define-mutable foldl-side-effect 0)
(define increment-and-add (lambda* (acc x) 
  (set! foldl-side-effect (+ foldl-side-effect 1))
  (+ acc x)))
(test-assert 
  (= (foldl increment-and-add 0 (list 10 20 30)) 60)
  "foldl should work with side effects - result")

(test-assert 
  (= foldl-side-effect 3)
  "foldl should work with side effects - side effect count")

; Test 14: foldl parameter order consistency check
; foldl takes (func init list) while foldr takes (func list init)
; Let's verify the parameter order is correct
(define test-func (lambda (acc elem) (cons elem acc)))
(define foldl-result (foldl test-func () (list 1 2 3)))
(test-assert 
  (= (first foldl-result) 3)
  "foldl parameter order should be (func init list)")

; Test 15: foldl with nested function calls
(define complex-accumulator 
  (lambda (acc x) 
    (+ acc (if (= (/ x 2) 1) (* x 2) x))))
(test-assert 
  (= (foldl complex-accumulator 0 (list 1 2 3))
     (complex-accumulator (complex-accumulator (complex-accumulator 0 1) 2) 3))
  "foldl should work with nested conditionals in accumulator")
(test-assert
  ; The results should be 11 with integer arithmetic, but it is 8 with rational.
  (= (foldl complex-accumulator 0 (list 1 2 3)) 8)
  "foldl should work with nested conditionals in accumulator")

;------------------------------------------------------------------------------
; map tests

; Test 1: Basic map with simple function
(define double (lambda (x) (* x 2)))
(define doubled-list (map double (list 1 2 3)))
(test-assert 
  (= (first doubled-list) 2)
  "map should apply function to first element")

(test-assert 
  (= (first (rest doubled-list)) 4)
  "map should apply function to second element")

(test-assert 
  (= (first (rest (rest doubled-list))) 6)
  "map should apply function to third element")

; Test 2: map with empty list should return empty list
(test-assert 
  (nil? (map double ()))
  "map with empty list should return nil")

; Test 3: map with single element list
(define single-result (map double (list 5)))
(test-assert 
  (= (first single-result) 10)
  "map should work with single element list")

(test-assert 
  (nil? (rest single-result))
  "map with single element should create single-element result")

; Test 4: map with increment function
(define increment (lambda (x) (+ x 1)))
(define incremented (map increment (list 10 20 30)))
(test-assert 
  (= (first incremented) 11)
  "map should work with increment function - first")

(test-assert 
  (= (first (rest incremented)) 21)
  "map should work with increment function - second")

(test-assert 
  (= (first (rest (rest incremented))) 31)
  "map should work with increment function - third")

; Test 5: map with more complex function
(define square-plus-one (lambda (x) (+ (* x x) 1)))
(define complex-result (map square-plus-one (list 2 3)))
(test-assert 
  (= (first complex-result) 5)  ; 2^2 + 1 = 5
  "map should work with complex functions - first")

(test-assert 
  (= (first (rest complex-result)) 10)  ; 3^2 + 1 = 10
  "map should work with complex functions - second")

; Test 6: map with lambda that returns strings
(define number-to-string-map (map (lambda (x) "num") (list 1 2 3)))
(test-assert 
  (= (first number-to-string-map) "num")
  "map should work with functions returning strings")

; Test 7: map with function that tests conditions
; This is-even function gives incorrect results for x < 1!
(define is-even (lambda (x) ((= (/ x 2) (/ (- x 1) 2)) false true)))
(define even-test-result (map is-even (list 2 3 4)))
; Since we can't easily test Church Boolean results with =, we'll test behavior
(test-assert 
  (not (nil? even-test-result))
  "map should work with predicate functions")

; Test 8: map preserves list structure
(define identity (lambda (x) x))
(define identity-result (map identity (list 42)))
(test-assert 
  (= (first identity-result) 42)
  "map with identity should preserve values")

; Test 9: map with wrapped operative
(define wrapped-increment (wrap (vau (x) env (+ (eval x env) 1))))
(define wrapped-result (map wrapped-increment (list 5 6)))
(test-assert 
  (= (first wrapped-result) 6)
  "map should work with wrapped operatives - first")

(test-assert 
  (= (first (rest wrapped-result)) 7)
  "map should work with wrapped operatives - second")

; Test 10: map with function that has side effects
(define-mutable map-side-effect-counter 0)
(define increment-counter-and-double 
  (lambda* (x) 
    (set! map-side-effect-counter (+ map-side-effect-counter 1))
    (* x 2)))
(define side-effect-result (map increment-counter-and-double (list 1 2)))
(test-assert 
  (= map-side-effect-counter 2)
  "map should call function exactly once per element")

(test-assert 
  (= (first side-effect-result) 2)
  "map with side effects should still produce correct results")

; Test 11: map with longer list
(define long-list (list 1 2 3 4 5))
(define doubled-long (map double long-list))
(test-assert 
  (= (first doubled-long) 2)
  "map should work with longer lists - first")

(test-assert 
  (= (first (rest (rest (rest (rest doubled-long))))) 10)
  "map should work with longer lists - last element")

; Test 12: map result is a proper list (not nil-terminated improperly)
(define proper-list-test (map identity (list 7)))
(test-assert 
  (nil? (rest proper-list-test))
  "map result should be properly nil-terminated")

; Test 13: Nested map calls
(define add-ten (lambda (x) (+ x 10)))
(define nested-map-result (map double (map add-ten (list 1 2))))
(test-assert 
  (= (first nested-map-result) 22)  ; (1+10)*2 = 22
  "nested map calls should work - first")

(test-assert 
  (= (first (rest nested-map-result)) 24)  ; (2+10)*2 = 24
  "nested map calls should work - second")

; Test 14: map with function returning different types
(define type-changing (lambda (x) (if (= x 1) "one" x)))
(define type-result (map type-changing (list 1 2)))
(test-assert 
  (= (first type-result) "one")
  "map should handle functions that change types")

(test-assert 
  (= (first (rest type-result)) 2)
  "map should handle mixed return types")

; Test 15: Error case - map with non-function first argument
(test-error (map 42 (list 1 2)) "map should reject non-function first argument")

; Test 16: Error case - map with non-list second argument
(test-error (map double 42) "map should reject non-list second argument")

;------------------------------------------------------------------------------
; apply tests

; Test 1: Basic apply with simple function
(define add-func (lambda (x y) (+ x y)))
(test-assert 
  (= (apply add-func (list 3 4)) 7)
  "apply should work with basic lambda function")

; Test 2: apply with single argument function
(define double-func (lambda (x) (* x 2)))
(test-assert 
  (= (apply double-func (list 5)) 10)
  "apply should work with single argument function")

; Test 3: apply with no-argument function
(define constant-func (lambda () 42))
(test-assert 
  (= (apply constant-func ()) 42)
  "apply should work with no-argument function")

; Test 4: apply with wrapped operatives
(define wrapped-plus (wrap +))
(test-assert 
  (= (apply wrapped-plus (list 10 20 30)) 60)
  "apply should work with wrapped operatives")

; Test 5: apply with multiple arguments
(define sum-three (lambda (a b c) (+ (+ a b) c)))
(test-assert 
  (= (apply sum-three (list 1 2 3)) 6)
  "apply should work with multiple arguments")

; Test 6: apply with built-in wrapped functions
(test-assert 
  (= (apply (wrap *) (list 2 3 4)) 24)
  "apply should work with wrapped built-in operatives")

; Test 7: apply with library functions that return functions
(define make-multiplier (lambda (n) (lambda (x) (* x n))))
(define times-five (make-multiplier 5))
(test-assert 
  (= (apply times-five (list 7)) 35)
  "apply should work with higher-order function results")

; Test 8: apply with lambda that has complex body
(define complex-func 
  (lambda* (a b)
    (define temp (+ a b))
    (define result (* temp 2))
    result))
(test-assert 
  (= (apply complex-func (list 4 6)) 20)  ; (4+6)*2 = 20
  "apply should work with lambda* functions")

; Test 9: apply with function that returns strings
(define string-func (lambda (prefix suffix) "combined"))
(test-assert 
  (= (apply string-func (list "hello" "world")) "combined")
  "apply should work with functions returning strings")

; Test 10: apply with conditional logic in function
(define conditional-func 
  (lambda (x y) 
    (if (= x y) 
        "equal" 
        "not-equal")))
(test-assert 
  (= (apply conditional-func (list 5 5)) "equal")
  "apply should work with conditional functions - equal case")

(test-assert 
  (= (apply conditional-func (list 5 6)) "not-equal")
  "apply should work with conditional functions - not equal case")

; Test 11: apply with side effects
(define-mutable apply-side-effect 0)
(define side-effect-func 
  (lambda* (x)
    (set! apply-side-effect (+ apply-side-effect x))
    x))
(test-assert 
  (= (apply side-effect-func (list 10)) 10)
  "apply should work with side effect functions - return value")

(test-assert 
  (= apply-side-effect 10)
  "apply should work with side effect functions - side effect")

; Test 12: apply with list manipulation functions
(test-assert 
  (= (apply first (list (list 1 2 3))) 1)
  "apply should work with list manipulation - first")

(define make-list (lambda args args))
(define applied-list (apply make-list (list 10 20 30)))
(test-assert 
  (= (first applied-list) 10)
  "apply should work with variadic functions - first element")

(test-assert 
  (= (first (rest applied-list)) 20)
  "apply should work with variadic functions - second element")

; Test 13: Nested apply calls
(define add-two (lambda (x y) (+ x y)))
(test-assert 
  (= (apply add-two (apply list (list 8 9))) 17)
  "nested apply calls should work")

; Test 14: apply with map (higher-order usage)
(define increment (lambda (x) (+ x 1)))
(define numbers (list 1 2 3))
(define incremented (apply map (list increment numbers)))
(test-assert 
  (= (first incremented) 2)
  "apply should work with higher-order functions like map")

(test-assert 
  (= (first (rest incremented)) 3)
  "apply with map should process all elements")

; Test 15: apply preserves function behavior
(define test-func (lambda (a b c) (+ a (* b c))))
(define direct-call (test-func 2 3 4))  ; 2 + (3*4) = 14
(define applied-call (apply test-func (list 2 3 4)))
(test-assert 
  (= direct-call applied-call)
  "apply should preserve function behavior compared to direct calls")

; Test 16: apply with Church Boolean returning functions
(define equality-test (lambda (x y) (= x y)))
(define bool-result (apply equality-test (list 7 7)))
; Test the Church Boolean by using it
(test-assert 
  (= (bool-result "true" "false") "true")
  "apply should work with Church Boolean returning functions")

; Test 17: apply with complex argument lists
(define sum-all (lambda args (foldl + 0 args)))
(test-assert 
  (= (apply sum-all (list 1 2 3 4 5)) 15)
  "apply should work with complex variadic functions")

; Test 18: apply with empty argument list to variadic function
(test-assert 
  (= (apply sum-all ()) 0)
  "apply should work with empty argument lists")

; Test 19: apply error conditions
(test-error (apply) "apply should require exactly 2 arguments")
(test-error (apply add-func) "apply should require exactly 2 arguments") 
(test-error (apply add-func (list 1 2) extra) "apply should require exactly 2 arguments")
(test-error (apply "not-function" (list 1 2)) "apply should reject non-function first argument")
(test-error (apply add-func "not-list") "apply should reject non-list second argument")

; Test 20: apply with library functions
(test-assert 
  (= (apply length (list (list 1 2 3 4))) 4)
  "apply should work with library functions like length")

(define filtered (apply filter (list even? (list 1 2 3 4 5 6))))
(test-assert 
  (= (first filtered) 2)
  "apply should work with library functions like filter")

; Test 21: apply composition patterns
(define compose-with-apply 
  (lambda (f g x) 
    (apply f (list (apply g (list x))))))
(define add-one (lambda (n) (+ n 1)))
(define times-two (lambda (n) (* n 2)))
(test-assert 
  (= (compose-with-apply times-two add-one 5) 12)  ; (5+1)*2 = 12
  "apply should support function composition patterns")

; Test 22: apply with recursive functions
(define factorial-func
  (lambda (n)
    (if (= n 0)
        1
        (* n (factorial-func (- n 1))))))
(test-assert 
  (= (apply factorial-func (list 4)) 24)
  "apply should work with recursive functions")

; Test 23: Performance test - apply vs direct call should be equivalent
(define perf-test-func (lambda (x) (+ x 100)))
(define direct-result (perf-test-func 23))
(define applied-result (apply perf-test-func (list 23)))
(test-assert 
  (= direct-result applied-result)
  "apply should give same results as direct function calls")

; Test 24: apply with curried functions
(define curry-test (lambda (x) (lambda (y) (+ x y))))
(define add-ten (curry-test 10))
(test-assert 
  (= (apply add-ten (list 5)) 15)
  "apply should work with curried functions")

; Test 25: apply used in fold operations
(define apply-in-fold 
  (foldl (lambda (acc elem) 
           (apply + (list acc elem)))
         0
         (list 1 2 3 4)))
(test-assert 
  (= apply-in-fold 10)
  "apply should work when used within fold operations")

;------------------------------------------------------------------------------
; length tests

; Test 1: Empty list should return 0
(test-assert 
  (= (length ()) 0)
  "length of empty list should be 0")

; Test 2: Single element list should return 1
(test-assert 
  (= (length (list 42)) 1)
  "length of single element list should be 1")

; Test 3: Multiple element list
(test-assert 
  (= (length (list 1 2 3)) 3)
  "length should count multiple elements correctly")

; Test 4: Longer list
(test-assert 
  (= (length (list 1 2 3 4 5 6 7)) 7)
  "length should work with longer lists")

; Test 5: List with different data types
(test-assert 
  (= (length (list "hello" 42 () "world")) 4)
  "length should count elements regardless of their types")

; Test 6: List containing nested lists
(test-assert 
  (= (length (list (list 1 2) (list 3 4 5) 6)) 3)
  "length should count top-level elements only")

; Test 7: List with repeated elements
(test-assert 
  (= (length (list 1 1 1 1)) 4)
  "length should count repeated elements")

; Test 8: List with nil/empty elements
(test-assert 
  (= (length (list () () ())) 3)
  "length should count nil elements")

; Test 9: Compare with manual list construction
(define manual-list (cons 1 (cons 2 (cons 3 ()))))
(test-assert 
  (= (length manual-list) 3)
  "length should work with manually constructed lists")

; Test 10: length with string elements
(test-assert 
  (= (length (list "a" "bb" "ccc" "dddd")) 4)
  "length should work with string elements")

; Test 11: length with mixed nested structures
(test-assert 
  (= (length (list 1 (list 2 3) "four" (list 5 (list 6 7)))) 4)
  "length should work with complex nested structures")

; Test 12: length used in expressions
(test-assert 
  (= (+ (length (list 1 2)) (length (list 3 4 5))) 5)
  "length results should work in arithmetic expressions")

; Test 13: length with library-generated lists
(test-assert 
  (= (length (map (lambda (x) (* x 2)) (list 1 2 3 4))) 4)
  "length should work with lists generated by other library functions")

; Test 14: length with filtered lists
(test-assert 
  (= (length (filter even? (list 1 2 3 4 5 6))) 3)
  "length should work with filtered lists")

; Test 15: length with reversed lists
(define original-list (list 10 20 30))
(test-assert 
  (= (length original-list) (length (reverse original-list)))
  "length should be same for original and reversed lists")

; Test 16: length with appended lists
(test-assert 
  (= (length (append (list 1 2) (list 3 4 5))) 5)
  "length should work with appended lists")

; Test 17: length with prepend results
(test-assert 
  (= (length (prepend 1 2 (list 3 4))) 4)
  "length should work with prepend results")

; Test 18: length in conditional expressions
(test-assert 
  (= (if (= (length (list 1 2 3)) 3) "correct" "wrong") "correct")
  "length should work in conditional expressions")

; Test 19: length with iota-generated lists
(test-assert 
  (= (length (iota 5)) 5)
  "length should work with iota-generated lists")

(test-assert 
  (= (length (iota 0)) 0)
  "length of iota 0 should be 0")

; Test 20: length error conditions
(test-error (length) "length should require exactly 1 argument")
(test-error (length (list 1 2) extra) "length should require exactly 1 argument")
(test-error (length 42) "length should reject non-list arguments")
(test-error (length "not-a-list") "length should reject string arguments")
(test-error (length true) "length should reject Church Boolean arguments")

; Test 21: length with very nested structure
(define deeply-nested (list 1 (list 2 (list 3 (list 4)))))
(test-assert 
  (= (length deeply-nested) 2)
  "length should only count top-level elements in deeply nested structures")

; Test 22: length consistency with other operations
(define test-list (list "a" "b" "c"))
(test-assert 
  (= (length test-list) (length (foldr cons test-list ())))
  "length should be consistent with foldr-reconstructed lists")

; Test 23: length with Church Boolean elements
(define bool-list (list true false (= 1 1) (= 1 2)))
(test-assert 
  (= (length bool-list) 4)
  "length should count Church Boolean elements")

; Test 24: length used in higher-order functions
(define get-length (lambda (lst) (length lst)))
(test-assert 
  (= (get-length (list 10 20 30 40)) 4)
  "length should work when wrapped in other functions")

; Test 25: length with apply
(test-assert 
  (= (apply length (list (list 7 8 9))) 3)
  "length should work with apply")

;------------------------------------------------------------------------------
; reverse tests

; Test 1: Empty list should return empty list
(test-assert 
  (nil? (reverse ()))
  "reverse of empty list should be empty")

; Test 2: Single element list should return same list
(define single-reversed (reverse (list 42)))
(test-assert 
  (= (first single-reversed) 42)
  "reverse of single element should preserve element")

(test-assert 
  (nil? (rest single-reversed))
  "reverse of single element should create proper single-element list")

; Test 3: Two element list should swap order
(define two-elem-reversed (reverse (list 1 2)))
(test-assert 
  (= (first two-elem-reversed) 2)
  "reverse should put last element first - two elements")

(test-assert 
  (= (first (rest two-elem-reversed)) 1)
  "reverse should put first element last - two elements")

; Test 4: Multiple element list reversal
(define multi-reversed (reverse (list 1 2 3 4)))
(test-assert 
  (= (first multi-reversed) 4)
  "reverse should put last element first - multiple elements")

(test-assert 
  (= (first (rest multi-reversed)) 3)
  "reverse should reverse order - second element")

(test-assert 
  (= (first (rest (rest multi-reversed))) 2)
  "reverse should reverse order - third element")

(test-assert 
  (= (first (rest (rest (rest multi-reversed)))) 1)
  "reverse should reverse order - fourth element")

; Test 5: reverse preserves list length
(define original-for-length (list 10 20 30))
(test-assert 
  (= (length original-for-length) (length (reverse original-for-length)))
  "reverse should preserve list length")

; Test 6: Double reversal should restore original
(define original-double (list 5 6 7))
(define double-reversed (reverse (reverse original-double)))
(test-assert 
  (= (first original-double) (first double-reversed))
  "double reverse should restore original - first element")

(test-assert 
  (= (first (rest original-double)) (first (rest double-reversed)))
  "double reverse should restore original - second element")

(test-assert 
  (= (first (rest (rest original-double))) (first (rest (rest double-reversed))))
  "double reverse should restore original - third element")

; Test 7: reverse with different data types
(define mixed-list (list "hello" 42 "world"))
(define mixed-reversed (reverse mixed-list))
(test-assert 
  (= (first mixed-reversed) "world")
  "reverse should work with mixed types - first element")

(test-assert 
  (= (first (rest mixed-reversed)) 42)
  "reverse should work with mixed types - middle element")

(test-assert 
  (= (first (rest (rest mixed-reversed))) "hello")
  "reverse should work with mixed types - last element")

; Test 8: reverse with nested lists
(define nested-list (list (list 1 2) (list 3 4) (list 5 6)))
(define nested-reversed (reverse nested-list))
(test-assert 
  (= (first (first nested-reversed)) 5)
  "reverse should work with nested structures - first nested element")

(test-assert 
  (= (first (first (rest nested-reversed))) 3)
  "reverse should work with nested structures - middle nested element")

; Test 9: reverse doesn't reverse inner structure
(define inner-structure (list (list 1 2 3) (list 4 5 6)))
(define outer-reversed (reverse inner-structure))
(test-assert 
  (= (first (first outer-reversed)) 4)
  "reverse should only reverse outer list, not inner lists")

(test-assert 
  (= (first (rest (first outer-reversed))) 5)
  "reverse should preserve inner list structure")

; Test 10: reverse with manually constructed list
(define manual-cons-list (cons 1 (cons 2 (cons 3 ()))))
(define manual-reversed (reverse manual-cons-list))
(test-assert 
  (= (first manual-reversed) 3)
  "reverse should work with manually constructed lists")

; Test 11: reverse with Church Boolean elements
(define bool-list (list true false (= 1 1)))
(define bool-reversed (reverse bool-list))
; Test by using the Church Boolean
(test-assert 
  (= ((first (rest (rest bool-reversed))) "true" "false") "true")
  "reverse should work with Church Boolean elements")

; Test 12: reverse with library-generated lists
(define mapped-list (map (lambda (x) (* x 2)) (list 1 2 3)))
(define mapped-reversed (reverse mapped-list))
(test-assert 
  (= (first mapped-reversed) 6)  ; 3*2 = 6 (originally last)
  "reverse should work with library-generated lists")

; Test 13: reverse with iota-generated list
(define iota-list (iota 4))  ; Should be (0 1 2 3)
(define iota-reversed (reverse iota-list))
(test-assert 
  (= (first iota-reversed) 3)
  "reverse should work with iota-generated lists - first")

(test-assert 
  (= (first (rest (rest (rest iota-reversed)))) 0)
  "reverse should work with iota-generated lists - last")

; Test 14: reverse used in expressions
(define expr-result (first (reverse (list 1 2 3 4 5))))
(test-assert 
  (= expr-result 5)
  "reverse should work in complex expressions")

; Test 15: reverse with filter results
(define filtered-even (filter even? (list 1 2 3 4 5 6)))
(define filtered-reversed (reverse filtered-even))
(test-assert 
  (= (first filtered-reversed) 6)
  "reverse should work with filtered lists")

; Test 16: reverse composition with other functions
(define compose-reverse-map 
  (lambda (f lst) 
    (reverse (map f lst))))
(define composed-result (compose-reverse-map (lambda (x) (+ x 10)) (list 1 2 3)))
(test-assert 
  (= (first composed-result) 13)  ; (3+10) = 13, originally last
  "reverse should compose well with other functions")

; Test 17: reverse with apply
(test-assert 
  (= (first (apply reverse (list (list 10 20 30)))) 30)
  "reverse should work with apply")

; Test 18: reverse in fold operations
(define fold-with-reverse 
  (foldl (lambda (acc elem) 
           (append acc (reverse (list elem))))
         ()
         (list 1 2 3)))
(test-assert 
  (= (first fold-with-reverse) 1)
  "reverse should work within fold operations")

; Test 19: reverse with prepend results
(define prepended (prepend 1 2 (list 3 4)))
(define prepend-reversed (reverse prepended))
(test-assert 
  (= (first prepend-reversed) 4)
  "reverse should work with prepend results")

; Test 20: reverse with append results
(define appended (append (list 1 2) (list 3 4)))
(define append-reversed (reverse appended))
(test-assert 
  (= (first append-reversed) 4)
  "reverse should work with append results - first")

(test-assert 
  (= (first (rest (rest (rest append-reversed)))) 1)
  "reverse should work with append results - last")

; Test 21: reverse error conditions
(test-error (reverse) "reverse should require exactly 1 argument")
(test-error (reverse (list 1 2) extra) "reverse should require exactly 1 argument")
(test-error (reverse 42) "reverse should reject non-list arguments")
(test-error (reverse "not-a-list") "reverse should reject string arguments")
(test-error (reverse true) "reverse should reject Church Boolean arguments")

; Test 22: reverse with very long list (performance check)
(define long-original (iota 10))
(define long-reversed (reverse long-original))
(test-assert 
  (= (first long-reversed) 9)  ; Last element of iota 10
  "reverse should work with longer lists - first")

(test-assert 
  (= (first (rest (rest (rest (rest (rest (rest (rest (rest (rest long-reversed)))))))))) 0)
  "reverse should work with longer lists - last")

; Test 23: reverse idempotency property
(define test-idempotent (list 1))
(test-assert 
  (= (first (reverse test-idempotent)) (first test-idempotent))
  "reverse of single element should be idempotent")

; Test 24: reverse with lambda-generated lists
(define lambda-list ((lambda () (list 7 8 9))))
(define lambda-reversed (reverse lambda-list))
(test-assert 
  (= (first lambda-reversed) 9)
  "reverse should work with lambda-generated lists")

; Test 25: reverse symmetry property
(define symmetry-list (list 1 2 2 1))
(define symmetry-reversed (reverse symmetry-list))
; This symmetric list should equal its reverse
(test-assert 
  (= (first symmetry-list) (first symmetry-reversed))
  "reverse should handle symmetric lists correctly - first matches")

(test-assert 
  (= (first (rest symmetry-list)) (first (rest symmetry-reversed)))
  "reverse should handle symmetric lists correctly - second matches")

;------------------------------------------------------------------------------
; append tests

; Test 1: Empty lists should return empty list
(test-assert 
  (nil? (append))
  "append with no arguments should return empty list")

(test-assert 
  (nil? (append ()))
  "append with single empty list should return empty list")

(test-assert 
  (nil? (append () ()))
  "append with two empty lists should return empty list")

; Test 2: Append empty to non-empty
(define result-empty-first (append () (list 1 2 3)))
(test-assert 
  (= (first result-empty-first) 1)
  "append empty to non-empty should preserve non-empty - first")

(test-assert 
  (= (first (rest result-empty-first)) 2)
  "append empty to non-empty should preserve non-empty - second")

(test-assert 
  (= (first (rest (rest result-empty-first))) 3)
  "append empty to non-empty should preserve non-empty - third")

; Test 3: Append non-empty to empty
(define result-empty-second (append (list 1 2 3) ()))
(test-assert 
  (= (first result-empty-second) 1)
  "append non-empty to empty should preserve non-empty - first")

(test-assert 
  (= (first (rest result-empty-second)) 2)
  "append non-empty to empty should preserve non-empty - second")

(test-assert 
  (= (first (rest (rest result-empty-second))) 3)
  "append non-empty to empty should preserve non-empty - third")

; Test 4: Two non-empty lists
(define result-both-nonempty (append (list 1 2) (list 3 4)))
(test-assert 
  (= (first result-both-nonempty) 1)
  "append two non-empty lists - first element")

(test-assert 
  (= (first (rest result-both-nonempty)) 2)
  "append two non-empty lists - second element")

(test-assert 
  (= (first (rest (rest result-both-nonempty))) 3)
  "append two non-empty lists - third element")

(test-assert 
  (= (first (rest (rest (rest result-both-nonempty)))) 4)
  "append two non-empty lists - fourth element")

; Test 5: Multiple list append (variadic)
(define result-multiple (append (list 1) (list 2 3) (list 4 5 6)))
(test-assert 
  (= (length result-multiple) 6)
  "append multiple lists should have correct length")

(test-assert 
  (= (first result-multiple) 1)
  "append multiple lists - first element")

(test-assert 
  (= (first (rest result-multiple)) 2)
  "append multiple lists - second element")

(test-assert 
  (= (first (rest (rest (rest result-multiple)))) 4)
  "append multiple lists - fourth element from third list")

; Test 6: Single element lists
(define single-result (append (list 10) (list 20) (list 30)))
(test-assert 
  (= (first single-result) 10)
  "append single element lists - first")

(test-assert 
  (= (first (rest single-result)) 20)
  "append single element lists - second")

(test-assert 
  (= (first (rest (rest single-result))) 30)
  "append single element lists - third")

; Test 7: Mixed data types
(define mixed-result (append (list "hello" 42) (list true "world")))
(test-assert 
  (= (first mixed-result) "hello")
  "append mixed types - string first")

(test-assert 
  (= (first (rest mixed-result)) 42)
  "append mixed types - number second")

(test-assert 
  (= ((first (rest (rest mixed-result))) "yes" "no") "yes")
  "append mixed types - Church Boolean third")

(test-assert 
  (= (first (rest (rest (rest mixed-result)))) "world")
  "append mixed types - string fourth")

; Test 8: Nested lists
(define nested-result (append (list (list 1 2) 3) (list 4 (list 5 6))))
(test-assert 
  (= (first (first nested-result)) 1)
  "append nested lists - nested first element")

(test-assert 
  (= (first (rest nested-result)) 3)
  "append nested lists - second element")

(test-assert 
  (= (first (rest (rest nested-result))) 4)
  "append nested lists - third element")

(test-assert 
  (= (first (first (rest (rest (rest nested-result))))) 5)
  "append nested lists - nested fourth element")

; Test 9: append preserves structure
(define original-first (list 1 2))
(define original-second (list 3 4))
(define appended-preserve (append original-first original-second))
; Modifying the result shouldn't affect originals (structural sharing test)
(test-assert 
  (= (first original-first) 1)
  "append should not mutate original lists")

; Test 10: append with many empty lists
(define many-empty-result (append () () (list 1 2) () () (list 3) ()))
(test-assert 
  (= (first many-empty-result) 1)
  "append with many empty lists - first non-empty element")

(test-assert 
  (= (first (rest (rest many-empty-result))) 3)
  "append with many empty lists - second non-empty element")

; Test 11: append with library-generated lists
(define mapped-list (map (lambda (x) (* x 2)) (list 1 2 3)))
(define filtered-list (filter even? (list 2 4 6 8)))
(define lib-result (append mapped-list filtered-list))
(test-assert 
  (= (first lib-result) 2)  ; 1*2 from mapped list
  "append with library lists - first from map")

(test-assert 
  (= (first (rest (rest (rest lib-result)))) 2)  ; first even from filter
  "append with library lists - first from filter")

; Test 12: append with iota-generated lists
(define iota-result (append (iota 3) (iota 2)))
(test-assert 
  (= (first iota-result) 0)
  "append with iota lists - first element")

(test-assert 
  (= (first (rest (rest (rest iota-result)))) 0)
  "append with iota lists - start of second iota")

(test-assert 
  (= (length iota-result) 5)
  "append with iota lists - correct total length")

; Test 13: append with reversed lists
(define reverse-result (append (reverse (list 1 2 3)) (list 4 5)))
(test-assert 
  (= (first reverse-result) 3)  ; Last element of reversed list
  "append with reversed list - first element")

(test-assert 
  (= (first (rest (rest (rest reverse-result)))) 4)
  "append with reversed list - start of second list")

; Test 14: append in expressions
(test-assert 
  (= (length (append (list 1 2) (list 3 4 5))) 5)
  "append should work in complex expressions")

; Test 15: append with manually constructed lists
(define manual-list (cons 1 (cons 2 ())))
(define manual-result (append manual-list (list 3 4)))
(test-assert 
  (= (first manual-result) 1)
  "append with manually constructed lists - first")

(test-assert 
  (= (first (rest (rest manual-result))) 3)
  "append with manually constructed lists - third")

; Test 16: append with prepend results
(define prepend-result (prepend 1 2 (list 3 4)))
(define append-prepend (append prepend-result (list 5 6)))
(test-assert 
  (= (first append-prepend) 1)
  "append with prepend results - first")

(test-assert 
  (= (first (rest (rest (rest (rest append-prepend))))) 5)
  "append with prepend results - start of appended part")

; Test 17: append used in higher-order functions
(define hof-result (map (lambda (lst) (append lst (list 0))) (list (list 1) (list 2 3))))
(test-assert 
  (= (first (first hof-result)) 1)
  "append in higher-order context - first list first element")

(test-assert 
  (= (first (rest (first hof-result))) 0)
  "append in higher-order context - first list appended element")

; Test 18: append with Church Boolean elements
(define bool-append (append (list true false) (list (= 1 1))))
(test-assert 
  (= ((first bool-append) "true" "false") "true")
  "append with Church Booleans - first element")

(test-assert 
  (= ((first (rest bool-append)) "true" "false") "false")
  "append with Church Booleans - second element")

; Test 19: append associativity property
(define assoc-a (list 1 2))
(define assoc-b (list 3 4))
(define assoc-c (list 5 6))
(define left-assoc (append (append assoc-a assoc-b) assoc-c))
(define right-assoc (append assoc-a (append assoc-b assoc-c)))
(test-assert 
  (= (first left-assoc) (first right-assoc))
  "append should be associative - first elements match")

(test-assert 
  (= (first (rest (rest (rest left-assoc)))) (first (rest (rest (rest right-assoc)))))
  "append should be associative - fourth elements match")

; Test 20: append identity property with empty list
(define identity-test (list 7 8 9))
(define left-identity (append () identity-test))
(define right-identity (append identity-test ()))
(test-assert 
  (= (first identity-test) (first left-identity))
  "append with empty list should be left identity")

(test-assert 
  (= (first identity-test) (first right-identity))
  "append with empty list should be right identity")

; Test 21: append with apply
(define apply-lists (list (list 1 2) (list 3 4) (list 5)))
(define apply-result (apply append apply-lists))
(test-assert 
  (= (first apply-result) 1)
  "append with apply - first element")

(test-assert 
  (= (first (rest (rest (rest (rest apply-result))))) 5)
  "append with apply - last element")

; Test 22: append error conditions
(test-error (append 42) "append should reject non-list arguments")
(test-error (append (list 1 2) "not-a-list") "append should reject non-list arguments in variadic position")
(test-error (append (list 1) 42 (list 3)) "append should reject non-list arguments in middle")

; Test 23: append with very long lists
(define long-first (iota 5))
(define long-second (iota 3))
(define long-result (append long-first long-second))
(test-assert 
  (= (length long-result) 8)
  "append with longer lists - correct length")

(test-assert 
  (= (first long-result) 0)
  "append with longer lists - first element")

(test-assert 
  (= (first (rest (rest (rest (rest (rest long-result)))))) 0)
  "append with longer lists - start of second list")

; Test 24: append used in fold operations
(define fold-append 
  (foldl (lambda (acc elem) 
           (append acc (list elem)))
         ()
         (list 10 20 30)))
(test-assert 
  (= (first fold-append) 10)
  "append in fold operations - first")

(test-assert 
  (= (first (rest (rest fold-append))) 30)
  "append in fold operations - third")

; Test 25: append performance - many small lists
(define many-small (append (list 1) (list 2) (list 3) (list 4) (list 5)))
(test-assert 
  (= (length many-small) 5)
  "append many small lists - correct length")

(test-assert 
  (= (first many-small) 1)
  "append many small lists - first")

(test-assert 
  (= (first (rest (rest (rest (rest many-small))))) 5)
  "append many small lists - last")

;------------------------------------------------------------------------------
; filter tests

; Test 1: Basic filter with predicate that returns true for some elements
(define is-positive (lambda (x) (not (= x 0))))
(define positive-result (filter is-positive (list -1 0 1 2 -3 4)))
(test-assert 
  (= (first positive-result) -1)
  "filter should preserve elements where predicate is true - first")

(test-assert 
  (= (first (rest positive-result)) 1)
  "filter should preserve elements where predicate is true - second")

(test-assert 
  (= (first (rest (rest positive-result))) 2)
  "filter should preserve elements where predicate is true - third")

; Test 2: Empty list should return empty list
(test-assert 
  (nil? (filter is-positive ()))
  "filter with empty list should return nil")

; Test 3: Filter with predicate that rejects all elements
(define always-false (lambda (x) false))
(test-assert 
  (nil? (filter always-false (list 1 2 3)))
  "filter with always-false predicate should return nil")

; Test 4: Filter with predicate that accepts all elements
(define always-true (lambda (x) true))
(define all-accepted (filter always-true (list 1 2 3)))
(test-assert 
  (= (first all-accepted) 1)
  "filter with always-true predicate should preserve all elements - first")

(test-assert 
  (= (first (rest all-accepted)) 2)
  "filter with always-true predicate should preserve all elements - second")

(test-assert 
  (= (first (rest (rest all-accepted))) 3)
  "filter with always-true predicate should preserve all elements - third")

; Test 5: Filter with even? predicate (from library)
(define even-numbers (filter even? (list 1 2 3 4 5 6)))
(test-assert 
  (= (first even-numbers) 2)
  "filter with even? should work - first even")

(test-assert 
  (= (first (rest even-numbers)) 4)
  "filter with even? should work - second even")

(test-assert 
  (= (first (rest (rest even-numbers))) 6)
  "filter with even? should work - third even")

; Test 6: Filter with odd? predicate (from library)
(define odd-numbers (filter odd? (list 1 2 3 4 5)))
(test-assert 
  (= (first odd-numbers) 1)
  "filter with odd? should work - first odd")

(test-assert 
  (= (first (rest odd-numbers)) 3)
  "filter with odd? should work - second odd")

(test-assert 
  (= (first (rest (rest odd-numbers))) 5)
  "filter with odd? should work - third odd")

; Test 7: Filter preserves order
(define order-test (filter even? (list 2 1 4 3 6 5 8)))
(test-assert 
  (= (first order-test) 2)
  "filter should preserve original order - first")

(test-assert 
  (= (first (rest order-test)) 4)
  "filter should preserve original order - second")

(test-assert 
  (= (first (rest (rest order-test))) 6)
  "filter should preserve original order - third")

(test-assert 
  (= (first (rest (rest (rest order-test)))) 8)
  "filter should preserve original order - fourth")

; Test 8: Filter with single element list - true case
(define single-true (filter even? (list 4)))
(test-assert 
  (= (first single-true) 4)
  "filter single element list - predicate true")

(test-assert 
  (nil? (rest single-true))
  "filter single element - result should be proper list")

; Test 9: Filter with single element list - false case
(test-assert 
  (nil? (filter even? (list 3)))
  "filter single element list - predicate false should return nil")

; Test 10: Filter with complex predicate
(define greater-than-two (lambda (x) (not (or (= x 1) (= x 2)))))
(define complex-result (filter greater-than-two (list 1 2 3 4 1 5 2)))
(test-assert 
  (= (first complex-result) 3)
  "filter with complex predicate - first")

(test-assert 
  (= (first (rest complex-result)) 4)
  "filter with complex predicate - second")

(test-assert 
  (= (first (rest (rest complex-result))) 5)
  "filter with complex predicate - third")

; Test 11: Filter with Church Boolean predicate returning functions
(define church-bool-pred (lambda (x) (= x 5)))  ; Returns Church Boolean
(define church-result (filter church-bool-pred (list 3 5 7 5 9)))
(test-assert 
  (= (first church-result) 5)
  "filter should work with Church Boolean predicates - first")

(test-assert 
  (= (first (rest church-result)) 5)
  "filter should work with Church Boolean predicates - second")

; Test 12: Filter with wrapped operative predicate
(define wrapped-equal-three (wrap (vau (x) env (= (eval x env) 3))))
(define wrapped-result (filter wrapped-equal-three (list 1 3 2 3 4)))
(test-assert 
  (= (first wrapped-result) 3)
  "filter should work with wrapped operatives - first")

(test-assert 
  (= (first (rest wrapped-result)) 3)
  "filter should work with wrapped operatives - second")

; Test 13: Filter with predicate that has side effects
(define-mutable filter-side-counter 0)
(define counting-predicate 
  (lambda* (x)
    (set! filter-side-counter (+ filter-side-counter 1))
    (even? x)))
(define side-effect-result (filter counting-predicate (list 1 2 3 4)))
(test-assert 
  (= filter-side-counter 4)
  "filter should call predicate exactly once per element")

(test-assert 
  (= (first side-effect-result) 2)
  "filter with side effects should still produce correct results")

; Test 14: Filter with different data types
(define mixed-filter (filter string? (list 42 "test" 99 "test" "other")))
(test-assert 
  (= (first mixed-filter) "test")
  "filter should work with mixed data types - first")

(test-assert 
  (= (second mixed-filter) "test")
  "filter should work with mixed data types - second")

; Test 15: Filter result is properly structured
(define structure-test (filter even? (list 2)))
(test-assert 
  (nil? (rest structure-test))
  "filter result should be properly nil-terminated")

; Test 16: Filter with longer list
(define long-list (list 1 2 3 4 5 6 7 8 9 10))
(define long-evens (filter even? long-list))
(test-assert 
  (= (length long-evens) 5)
  "filter should work with longer lists - correct count")

(test-assert 
  (= (first long-evens) 2)
  "filter should work with longer lists - first element")

(test-assert 
  (= (first (rest (rest (rest (rest long-evens))))) 10)
  "filter should work with longer lists - last element")

; Test 17: Filter with nested lists as elements
(define has-two-elements (lambda (lst) (= (length lst) 2)))
(define nested-test (filter has-two-elements (list (list 1) (list 2 3) (list 4 5 6) (list 7 8))))
(test-assert 
  (= (first (first nested-test)) 2)
  "filter should work with nested structures - first list first element")

(test-assert 
  (= (first (first (rest nested-test))) 7)
  "filter should work with nested structures - second list first element")

; Test 18: Filter with iota-generated list
(define iota-evens (filter even? (iota 8)))
(test-assert 
  (= (first iota-evens) 0)
  "filter should work with iota-generated lists - first")

(test-assert 
  (= (first (rest iota-evens)) 2)
  "filter should work with iota-generated lists - second")

; Test 19: Filter composition with other functions
(define doubled-evens (map (lambda (x) (* x 2)) (filter even? (list 1 2 3 4 5))))
(test-assert 
  (= (first doubled-evens) 4)  ; 2*2
  "filter should compose with other functions - first")

(test-assert 
  (= (first (rest doubled-evens)) 8)  ; 4*2
  "filter should compose with other functions - second")

; Test 20: Filter used in fold operations
(define sum-of-evens (foldl + 0 (filter even? (list 1 2 3 4 5 6))))
(test-assert 
  (= sum-of-evens 12)  ; 2+4+6 = 12
  "filter should work within fold operations")

; Test 21: Filter with apply
(define apply-filter-result (apply filter (list even? (list 1 2 3 4))))
(test-assert 
  (= (first apply-filter-result) 2)
  "filter should work with apply")

; Test 22: Filter with lambda-generated predicates
(define make-greater-than (lambda (threshold) (lambda (x) (not (or (= x threshold) (= x (- threshold 1)) (= x (- threshold 2)))))))
(define greater-than-three (make-greater-than 3))
(define lambda-pred-result (filter greater-than-three (list 1 2 3 4 5)))
(test-assert 
  (= (first lambda-pred-result) 4)
  "filter should work with lambda-generated predicates")

; Test 23: Filter with reversed input maintains order
(define reverse-input (reverse (list 1 2 3 4 5 6)))
(define reverse-evens (filter even? reverse-input))
(test-assert 
  (= (first reverse-evens) 6)  ; First even in reversed list
  "filter should maintain order of input list")

(test-assert 
  (= (first (rest reverse-evens)) 4)
  "filter should preserve input order - second")

; Test 24: Filter with conditional predicate
(define conditional-pred 
  (lambda (x) 
    (if (= x 0) 
        false 
        (even? x))))
(define conditional-result (filter conditional-pred (list 0 1 2 3 4)))
(test-assert 
  (= (first conditional-result) 2)
  "filter should work with conditional predicates - first")

(test-assert 
  (= (first (rest conditional-result)) 4)
  "filter should work with conditional predicates - second")

; Test 25: Filter error conditions
(test-error (filter) "filter should require exactly 2 arguments")
(test-error (filter even?) "filter should require exactly 2 arguments")
(test-error (filter even? (list 1 2) extra) "filter should require exactly 2 arguments")
(test-error (filter "not-function" (list 1 2)) "filter should reject non-function predicates")
(test-error (filter even? 42) "filter should reject non-list second argument")
(test-error (filter even? "not-list") "filter should reject string second argument")

;------------------------------------------------------------------------------
; nth tests

; Test 1: Basic nth functionality
(define test-list (list 10 20 30 40 50))
(test-assert 
  (= (nth test-list 0) 10)
  "nth should return first element with index 0")

(test-assert 
  (= (nth test-list 1) 20)
  "nth should return second element with index 1")

(test-assert 
  (= (nth test-list 2) 30)
  "nth should return third element with index 2")

(test-assert 
  (= (nth test-list 4) 50)
  "nth should return last element with correct index")

; Test 2: Single element list
(define single-list (list 42))
(test-assert 
  (= (nth single-list 0) 42)
  "nth should work with single element list")

; Test 3: nth with different data types
(define mixed-list (list "hello" 123 true (list 1 2)))
(test-assert 
  (= (nth mixed-list 0) "hello")
  "nth should work with strings")

(test-assert 
  (= (nth mixed-list 1) 123)
  "nth should work with numbers")

(test-assert 
  (= ((nth mixed-list 2) "yes" "no") "yes")
  "nth should work with Church Booleans")

(test-assert 
  (= (first (nth mixed-list 3)) 1)
  "nth should work with nested lists")

; Test 4: nth with library-generated lists
(define iota-list (iota 5))  ; (0 1 2 3 4)
(test-assert 
  (= (nth iota-list 0) 0)
  "nth should work with iota-generated lists - first")

(test-assert 
  (= (nth iota-list 3) 3)
  "nth should work with iota-generated lists - middle")

(test-assert 
  (= (nth iota-list 4) 4)
  "nth should work with iota-generated lists - last")

; Test 5: nth with filtered lists
(define even-list (filter even? (iota 10)))  ; (0 2 4 6 8)
(test-assert 
  (= (nth even-list 0) 0)
  "nth should work with filtered lists - first")

(test-assert 
  (= (nth even-list 2) 4)
  "nth should work with filtered lists - middle")

(test-assert 
  (= (nth even-list 4) 8)
  "nth should work with filtered lists - last")

; Test 6: nth with mapped lists
(define doubled-list (map (lambda (x) (* x 2)) (list 1 2 3 4)))
(test-assert 
  (= (nth doubled-list 0) 2)
  "nth should work with mapped lists - first")

(test-assert 
  (= (nth doubled-list 3) 8)
  "nth should work with mapped lists - last")

; Test 7: nth with reversed lists
(define original-list (list 1 2 3 4 5))
(define reversed-list (reverse original-list))
(test-assert 
  (= (nth reversed-list 0) 5)
  "nth should work with reversed lists - first")

(test-assert 
  (= (nth reversed-list 4) 1)
  "nth should work with reversed lists - last")

; Test 8: nth with appended lists
(define appended-list (append (list 1 2) (list 3 4)))
(test-assert 
  (= (nth appended-list 0) 1)
  "nth should work with appended lists - first part")

(test-assert 
  (= (nth appended-list 2) 3)
  "nth should work with appended lists - second part")

; Test 9: nth with prepended lists
(define prepended-list (prepend 10 20 (list 30 40)))
(test-assert 
  (= (nth prepended-list 0) 10)
  "nth should work with prepended lists - prepended part")

(test-assert 
  (= (nth prepended-list 2) 30)
  "nth should work with prepended lists - original part")

; Test 10: nth used in higher-order functions
(define get-second (lambda (lst) (nth lst 1)))
(test-assert 
  (= (get-second (list (q a) (q b) (q c))) (q b))
  "nth should work in higher-order functions")

; Test 11: nth with apply
(test-assert 
  (= (apply nth (list (list 7 8 9) 1)) 8)
  "nth should work with apply")

; Test 12: nth used in fold operations
(define first-elements (map (lambda (lst) (nth lst 0)) (list (list 1 2) (list 3 4) (list 5 6))))
(test-assert 
  (= (first first-elements) 1)
  "nth should work in map operations - first result")

(test-assert 
  (= (nth first-elements 2) 5)
  "nth should work in map operations - third result")

; Test 13: nth with string elements
(define string-list (list "first" "second" "third"))
(test-assert 
  (= (nth string-list 1) "second")
  "nth should work with string elements")

; Test 14: nth with symbol elements
(define symbol-list (list (q alpha) (q beta) (q gamma)))
(test-assert 
  (= (nth symbol-list 2) (q gamma))
  "nth should work with symbol elements")

; Test 15: nth with computed indices
(test-assert 
  (= (nth (list 100 200 300) (+ 1 1)) 300)
  "nth should work with computed indices")

; Test 16: nth consistency with other list operations
(define consistency-list (list (q x) (q y) (q z)))
(test-assert 
  (= (nth consistency-list 0) (first consistency-list))
  "nth 0 should be equivalent to first")

(test-assert 
  (= (nth consistency-list 1) (first (rest consistency-list)))
  "nth 1 should be equivalent to first of rest")

; Test 17: nth with Church Boolean operatives
(define bool-list (list true false (= 1 1) (= 1 2)))
(test-assert 
  (= ((nth bool-list 0) "true" "false") "true")
  "nth should work with Church Boolean operatives - true")

(test-assert 
  (= ((nth bool-list 1) "true" "false") "false")
  "nth should work with Church Boolean operatives - false")

; Test 18: Error conditions - index out of bounds
(test-error (nth (list 1 2 3) 3) "nth should raise error for index out of bounds")
(test-error (nth (list 1 2) 5) "nth should raise error for index way out of bounds")
(test-error (nth () 0) "nth should raise error for empty list")

; Test 19: Error conditions - invalid arguments
(test-error (nth) "nth should require exactly 2 arguments")
(test-error (nth (list 1 2)) "nth should require exactly 2 arguments")
(test-error (nth (list 1 2) 1 extra) "nth should require exactly 2 arguments")
(test-error (nth "not-list" 0) "nth should reject non-list first argument")
(test-error (nth (list 1 2) "not-number") "nth should reject non-numeric index")
(test-error (nth (list 1 2) -1) "nth should reject negative indices")
(test-error (nth (list 1 2) 1.5) "nth should reject non-integer indices")

; Test 20: nth with larger lists (performance check)
(define large-list (iota 20))
(test-assert 
  (= (nth large-list 0) 0)
  "nth should work with larger lists - first")

(test-assert 
  (= (nth large-list 10) 10)
  "nth should work with larger lists - middle")

(test-assert 
  (= (nth large-list 19) 19)
  "nth should work with larger lists - last")

; Test 21: nth with manually constructed lists
(define manual-list (cons 1 (cons 2 (cons 3 ()))))
(test-assert 
  (= (nth manual-list 0) 1)
  "nth should work with manually constructed lists - first")

(test-assert 
  (= (nth manual-list 2) 3)
  "nth should work with manually constructed lists - last")

; Test 22: nth used in conditional expressions
(define conditional-nth 
  (lambda (lst idx default)
    (try (nth lst idx)
         (lambda (error) default))))
(test-assert 
  (= (conditional-nth (list 10 20 30) 1 999) 20)
  "nth should work in conditional expressions - success case")

(test-assert 
  (= (conditional-nth (list 10 20 30) 5 999) 999)
  "nth should work in conditional expressions - error case")

; Test 23: nth with nested list access patterns
(define nested-lists (list (list 1 2 3) (list 4 5 6) (list 7 8 9)))
(test-assert 
  (= (nth (nth nested-lists 1) 2) 6)
  "nth should work for nested list access")

(test-assert 
  (= (nth (nth nested-lists 2) 0) 7)
  "nth should work for nested list access - different indices")

; Test 24: nth with fold operations
(define sum-nth-elements 
  (foldl (lambda (acc lst) (+ acc (nth lst 0))) 0 (list (list 1 2) (list 3 4) (list 5 6))))
(test-assert 
  (= sum-nth-elements 9)  ; 1 + 3 + 5 = 9
  "nth should work within fold operations")

; Test 25: nth boundary conditions
(define boundary-list (list (q only)))
(test-assert 
  (= (nth boundary-list 0) (q only))
  "nth should work with single-element list at boundary")

(test-error (nth boundary-list 1) "nth should fail just past boundary of single-element list")

;------------------------------------------------------------------------------
; drop tests
(lndisplayln "drop/take tests")

; Test 1: Basic drop functionality
(define test-drop-list (list 1 2 3 4 5))
(define dropped-two (drop 2 test-drop-list))
(test-assert 
  (= (first dropped-two) 3)
  "drop should remove first n elements - first remaining")

(test-assert 
  (= (first (rest dropped-two)) 4)
  "drop should remove first n elements - second remaining")

(test-assert 
  (= (length dropped-two) 3)
  "drop should return list with correct length")

; Test 2: Drop 0 elements should return original list
(define dropped-zero (drop 0 (list 10 20 30)))
(test-assert 
  (= (first dropped-zero) 10)
  "drop 0 should return original list")

(test-assert 
  (= (length dropped-zero) 3)
  "drop 0 should preserve list length")

; Test 3: Drop all elements
(define original-list (list 1 2 3))
(define dropped-all (drop 3 original-list))
(test-assert 
  (nil? dropped-all)
  "drop all elements should return empty list")

; Test 4: Drop more than list length
(define dropped-excess (drop 10 (list 1 2 3)))
(test-assert 
  (nil? dropped-excess)
  "drop more than length should return empty list")

; Test 5: Drop from empty list
(test-assert 
  (nil? (drop 5 ()))
  "drop from empty list should return empty list")

; Test 6: Drop single element
(define single-elem-list (list 42))
(test-assert 
  (= (first (drop 0 single-elem-list)) 42)
  "drop 0 from single element should preserve element")

(test-assert 
  (nil? (drop 1 single-elem-list))
  "drop 1 from single element should return empty")

; Test 7: Drop with different data types
(define mixed-list (list "hello" 42 true (list 1 2)))
(define mixed-dropped (drop 1 mixed-list))
(test-assert 
  (= (first mixed-dropped) 42)
  "drop should work with mixed data types")

; Test 8: Drop with library-generated lists
(define iota-list (iota 6))  ; (0 1 2 3 4 5)
(define iota-dropped (drop 2 iota-list))
(test-assert 
  (= (first iota-dropped) 2)
  "drop should work with iota-generated lists")

(test-assert 
  (= (length iota-dropped) 4)
  "drop should preserve remaining length correctly")

; Test 9: Drop with filtered lists
(define even-list (filter even? (iota 10)))
(define even-dropped (drop 1 even-list))
(test-assert 
  (= (first even-dropped) 2)  ; Second even number (after 0)
  "drop should work with filtered lists")

; Test 10: Drop with mapped lists
(define doubled-list (map (lambda (x) (* x 2)) (list 1 2 3 4)))
(define doubled-dropped (drop 1 doubled-list))
(test-assert 
  (= (first doubled-dropped) 4)  ; 2*2
  "drop should work with mapped lists")

; Test 11: Drop used with other functions
(define drop-and-reverse (reverse (drop 2 (list 1 2 3 4 5))))
(test-assert 
  (= (first drop-and-reverse) 5)
  "drop should compose with other functions")

; Test 12: Drop with nested lists
(define nested-list (list (list 1 2) (list 3 4) (list 5 6)))
(define nested-dropped (drop 1 nested-list))
(test-assert 
  (= (first (first nested-dropped)) 3)
  "drop should work with nested lists")

; Test 13: Drop with apply
(test-assert 
  (= (first (apply drop (list 1 (list 10 20 30)))) 20)
  "drop should work with apply")

; Test 14: Drop in fold operations
(define drop-fold-result 
  (foldl (lambda (acc n) (+ acc (length (drop n (list 1 2 3 4 5))))) 
         0 
         (list 0 1 2 3)))
(test-assert 
  (= drop-fold-result 14)  ; 5+4+3+2 = 14
  "drop should work in fold operations")

; Test 15: Drop with Church Boolean elements
(define bool-list (list true false (= 1 1) (= 1 2)))
(define bool-dropped (drop 1 bool-list))
(test-assert 
  (= ((first bool-dropped) "true" "false") "false")
  "drop should work with Church Boolean elements")

; Test 16: Error conditions for drop
(test-error (drop) "drop should require exactly 2 arguments")
(test-error (drop 2) "drop should require exactly 2 arguments")
(test-error (drop 1 2 3) "drop should require exactly 2 arguments")
(test-error (drop "not-number" (list 1 2)) "drop should reject non-numeric first argument")
(test-error (drop 2 "not-list") "drop should reject non-list second argument")
(test-error (drop -1 (list 1 2)) "drop should reject negative numbers")

; Test 17: Drop with rational numbers
(test-assert 
  (= (first (drop 2.0 (list 1 2 3 4))) 3)
  "drop should work with rational numbers that are integers")

; Test 18: Drop with prepend results
(define prepended-list (prepend 1 2 (list 3 4 5)))
(define prepend-dropped (drop 2 prepended-list))
(test-assert 
  (= (first prepend-dropped) 3)
  "drop should work with prepend results")

; Test 19: Drop with append results
(define appended-list (append (list 1 2) (list 3 4) (list 5 6)))
(define append-dropped (drop 3 appended-list))
(test-assert 
  (= (first append-dropped) 4)
  "drop should work with append results")

; Test 20: Drop performance with larger lists
(define large-list (iota 20))
(define large-dropped (drop 10 large-list))
(test-assert 
  (= (first large-dropped) 10)
  "drop should work efficiently with larger lists")

(test-assert 
  (= (length large-dropped) 10)
  "drop should maintain correct length with larger lists")

;------------------------------------------------------------------------------
; take tests

; Test 1: Basic take functionality
(define test-take-list (list 1 2 3 4 5))
(define taken-two (take 2 test-take-list))
(test-assert 
  (= (first taken-two) 1)
  "take should return first n elements - first")

(test-assert 
  (= (first (rest taken-two)) 2)
  "take should return first n elements - second")

(test-assert 
  (= (length taken-two) 2)
  "take should return list with correct length")

; Test 2: Take 0 elements should return empty list
(test-assert 
  (nil? (take 0 (list 10 20 30)))
  "take 0 should return empty list")

; Test 3: Take all elements
(define take-all-list (list 1 2 3))
(define taken-all (take 3 take-all-list))
(test-assert 
  (= (first taken-all) 1)
  "take all should preserve first element")

(test-assert 
  (= (length taken-all) 3)
  "take all should preserve list length")

; Test 4: Take more than list length
(define taken-excess (take 10 (list 1 2 3)))
(test-assert 
  (= (length taken-excess) 3)
  "take more than length should return full list")

(test-assert 
  (= (first taken-excess) 1)
  "take excess should preserve elements")

; Test 5: Take from empty list
(test-assert 
  (nil? (take 5 ()))
  "take from empty list should return empty list")

; Test 6: Take single element
(define single-take-list (list 42))
(test-assert 
  (= (first (take 1 single-take-list)) 42)
  "take 1 from single element should return that element")

(test-assert 
  (nil? (take 0 single-take-list))
  "take 0 from single element should return empty")

; Test 7: Take with different data types
(define mixed-take-list (list "hello" 42 true (list 1 2)))
(define mixed-taken (take 2 mixed-take-list))
(test-assert 
  (= (first mixed-taken) "hello")
  "take should work with mixed data types - first")

(test-assert 
  (= (first (rest mixed-taken)) 42)
  "take should work with mixed data types - second")

; Test 8: Take with library-generated lists
(define iota-take-list (iota 6))  ; (0 1 2 3 4 5)
(define iota-taken (take 3 iota-take-list))
(test-assert 
  (= (first iota-taken) 0)
  "take should work with iota-generated lists - first")

(test-assert 
  (= (first (rest (rest iota-taken))) 2)
  "take should work with iota-generated lists - third")

(test-assert 
  (= (length iota-taken) 3)
  "take should return correct length")

; Test 9: Take with filtered lists
(define even-take-list (filter even? (iota 10)))
(define even-taken (take 2 even-take-list))
(test-assert 
  (= (first even-taken) 0)
  "take should work with filtered lists - first")

(test-assert 
  (= (first (rest even-taken)) 2)
  "take should work with filtered lists - second")

; Test 10: Take with mapped lists
(define doubled-take-list (map (lambda (x) (* x 2)) (list 1 2 3 4)))
(define doubled-taken (take 2 doubled-take-list))
(test-assert 
  (= (first doubled-taken) 2)  ; 1*2
  "take should work with mapped lists - first")

(test-assert 
  (= (first (rest doubled-taken)) 4)  ; 2*2
  "take should work with mapped lists - second")

; Test 11: Take used with other functions
(define take-and-reverse (reverse (take 3 (list 1 2 3 4 5))))
(test-assert 
  (= (first take-and-reverse) 3)
  "take should compose with other functions")

(test-assert 
  (= (length take-and-reverse) 3)
  "take composition should preserve length")

; Test 12: Take with nested lists
(define nested-take-list (list (list 1 2) (list 3 4) (list 5 6)))
(define nested-taken (take 2 nested-take-list))
(test-assert 
  (= (first (first nested-taken)) 1)
  "take should work with nested lists - first list")

(test-assert 
  (= (first (first (rest nested-taken))) 3)
  "take should work with nested lists - second list")

; Test 13: Take with apply
(test-assert 
  (= (first (apply take (list 2 (list 10 20 30)))) 10)
  "take should work with apply")

; Test 14: Take in fold operations
(define take-fold-result 
  (foldl (lambda (acc n) (+ acc (length (take n (list 1 2 3 4 5))))) 
         0 
         (list 0 1 2 3)))
(test-assert 
  (= take-fold-result 6)  ; 0+1+2+3 = 6
  "take should work in fold operations")

; Test 15: Take with Church Boolean elements
(define bool-take-list (list true false (= 1 1) (= 1 2)))
(define bool-taken (take 2 bool-take-list))
(test-assert 
  (= ((first bool-taken) "true" "false") "true")
  "take should work with Church Boolean elements - first")

(test-assert 
  (= ((first (rest bool-taken)) "true" "false") "false")
  "take should work with Church Boolean elements - second")

; Test 16: Error conditions for take
(test-error (take) "take should require exactly 2 arguments")
(test-error (take 2) "take should require exactly 2 arguments")
(test-error (take 1 2 3) "take should require exactly 2 arguments")
(test-error (take "not-number" (list 1 2)) "take should reject non-numeric first argument")
(test-error (take 2 "not-list") "take should reject non-list second argument")
(test-error (take -1 (list 1 2)) "take should reject negative numbers")

; Test 17: Take with rational numbers
(test-assert 
  (= (length (take 2.0 (list 1 2 3 4))) 2)
  "take should work with rational numbers that are integers")

; Test 18: Take with prepend results
(define prepended-take-list (prepend 1 2 (list 3 4 5)))
(define prepend-taken (take 3 prepended-take-list))
(test-assert 
  (= (first prepend-taken) 1)
  "take should work with prepend results - first")

(test-assert 
  (= (first (rest (rest prepend-taken))) 3)
  "take should work with prepend results - third")

; Test 19: Take with append results
(define appended-take-list (append (list 1 2) (list 3 4) (list 5 6)))
(define append-taken (take 4 appended-take-list))
(test-assert 
  (= (first append-taken) 1)
  "take should work with append results - first")

(test-assert 
  (= (first (rest (rest (rest append-taken)))) 4)
  "take should work with append results - fourth")

; Test 20: Take performance with larger lists
(define large-take-list (iota 20))
(define large-taken (take 5 large-take-list))
(test-assert 
  (= (first large-taken) 0)
  "take should work efficiently with larger lists - first")

(test-assert 
  (= (first (rest (rest (rest (rest large-taken))))) 4)
  "take should work efficiently with larger lists - last")

(test-assert 
  (= (length large-taken) 5)
  "take should maintain correct length with larger lists")

;------------------------------------------------------------------------------
; drop/take complementary behavior tests

; Test 1: drop and take should be complementary
(define complement-list (list 1 2 3 4 5 6))
(define dropped-part (drop 2 complement-list))
(define taken-part (take 2 complement-list))
(define recombined (append taken-part dropped-part))

(test-assert 
  (= (first recombined) 1)
  "drop/take recombination should preserve original order - first")

(test-assert 
  (= (first (rest (rest recombined))) 3)
  "drop/take recombination should preserve original order - third")

(test-assert 
  (= (length recombined) (length complement-list))
  "drop/take recombination should preserve original length")

; Test 2: drop n + take n should cover whole list when n = length/2
(define even-length-list (list 10 20 30 40))
(define first-half (take 2 even-length-list))
(define second-half (drop 2 even-length-list))
(define rejoined (append first-half second-half))

(test-assert 
  (= (first rejoined) 10)
  "split/rejoin should work - first element")

(test-assert 
  (= (first (rest (rest (rest rejoined)))) 40)
  "split/rejoin should work - last element")

; Test 3: Edge case - drop 0 and take 0
(define edge-list (list 7 8 9))
(test-assert 
  (= (first (drop 0 edge-list)) 7)
  "drop 0 should be identity")

(test-assert 
  (nil? (take 0 edge-list))
  "take 0 should be empty")

; Test 4: Edge case - drop all and take all
(define all-test-list (list 1 2 3))
(test-assert 
  (nil? (drop 3 all-test-list))
  "drop all should be empty")

(test-assert 
  (= (length (take 3 all-test-list)) 3)
  "take all should preserve length")

; Test 5: Boundary behavior consistency
(define boundary-list (list 5 10 15))
(test-assert 
  (= (length (take 1 boundary-list)) 1)
  "take 1 should have length 1")

(test-assert 
  (= (length (drop 1 boundary-list)) 2)
  "drop 1 should leave length-1 elements")

; Test 6: Using drop/take for list slicing
(define slice-list (list 100 200 300 400 500))
(define middle-slice (take 2 (drop 1 slice-list)))  ; Elements 2-3 (200, 300)
(test-assert 
  (= (first middle-slice) 200)
  "list slicing with drop/take should work - first")

(test-assert 
  (= (first (rest middle-slice)) 300)
  "list slicing with drop/take should work - second")

(test-assert 
  (= (length middle-slice) 2)
  "list slicing should have correct length")

; Test 7: drop/take with iota for range operations
(define range-start-3-count-4 (take 4 (drop 3 (iota 10))))  ; Should be (3 4 5 6)
(test-assert 
  (= (first range-start-3-count-4) 3)
  "range simulation should work - first")

(test-assert 
  (= (first (rest (rest (rest range-start-3-count-4)))) 6)
  "range simulation should work - last")

; Test 8: Nested drop/take operations
(define nested-ops-list (list 1 2 3 4 5 6 7 8 9 10))
(define nested-result (take 2 (drop 1 (take 5 (drop 2 nested-ops-list)))))
(test-assert 
  (= (first nested-result) 4)  ; drop 2 -> (3 4 5 6 7 8 9 10), take 5 -> (3 4 5 6 7), drop 1 -> (4 5 6 7), take 2 -> (4 5)
  "nested drop/take operations should work")

; Test 9: drop/take with filter results
(define filtered-for-drop-take (filter odd? (iota 10)))  ; (1 3 5 7 9)
(define filtered-partial (take 3 (drop 1 filtered-for-drop-take)))  ; Should be (3 5 7)
(test-assert 
  (= (first filtered-partial) 3)
  "drop/take should work with filtered lists")

; Test 10: Performance comparison - large lists
(define perf-list (iota 100))
(define perf-dropped (drop 50 perf-list))
(define perf-taken (take 50 perf-list))

(test-assert 
  (= (first perf-dropped) 50)
  "drop should work efficiently on large lists")

(test-assert 
  (= (length perf-taken) 50)
  "take should work efficiently on large lists")

;------------------------------------------------------------------------------
; iota tests

; Test 1: Basic iota functionality
(define iota-three (iota 3))
(test-assert 
  (= (first iota-three) 0)
  "iota should start from 0 - first element")

(test-assert 
  (= (first (rest iota-three)) 1)
  "iota should increment by 1 - second element")

(test-assert 
  (= (first (rest (rest iota-three))) 2)
  "iota should continue sequence - third element")

; Test 2: iota 0 should return empty list
(test-assert 
  (nil? (iota 0))
  "iota 0 should return empty list")

; Test 3: iota 1 should return single element list
(define iota-one (iota 1))
(test-assert 
  (= (first iota-one) 0)
  "iota 1 should contain only 0")

(test-assert 
  (nil? (rest iota-one))
  "iota 1 should be single-element list")

; Test 4: iota with larger numbers
(define iota-five (iota 5))
(test-assert 
  (= (length iota-five) 5)
  "iota should generate correct number of elements")

(test-assert 
  (= (first iota-five) 0)
  "iota should start from 0 - larger list")

(test-assert 
  (= (first (rest (rest (rest (rest iota-five))))) 4)
  "iota should end at n-1 - larger list")

; Test 5: iota sequence correctness
(define iota-seven (iota 7))
(test-assert 
  (= (first (rest (rest iota-seven))) 2)
  "iota sequence should be correct - middle elements")

(test-assert 
  (= (first (rest (rest (rest (rest (rest (rest iota-seven))))))) 6)
  "iota sequence should be correct - last element")

; Test 6: iota works with other library functions
(test-assert 
  (= (length (iota 10)) 10)
  "iota should work with length function")

; Test 7: iota with map
(define doubled-iota (map (lambda (x) (* x 2)) (iota 4)))
(test-assert 
  (= (first doubled-iota) 0)  ; 0*2 = 0
  "iota should work with map - first element")

(test-assert 
  (= (first (rest (rest (rest doubled-iota)))) 6)  ; 3*2 = 6
  "iota should work with map - last element")

; Test 8: iota with filter
(define even-iota (filter even? (iota 6)))
(test-assert 
  (= (first even-iota) 0)
  "iota should work with filter - first even")

(test-assert 
  (= (first (rest even-iota)) 2)
  "iota should work with filter - second even")

; Test 9: iota with fold operations
(define sum-iota (foldl + 0 (iota 5)))
(test-assert 
  (= sum-iota 10)  ; 0+1+2+3+4 = 10
  "iota should work with fold operations")

; Test 10: iota with reverse
(define reversed-iota (reverse (iota 4)))
(test-assert 
  (= (first reversed-iota) 3)
  "iota should work with reverse - first element")

(test-assert 
  (= (first (rest (rest (rest reversed-iota)))) 0)
  "iota should work with reverse - last element")

; Test 11: iota error conditions
(test-error (iota) "iota should require exactly 1 argument")
(test-error (iota 5 extra) "iota should require exactly 1 argument")
(test-error (iota "not-number") "iota should reject non-numeric arguments")

; Test 12: iota with apply
(test-assert 
  (= (length (apply iota (list 8))) 8)
  "iota should work with apply")

;------------------------------------------------------------------------------
; any?/all? tests
(lndisplayln "any?/all? tests")

; any? tests
; Test 1: Basic any? with predicate that finds matching elements
(test-assert 
  (any? even? (list 1 3 4 5))
  "any? should return true when at least one element matches")

(test-assert 
  (any? odd? (list 2 4 6 7))
  "any? should return true when at least one element matches - odd case")

; Test 2: any? with no matching elements
(test-assert 
  (= (any? even? (list 1 3 5 7)) false)
  "any? should return false when no elements match")

(test-assert 
  (= (any? odd? (list 2 4 6 8)) false)
  "any? should return false when no elements match - even case")

; Test 3: any? with empty list
(test-assert 
  (= (any? even? ()) false)
  "any? should return false for empty list")

; Test 4: any? with all matching elements
(test-assert 
  (any? even? (list 2 4 6 8))
  "any? should return true when all elements match")

; Test 5: any? short-circuiting behavior
(define-mutable any-side-effect-counter 0)
(define counting-predicate-any
  (lambda* (x)
    (set! any-side-effect-counter (+ any-side-effect-counter 1))
    (even? x)))

(any? counting-predicate-any (list 2 4 6 8))  ; Should stop at first element
(test-assert 
  (= any-side-effect-counter 1)
  "any? should short-circuit and stop at first matching element")

; Test 6: any? with single element list - true case
(test-assert 
  (any? even? (list 4))
  "any? should work with single element list - matching case")

; Test 7: any? with single element list - false case
(test-assert 
  (= (any? even? (list 3)) false)
  "any? should work with single element list - non-matching case")

; Test 8: any? as Church Boolean
(test-assert 
  (= ((any? even? (list 1 2 3)) "found" "not-found") "found")
  "any? should work as Church Boolean - true case")

(test-assert 
  (= ((any? odd? (list 2 4 6)) "found" "not-found") "not-found")
  "any? should work as Church Boolean - false case")

; Test 9: any? with complex predicate
(define greater-than-five (lambda (x) (> x 5)))
(test-assert 
  (any? greater-than-five (list 1 2 7 3))
  "any? should work with complex predicates")

(test-assert 
  (= (any? greater-than-five (list 1 2 3 4)) false)
  "any? should work with complex predicates - false case")

; Test 10: any? with wrapped operatives
(define wrapped-equal-three (wrap (vau (x) env (= (eval x env) 3))))
(test-assert 
  (any? wrapped-equal-three (list 1 2 3 4))
  "any? should work with wrapped operatives")

; Test 11: any? with type predicates
(test-assert 
  (any? string? (list 1 "hello" 3))
  "any? should work with type predicates")

(test-assert 
  (= (any? number? (list "a" "b" "c")) false)
  "any? should work with type predicates - false case")

; Test 12: any? with library-generated lists
(test-assert 
  (any? even? (iota 5))  ; (0 1 2 3 4) - contains even numbers
  "any? should work with iota-generated lists")

; Test 13: any? error conditions
(test-error (any?) "any? should require exactly 2 arguments")
(test-error (any? even?) "any? should require exactly 2 arguments")
(test-error (any? even? (list 1 2) extra) "any? should require exactly 2 arguments")
(test-error (any? "not-function" (list 1 2)) "any? should reject non-function predicates")
(test-error (any? even? 42) "any? should reject non-list second argument")

;------------------------------------------------------------------------------
; all? tests

; Test 1: Basic all? with all matching elements
(test-assert 
  (all? even? (list 2 4 6 8))
  "all? should return true when all elements match")

(test-assert 
  (all? odd? (list 1 3 5 7))
  "all? should return true when all elements match - odd case")

; Test 2: all? with some non-matching elements
(test-assert 
  (= (all? even? (list 2 4 5 8)) false)
  "all? should return false when any element doesn't match")

(test-assert 
  (= (all? odd? (list 1 3 4 7)) false)
  "all? should return false when any element doesn't match - even case")

; Test 3: all? with empty list
(test-assert 
  (all? even? ())
  "all? should return true for empty list")

; Test 4: all? with no matching elements
(test-assert 
  (= (all? even? (list 1 3 5 7)) false)
  "all? should return false when no elements match")

; Test 5: all? short-circuiting behavior
(define-mutable all-side-effect-counter 0)
(define counting-predicate-all
  (lambda* (x)
    (set! all-side-effect-counter (+ all-side-effect-counter 1))
    (odd? x)))

(all? counting-predicate-all (list 1 2 3 5))  ; Should stop at second element (2)
(test-assert 
  (= all-side-effect-counter 2)
  "all? should short-circuit and stop at first non-matching element")

; Test 6: all? with single element list - true case
(test-assert 
  (all? even? (list 4))
  "all? should work with single element list - matching case")

; Test 7: all? with single element list - false case
(test-assert 
  (= (all? even? (list 3)) false)
  "all? should work with single element list - non-matching case")

; Test 8: all? as Church Boolean
(test-assert 
  (= ((all? even? (list 2 4 6)) "all-match" "some-fail") "all-match")
  "all? should work as Church Boolean - true case")

(test-assert 
  (= ((all? odd? (list 1 2 3)) "all-match" "some-fail") "some-fail")
  "all? should work as Church Boolean - false case")

; Test 9: all? with complex predicate
(define less-than-ten (lambda (x) (< x 10)))
(test-assert 
  (all? less-than-ten (list 1 5 8 9))
  "all? should work with complex predicates")

(test-assert 
  (= (all? less-than-ten (list 1 5 15 9)) false)
  "all? should work with complex predicates - false case")

; Test 10: all? with type predicates
(test-assert 
  (all? number? (list 1 2 3 4))
  "all? should work with type predicates")

(test-assert 
  (= (all? string? (list "a" "b" 3)) false)
  "all? should work with type predicates - false case")

; Test 11: all? with library-generated lists
(test-assert 
  (all? number? (iota 5))
  "all? should work with iota-generated lists")

(test-assert 
  (= (all? even? (iota 5)) false)  ; (0 1 2 3 4) - not all even
  "all? should work with iota-generated lists - false case")

; Test 12: all? error conditions
(test-error (all?) "all? should require exactly 2 arguments")
(test-error (all? even?) "all? should require exactly 2 arguments")
(test-error (all? even? (list 1 2) extra) "all? should require exactly 2 arguments")
(test-error (all? "not-function" (list 1 2)) "all? should reject non-function predicates")
(test-error (all? even? 42) "all? should reject non-list second argument")

;------------------------------------------------------------------------------
; any?/all? complementary behavior tests

; Test 1: Logical relationship between any? and all?
(define test-numbers (list 1 3 5 7))  ; All odd
(test-assert 
  (and (all? odd? test-numbers) (any? odd? test-numbers))
  "all? true should imply any? true")

(define mixed-numbers (list 1 2 3 4))  ; Mixed odd/even
(test-assert 
  (and (any? odd? mixed-numbers) 
       (any? even? mixed-numbers)
       (not (all? odd? mixed-numbers))
       (not (all? even? mixed-numbers)))
  "mixed list should have any? true and all? false for both predicates")

; Test 2: Empty list behavior consistency
(test-assert 
  (and (all? even? ()) 
       (not (any? even? ())))
  "empty list: all? should be true, any? should be false")

; Test 3: De Morgan's laws analog
(define some-evens (list 2 3 4))
(test-assert 
  (= (not (all? even? some-evens)) (any? odd? some-evens))
  "not(all even) should equal any odd")

; Test 4: Performance comparison - any? vs all? short-circuiting
(define-mutable perf-counter-any 0)
(define-mutable perf-counter-all 0)

(define counting-pred-any 
  (lambda* (x) 
    (set! perf-counter-any (+ perf-counter-any 1))
    (= x 3)))

(define counting-pred-all
  (lambda* (x)
    (set! perf-counter-all (+ perf-counter-all 1))
    (not (= x 3))))

; any? should find 3 at position 3 (1-indexed)
(any? counting-pred-any (list 1 2 3 4 5))
; all? should fail at position 3 (1-indexed)  
(all? counting-pred-all (list 1 2 3 4 5))

(test-assert 
  (= perf-counter-any 3)
  "any? should short-circuit correctly")

(test-assert 
  (= perf-counter-all 3)
  "all? should short-circuit correctly")

; Test 5: any?/all? with filter results
(define filtered-evens (filter even? (iota 10)))
(test-assert 
  (all? even? filtered-evens)
  "all? should work with filter results - all even")

(test-assert 
  (any? (lambda (x) (> x 5)) filtered-evens)
  "any? should work with filter results - some greater than 5")

; Test 6: any?/all? composition with other functions
(define lists-of-numbers (list (list 2 4 6) (list 1 3 5) (list 2 4 7)))
(define all-even-lists (filter (lambda (lst) (all? even? lst)) lists-of-numbers))
(test-assert 
  (= (length all-even-lists) 1)
  "all? should work in filter composition")

(define any-even-lists (filter (lambda (lst) (any? even? lst)) lists-of-numbers))
(test-assert 
  (= (length any-even-lists) 2)
  "any? should work in filter composition")

; Test 7: any?/all? with nested predicates
(define has-small-numbers (lambda (x) (< x 5)))
(define nested-test-list (list 1 2 10 3))

(test-assert 
  (and (any? has-small-numbers nested-test-list)
       (not (all? has-small-numbers nested-test-list)))
  "any?/all? should work with custom predicates on mixed data")

; Test 8: any?/all? with Church Boolean predicates
(define church-bool-pred (lambda (x) (= x 42)))  ; Returns Church Boolean
(test-assert 
  (= ((any? church-bool-pred (list 1 42 3)) "found" "missing") "found")
  "any? should work with Church Boolean returning predicates")

(test-assert 
  (= ((all? church-bool-pred (list 42 42 42)) "all-match" "some-different") "all-match")
  "all? should work with Church Boolean returning predicates")

; Test 9: any?/all? used in fold operations
(define check-lists (list (list 2 4 6) (list 1 3 5) (list 2 4 8)))
(define count-all-even-lists 
  (foldl (lambda (acc lst) ((all? even? lst) (+ acc 1) acc)) 0 check-lists))
(test-assert 
  (= count-all-even-lists 2)
  "all? should work in fold operations")

; Test 10: any?/all? with apply
(test-assert 
  (= ((apply any? (list even? (list 1 2 3))) "yes" "no") "yes")
  "any? should work with apply")

(test-assert 
  (= ((apply all? (list odd? (list 1 3 5))) "yes" "no") "yes")
  "all? should work with apply")

;------------------------------------------------------------------------------
; Cond tests
(lndisplayln "cond/when/unless tests")

; Test 1: Basic cond with true first condition
(test-assert 
  (= (cond ((= 1 1) 42))
     42)
  "cond should return value when first condition is true")

; Test 2: Basic cond with false first condition, true second
(test-assert
  (= (cond ((= 1 2) 10)
           ((= 2 2) 20))
     20)
  "cond should skip false conditions and return first true")

; Test 3: Multiple conditions, second one true
(test-assert
  (= (cond ((= 5 6) 100)
           ((= 3 3) 200)
           ((= 7 7) 300))
     200)
  "cond should return first true condition, not evaluate later ones")

; Test 4: No true conditions - should return nil
(test-assert
  (nil? (cond ((= 1 2) 10)
              ((= 3 4) 20)))
  "cond should return nil when no conditions are true")

; Test 5: Empty cond - should return nil
(test-assert 
  (nil? (cond))
  "cond with no clauses should return nil")

; Test 6: Complex expressions in conditions and results
(test-assert
  (= (cond ((= (+ 1 2) 4) (* 2 3))
           ((= (* 2 2) 4) (+ 10 5)))
     15)
  "cond should handle complex expressions in both test and result")

; Test 7: Side effects should only occur for evaluated branches
(define-mutable test-counter 0)
(define increment-counter (lambda () (set! test-counter (+ test-counter 1))))
(cond ((= 1 1) (increment-counter))
      ((= 2 2) (increment-counter)))
(test-assert 
  (= test-counter 1)
  "cond should only evaluate the first true branch")

; Test 8: Using Church Booleans directly
(test-assert 
  (= (cond (true "correct") 
           (false "wrong")) 
     "correct")
  "cond should work with Church Boolean values")

; Test 9: Variable references in conditions
(define x 5)
(define y 10)
(test-assert
  (= (cond ((= x 3) "no")
           ((= y 10) "yes")
           ((= x 5) "maybe"))
     "yes")
  "cond should work with variable references")

; Test 10: Nested cond expressions
(define nested-result 
  (cond ((= 1 2) "outer-false")
        ((= 2 2) (cond ((= 3 4) "inner-false")
                       ((= 5 5) "inner-true")))))
(test-assert 
  (= nested-result "inner-true")
  "cond should work when nested inside other cond expressions")

; Test 11: Short-circuit evaluation - later conditions shouldn't be evaluated
(define side-effect-var 0)
(define make-side-effect 
  (lambda () (define side-effect-var (+ side-effect-var 1))))
(cond ((= 1 1) "found")
      ((make-side-effect) "should not reach here"))
(test-assert 
  (= side-effect-var 0)
  "cond should not evaluate conditions after finding a true one")

; Test 12: Using cond with wrapped functions
(define wrapped-equal (wrap =))
(test-assert 
  (= (cond ((wrapped-equal 1 2) "no") ((wrapped-equal 3 3) "yes")) "yes")
  "cond should work with wrapped operatives")

; Test 13: Return values can be any type
(define string-result (cond ((= 1 2) 42) ((= 2 2) "string")))
(define number-result (cond ((= 1 1) 99) ((= 2 2) "string")))
(test-assert 
  (= string-result "string")
  "cond should return string values correctly")
(test-assert 
  (= number-result 99)
  "cond should return number values correctly")

; Test 14: Single clause cond
(test-assert 
  (= (cond ((= 7 7) "single")) "single")
  "cond with single true clause should work")

(test-assert 
  (nil? (cond ((= 7 8) "single")))
  "cond with single false clause should return nil")

; Test 15: Complex realistic example
(define classify-number
  (lambda (n)
    (cond ((= n 0) "zero")
          ((= n 1) "one") 
          ((= n 2) "two")
          ((nil? ()) "other"))))  ; Always true as fallback

(test-assert 
  (= (classify-number 0) "zero")
  "cond classifier should work for zero")

(test-assert 
  (= (classify-number 1) "one")
  "cond classifier should work for one")

(test-assert 
  (= (classify-number 99) "other")
  "cond classifier should work for default case")

;------------------------------------------------------------------------------
; when/unless tests

; Test 1: Basic when with true condition
(define-mutable when-test-var 0)
(when (= 1 1)
  (set! when-test-var 42))
(test-assert 
  (= when-test-var 42)
  "when should execute body when condition is true")

; Test 2: when with false condition should not execute body
(define-mutable when-false-var 0)
(when (= 1 2)
  (set! when-false-var 99))
(test-assert 
  (= when-false-var 0)
  "when should not execute body when condition is false")

; Test 3: when with multiple body expressions
(define-mutable when-multi-var1 0)
(define-mutable when-multi-var2 0)
(when (= 2 2)
  (set! when-multi-var1 10)
  (set! when-multi-var2 20)
  (set! when-multi-var1 (+ when-multi-var1 5)))
(test-assert 
  (= when-multi-var1 15)
  "when should execute all body expressions - first variable")

(test-assert 
  (= when-multi-var2 20)
  "when should execute all body expressions - second variable")

; Test 4: when return value with true condition
(define when-return-true (when (= 3 3) "executed"))
(test-assert 
  (= when-return-true "executed")
  "when should return value of last body expression when condition is true")

; Test 5: when return value with false condition
(define when-return-false (when (= 3 4) "not-executed"))
(test-assert 
  (nil? when-return-false)
  "when should return nil when condition is false")

; Test 6: when with complex condition
(define when-complex-result
  (when (and (= 1 1) (not (= 2 3)))
    "complex-condition-true"))
(test-assert 
  (= when-complex-result "complex-condition-true")
  "when should work with complex conditions")

; Test 7: when with Church Boolean condition
(define church-bool-true (= 5 5))
(define-mutable church-when-var 0)
(when church-bool-true
  (set! church-when-var 777))
(test-assert 
  (= church-when-var 777)
  "when should work with Church Boolean conditions")

; Test 8: when with variable reference condition
(define test-condition true)
(define-mutable var-cond-result 0)
(when test-condition
  (set! var-cond-result 123))
(test-assert 
  (= var-cond-result 123)
  "when should work with variable reference conditions")

; Test 9: when should not evaluate body on false (side effect test)
(define-mutable side-effect-counter 0)
(define increment-counter (lambda () (set! side-effect-counter (+ side-effect-counter 1))))
(when false
  (increment-counter)
  (increment-counter))
(test-assert 
  (= side-effect-counter 0)
  "when should not evaluate body expressions when condition is false")

; Test 10: Nested when expressions
(define-mutable nested-when-var 0)
(when (= 1 1)
  (when (= 2 2)
    (set! nested-when-var 50)))
(test-assert 
  (= nested-when-var 50)
  "nested when expressions should work")

; Test 11: when with library functions in condition
(define when-lib-result
  (when (even? 4)
    "four-is-even"))
(test-assert 
  (= when-lib-result "four-is-even")
  "when should work with library function conditions")

; Test 12: when with no body expressions
(define when-no-body (when (= 1 1)))
(test-assert 
  (nil? when-no-body)
  "when with no body should return nil")

; Test 13: when with computed condition
(define computed-when-result
  (when (= (+ 2 3) (+ (* 2 2 1 1) 1))
    "computed-match"))
(test-assert 
  (= computed-when-result "computed-match")
  "when should work with computed conditions")

;------------------------------------------------------------------------------
; unless tests

; Test 1: Basic unless with false condition
(define-mutable unless-test-var 0)
(unless (= 1 2)
  (set! unless-test-var 42))
(test-assert 
  (= unless-test-var 42)
  "unless should execute body when condition is false")

; Test 2: unless with true condition should not execute body
(define-mutable unless-true-var 0)
(unless (= 1 1)
  (set! unless-true-var 99))
(test-assert 
  (= unless-true-var 0)
  "unless should not execute body when condition is true")

; Test 3: unless with multiple body expressions
(define-mutable unless-multi-var1 0)
(define-mutable unless-multi-var2 0)
(unless (= 2 3)
  (set! unless-multi-var1 30)
  (set! unless-multi-var2 40)
  (set! unless-multi-var1 (+ unless-multi-var1 5)))
(test-assert 
  (= unless-multi-var1 35)
  "unless should execute all body expressions - first variable")

(test-assert 
  (= unless-multi-var2 40)
  "unless should execute all body expressions - second variable")

; Test 4: unless return value with false condition
(define unless-return-false (unless (= 3 4) "executed"))
(test-assert 
  (= unless-return-false "executed")
  "unless should return value of last body expression when condition is false")

; Test 5: unless return value with true condition
(define unless-return-true (unless (= 3 3) "not-executed"))
(test-assert 
  (nil? unless-return-true)
  "unless should return nil when condition is true")

; Test 6: unless with complex condition
(define unless-complex-result
  (unless (or (= 1 2) (= 3 4))
    "complex-condition-false"))
(test-assert 
  (= unless-complex-result "complex-condition-false")
  "unless should work with complex conditions")

; Test 7: unless with Church Boolean condition
(define church-bool-false (= 5 6))
(define-mutable church-unless-var 0)
(unless church-bool-false
  (set! church-unless-var 888))
(test-assert 
  (= church-unless-var 888)
  "unless should work with Church Boolean conditions")

; Test 8: unless with variable reference condition
(define false-condition false)
(define-mutable unless-var-cond-result 0)
(unless false-condition
  (set! unless-var-cond-result 456))
(test-assert 
  (= unless-var-cond-result 456)
  "unless should work with variable reference conditions")

; Test 9: unless should not evaluate body on true (side effect test)
(define-mutable unless-side-effect-counter 0)
(define unless-increment-counter (lambda () (set! unless-side-effect-counter (+ unless-side-effect-counter 1))))
(unless true
  (unless-increment-counter)
  (unless-increment-counter))
(test-assert 
  (= unless-side-effect-counter 0)
  "unless should not evaluate body expressions when condition is true")

; Test 10: Nested unless expressions
(define-mutable nested-unless-var 0)
(unless (= 1 2)
  (unless (= 3 4)
    (set! nested-unless-var 75)))
(test-assert 
  (= nested-unless-var 75)
  "nested unless expressions should work")

; Test 11: unless with library functions in condition
(define unless-lib-result
  (unless (odd? 4)
    "four-is-not-odd"))
(test-assert 
  (= unless-lib-result "four-is-not-odd")
  "unless should work with library function conditions")

; Test 12: unless with no body expressions
(define unless-no-body (unless (= 1 2)))
(test-assert 
  (nil? unless-no-body)
  "unless with no body should return nil")

; Test 13: unless with computed condition
(define computed-unless-result
  (unless (= (+ 2 3) (* 3 3))
    "computed-no-match"))
(test-assert 
  (= computed-unless-result "computed-no-match")
  "unless should work with computed conditions")

;------------------------------------------------------------------------------
; when/unless complementary behavior tests

; Test 1: when and unless should be opposites
(define-mutable complementary-var1 0)
(define-mutable complementary-var2 0)
(define test-bool (= 7 7))

(when test-bool (set! complementary-var1 100))
(unless test-bool (set! complementary-var2 200))

(test-assert 
  (= complementary-var1 100)
  "when should execute when condition is true")

(test-assert 
  (= complementary-var2 0)
  "unless should not execute when condition is true")

; Test 2: when and unless with false condition
(define-mutable complementary-var3 0)
(define-mutable complementary-var4 0)
(define false-bool (= 7 8))

(when false-bool (set! complementary-var3 300))
(unless false-bool (set! complementary-var4 400))

(test-assert 
  (= complementary-var3 0)
  "when should not execute when condition is false")

(test-assert 
  (= complementary-var4 400)
  "unless should execute when condition is false")

; Test 3: when/unless with same condition and opposite effects
(define test-when-unless-condition (even? 6))
(define when-result (when test-when-unless-condition "when-executed"))
(define unless-result (unless test-when-unless-condition "unless-executed"))

(test-assert 
  (= when-result "when-executed")
  "when should execute for true condition")

(test-assert 
  (nil? unless-result)
  "unless should not execute for true condition")

; Test 4: Complex mixed usage
(define-mutable mixed-result 0)
(let ((x 10) (y 5))
  (when (> x y)
    (set! mixed-result (+ mixed-result 1)))
  (unless (< x y) 
    (set! mixed-result (+ mixed-result 2)))
  (when (= x 10)
    (set! mixed-result (+ mixed-result 4)))
  (unless (= y 10)
    (set! mixed-result (+ mixed-result 8))))

(test-assert 
  (= mixed-result 15)  ; 1 + 2 + 4 + 8 = 15
  "when and unless should work together in complex scenarios")

; Test 5: when/unless error conditions - both need at least one argument
(test-error (when) "when should require at least 1 argument")
(test-error (unless) "unless should require at least 1 argument")

; Test 6: when/unless with try blocks
(define-mutable try-when-var 0)
(try (when (= 1 1)
       (set! try-when-var 999)
       (rest "this will fail"))
     (lambda* (error) 
       (set! try-when-var 0)))

(test-assert 
  (= try-when-var 0)
  "when should work with try blocks and error handling")

; Test 7: when/unless evaluation order
(define-mutable eval-order-test 0)
(define side-effect-true 
  (lambda* () 
    (set! eval-order-test 1)
    true))

(when (side-effect-true)
  (set! eval-order-test (+ eval-order-test 10)))

(test-assert 
  (= eval-order-test 11)
  "when should evaluate condition before body")

; Test 8: unless evaluation order
(define-mutable unless-eval-order-test 0)
(define side-effect-false
  (lambda* ()
    (set! unless-eval-order-test 2)
    false))

(unless (side-effect-false)
  (set! unless-eval-order-test (+ unless-eval-order-test 20)))

(test-assert 
  (= unless-eval-order-test 22)
  "unless should evaluate condition before body")

; Test 9: when/unless with mutable variables
(define-mutable mutable-condition true)
(define-mutable mutable-result 0)

(when mutable-condition
  (set! mutable-result 100))
(set! mutable-condition false)
(unless mutable-condition  
  (set! mutable-result (+ mutable-result 50)))

(test-assert 
  (= mutable-result 150)
  "when/unless should work with mutable variables")

; Test 10: Short-circuiting behavior verification
(define-mutable short-circuit-test 0)
(define failing-operation
  (lambda* ()
    (set! short-circuit-test 999)
    (rest "this should not be called")))

; This should not call failing-operation
(when false
  (failing-operation))

(unless true
  (failing-operation))

(test-assert 
  (= short-circuit-test 0)
  "when/unless should short-circuit and not evaluate body on opposite conditions")

;------------------------------------------------------------------------------
; and/or/not tests
(lndisplayln "and/or/not tests")

(test-assert (and) "(and) should return true")
(test-assert (and true) "(and true) should return true")
(test-assert (not (and false)) "(and false) should return false") 
(test-assert (and true true true)
  "(and true true true) should return true")
(test-assert (not (and false false false)) 
  "(and false false false) should return false")
(test-assert (not (and true false true))
  "(and true false true) should return false")

(define-mutable boolean-test-int 0)
(define boolean-test-set! (lambda* (n) (set! boolean-test-int n) true))

(and false (boolean-test-set! 1))
(test-assert (= 0 boolean-test-int)
  "and should short-circuit")

(test-assert (not (or))
  "(or) should return false")
(test-assert (or true) "(or true) should return true")
(test-assert (not (or false)) "(or false) should return false")
(test-assert (or true true true)
  "(or true true true) should return true")
(test-assert (not (or false false false))
  "(or false false false) shoud return false")
(test-assert (or false true false)
  "(or false true false) should return true")

(set! boolean-test-int 0)
(or true (boolean-test-int 1))
(test-assert (= 0 boolean-test-int)
  "or should short-circuit")

(test-assert (not (not true))
  "(not true) should return false")
(test-assert (not false)
  "(not false) should return true")

; Nested operations
(test-assert (and (or true false) (not false))
  "nested boolean operations should work")
(test-assert (or (and false true) (not false))
  "complex nested operations should work")

; Test with Church Boolean expressions
(test-assert (and (= 1 1) (nil? ()))
  "and should work with Church Boolean expressions")
(test-assert (or (= 1 2) (= 2 2))
  "or should work with Church Boolean expressions")
(test-assert (not (= 1 2))
  "not should work with Church Boolean expressions")

; Many arguments
(test-assert (and true true true true true true)
  "and should handle many true arguments")
(test-assert (not (and true true false true true))
  "and should handle false anywhere in many arguments")

;------------------------------------------------------------------------------
; Error condition tests (now that we have try/test-error)
(lndisplayln "misc error condition tests")

; Test arithmetic errors
(test-error (+ 1 "hello") "arithmetic operations should reject non-numeric arguments")
(test-error (- "world" 5) "subtraction should reject string arguments")
(test-error (* true 3) "multiplication should reject boolean arguments")
(test-error (/ 10 "two") "division should reject non-numeric arguments")

; Test list operation errors  
(test-error (first 42) "first should reject non-list arguments")
(test-error (rest "hello") "rest should reject non-list arguments")
(test-error (cons) "cons should require exactly 2 arguments")
(test-error (cons 1) "cons should require exactly 2 arguments") 
(test-error (cons 1 2 3) "cons should require exactly 2 arguments")

; Test undefined variable errors
(test-error undefined-variable-name "accessing undefined variables should throw")
(test-error (+ undefined-var 5) "undefined variables in expressions should throw")

; Test eval errors
(test-error (eval) "eval should require exactly 2 arguments")
(test-error (eval 42) "eval should require exactly 2 arguments")
(test-error (eval 1 2 3) "eval should require exactly 2 arguments")
(test-error (eval 42 "not-env") "eval should reject non-environment second argument")

; Test vau parameter errors
(test-error (vau) "vau should require exactly 3 arguments")
(test-error (vau (x)) "vau should require exactly 3 arguments")
(test-error (vau (x) env) "vau should require exactly 3 arguments")
(test-error (vau "not-list" env body) "vau should reject non-list parameter list")
(test-error (vau (123) env body) "vau should reject non-symbol parameters")

; Test define errors
(test-error (define) "define should require exactly 2 arguments")
(test-error (define x) "define should require exactly 2 arguments")
(test-error (define x 1 2) "define should require exactly 2 arguments")
(test-error (define 123 "value") "define should reject non-symbol names")
(test-error (define "string" 42) "define should reject string names")

; Test define-mutable errors
(test-error (define-mutable) "define-mutable should require exactly 2 arguments")
(test-error (define-mutable x) "define-mutable should require exactly 2 arguments") 
(test-error (define-mutable 42 "value") "define-mutable should reject non-symbol names")

; Test set! errors
(test-error (set!) "set! should require exactly 2 arguments")
(test-error (set! x) "set! should require exactly 2 arguments")
(test-error (set! "string" 42) "set! should reject non-symbol names")
(test-error (set! 123 "value") "set! should reject numeric names")

; Test set! on immutable bindings
(define immutable-var 42)
(test-error (set! immutable-var 99) "set! should reject immutable bindings")

; Test set! on undefined variables
(test-error (set! completely-undefined 123) "set! should reject undefined variables")

; Test wrap errors
(test-error (wrap) "wrap should require exactly 1 argument")
(test-error (wrap +  *) "wrap should require exactly 1 argument")
(test-error (wrap 42) "wrap should reject non-operative arguments")
(test-error (wrap "string") "wrap should reject non-operative arguments")

; Test invoke errors  
(test-error (invoke) "invoke should require at least 1 argument")
(test-error (invoke 42 (list 1 2)) "invoke should reject non-operative first argument")
(test-error (invoke + "not-list") "invoke should reject non-list second argument")

; Test comparison operator edge cases
(test-error (=) "= should require at least 2 arguments")
(test-error (= 1) "= should require at least 2 arguments")

; Test Church Boolean edge cases - operatives called as values
(test-error (42 "true-branch" "false-branch") "integers are not operatives")
(test-error ("hello" 1 2) "strings are not operatives")
(test-error (() 1 2) "nil is not an operative")

;------------------------------------------------------------------------------
; Environment isolation tests
(lndisplayln "environment isolation tests")

#skip
; I'm not sure about this one.
; We could have `try` introduce a new environment.
; But maybe we should leave that up to the user.
; (Especially once we've implemented let.)

; Test that errors don't corrupt environment
(define test-env-var 100)
(try (do (define test-env-var 200)  ; This should fail...
         (rest "invalid"))          ; ...before this error
     (lambda* (error) "caught"))
; The original binding should be preserved
(test-assert 
  (= test-env-var 100)
  "exceptions should not corrupt environment bindings")
#end

; Test exception in environment parameter usage
(define env-error-vau (vau (expr) env (eval expr "not-an-env")))
(test-error (env-error-vau (+ 1 2)) "invalid environment usage should throw")

;------------------------------------------------------------------------------
; let tests
(lndisplayln "let tests")

; Test 1: Basic let with single binding
(test-assert 
  (= (let ((x 10)) x) 10)
  "let should work with single binding")

; Test 2: let with multiple bindings
(test-assert 
  (= (let ((x 5) (y 3)) (+ x y)) 8)
  "let should work with multiple bindings")

; Test 3: let with no bindings (should work like immediate lambda invocation)
(test-assert 
  (= (let () 42) 42)
  "let with empty bindings should work")

; Test 4: let bindings shadow outer variables
(define outer-let-var 100)
(test-assert 
  (= (let ((outer-let-var 20)) outer-let-var) 20)
  "let bindings should shadow outer variables")

(test-assert 
  (= outer-let-var 100)
  "let should not affect outer variable bindings")

; Test 5: let with complex expressions in bindings
(test-assert 
  (= (let ((a (+ 2 3)) (b (* 4 5))) (+ a b)) 25)
  "let should evaluate complex expressions in bindings")

; Test 6: let with multiple body expressions (since let uses lambda*)
(define-mutable let-side-effect 0)
(define let-result 
  (let ((x 10))
    (set! let-side-effect 1)
    (set! let-side-effect (+ let-side-effect x))
    (* x 2)))
(test-assert 
  (= let-result 20)
  "let should return value of last expression")

(test-assert 
  (= let-side-effect 11)
  "let should execute all body expressions for side effects")

; Test 7: Nested let expressions
(test-assert 
  (= (let ((x 5))
       (let ((y 3))
         (+ x y))) 8)
  "nested let expressions should work")

; Test 8: let with variable references in bindings (bindings are evaluated in outer scope)
(define let-outer-var 15)
(test-assert 
  (= (let ((x let-outer-var) (y 5)) (+ x y)) 20)
  "let bindings should access outer scope variables")

; Test 9: let bindings don't see each other (parallel binding)
(define let-base-var 10)
(test-assert 
  (= (let ((x let-base-var) (y let-base-var)) (+ x y)) 20)
  "let bindings should be evaluated independently")

; Test 10: let with conditional expressions
(test-assert 
  (= (let ((test-val 5))
       (if (= test-val 5) 
           "correct"
           "wrong")) "correct")
  "let should work with conditionals")

; Test 11: let used in function definitions
(define make-adder-with-let 
  (lambda (base)
    (lambda (x)
      (let ((adjusted-base (+ base 1)))
        (+ x adjusted-base)))))
(define add-with-six (make-adder-with-let 5))
(test-assert 
  (= (add-with-six 10) 16)  ; 10 + (5+1) = 16
  "let should work inside lambda definitions")

; Test 12: let with library functions
(test-assert 
  (= (let ((nums (list 1 2 3)))
       (first nums)) 1)
  "let should work with library functions")

; Test 13: let with mutable variables in body
(define-mutable let-mutable-test 0)
(let ((increment 5))
  (set! let-mutable-test increment)
  (set! let-mutable-test (+ let-mutable-test increment)))
(test-assert 
  (= let-mutable-test 10)
  "let should work with mutable variable operations")

; Test 14: let with recursive pattern (using library functions)
(test-assert 
  (= (let ((double-list (lambda (lst) (map (lambda (x) (* x 2)) lst))))
       (first (double-list (list 3 4 5)))) 6)
  "let should work with higher-order function patterns")

; Test 15: let with Church Boolean results
(define let-boolean-result 
  (let ((x 1) (y 1))
    (= x y)))  ; This returns a Church Boolean
; We can't test Church Booleans with = directly, so test their behavior
(test-assert 
  (= (let ((test-bool (let ((a 2) (b 2)) (= a b))))
       (test-bool 42 99)) 42)
  "let should work with Church Boolean expressions")

; Test 16: Complex let example with multiple concepts
(define complex-let-result
  (let ((items (list 10 20 30))
        (multiplier 3))
    (define doubled (map (lambda (x) (* x 2)) items))
    (define first-doubled (first doubled))
    (* first-doubled multiplier)))
(test-assert 
  (= complex-let-result 60)  ; (10*2)*3 = 60
  "let should work in complex scenarios with multiple operations")

; Test 17: let with string bindings
(test-assert 
  (= (let ((greeting "hello") (name "world"))
       greeting) "hello")
  "let should work with string bindings")

; Test 18: let with immediate computation and side effects
(define-mutable let-immediate-effect 0)
(let ((side-effect-val (do (set! let-immediate-effect 42) 10)))
  (set! let-immediate-effect (+ let-immediate-effect side-effect-val)))
(test-assert 
  (= let-immediate-effect 52)  ; 42 + 10
  "let bindings should evaluate expressions with side effects immediately")

; Test 19: let error conditions - malformed binding lists
(test-error (let "not-a-list" body) "let should reject non-list binding forms")
(test-error (let ((x)) x) "let should reject incomplete bindings")
#skip
; Need to enhance the let implementation to validate bindings
(test-error (let ((x 1 2)) x) "let should reject malformed bindings")
#end

; Test 20: let with wrapped operatives
(define let-wrapped-op (wrap +))
(test-assert 
  (= (let ((op let-wrapped-op) (a 5) (b 7))
       (op a b)) 12)
  "let should work with wrapped operatives")

;------------------------------------------------------------------------------
; even? tests
(lndisplayln "even?/odd? tests")

; Test 1: Basic even number tests
(test-assert 
  (= (even? 0) true)
  "0 should be even")

(test-assert 
  (= (even? 2) true)
  "2 should be even")

(test-assert 
  (= (even? 4) true)
  "4 should be even")

; Test 2: Basic odd number tests
(test-assert 
  (= (even? 1) false)
  "1 should not be even")

(test-assert 
  (= (even? 3) false)
  "3 should not be even")

(test-assert 
  (= (even? 5) false)
  "5 should not be even")

; Test 3: Larger even numbers
(test-assert 
  (= (even? 100) true)
  "100 should be even")

(test-assert 
  (= (even? 1000) true)
  "1000 should be even")

; Test 4: Larger odd numbers
(test-assert 
  (= (even? 99) false)
  "99 should not be even")

(test-assert 
  (= (even? 1001) false)
  "1001 should not be even")

; Test 5: even? as Church Boolean
(test-assert 
  (= ((even? 6) "yes" "no") "yes")
  "even? should work as Church Boolean - even case")

(test-assert 
  (= ((even? 7) "yes" "no") "no")
  "even? should work as Church Boolean - odd case")

; Test 6: even? with library functions
(define evens-from-iota (filter even? (iota 6)))
(test-assert 
  (= (length evens-from-iota) 3)  ; 0, 2, 4
  "even? should work with filter")

; Test 7: even? with map
(define evenness-map (map even? (list 1 2 3 4)))
; Test the Church Boolean results
(test-assert 
  (= ((first evenness-map) "even" "odd") "odd")  ; 1 is odd
  "even? should work with map - first result")

(test-assert 
  (= ((first (rest evenness-map)) "even" "odd") "even")  ; 2 is even
  "even? should work with map - second result")

; Test 8: even? error conditions
(test-error (even?) "even? should require exactly 1 argument")
(test-error (even? 2 4) "even? should require exactly 1 argument")
(test-error (even? "not-number") "even? should reject non-numeric arguments")

; Test 9: even? with apply
(test-assert 
  (= ((apply even? (list 8)) "yes" "no") "yes")
  "even? should work with apply")

;------------------------------------------------------------------------------
; odd? tests

; Test 1: Basic odd number tests
(test-assert 
  (= (odd? 1) true)
  "1 should be odd")

(test-assert 
  (= (odd? 3) true)
  "3 should be odd")

(test-assert 
  (= (odd? 5) true)
  "5 should be odd")

; Test 2: Basic even number tests (should be false)
(test-assert 
  (= (odd? 0) false)
  "0 should not be odd")

(test-assert 
  (= (odd? 2) false)
  "2 should not be odd")

(test-assert 
  (= (odd? 4) false)
  "4 should not be odd")

; Test 3: Larger odd numbers
(test-assert 
  (= (odd? 99) true)
  "99 should be odd")

(test-assert 
  (= (odd? 1001) true)
  "1001 should be odd")

; Test 4: Larger even numbers (should be false)
(test-assert 
  (= (odd? 100) false)
  "100 should not be odd")

(test-assert 
  (= (odd? 1000) false)
  "1000 should not be odd")

; Test 5: odd? as Church Boolean
(test-assert 
  (= ((odd? 7) "yes" "no") "yes")
  "odd? should work as Church Boolean - odd case")

(test-assert 
  (= ((odd? 8) "yes" "no") "no")
  "odd? should work as Church Boolean - even case")

; Test 6: odd? with library functions
(define odds-from-iota (filter odd? (iota 6)))
(test-assert 
  (= (length odds-from-iota) 3)  ; 1, 3, 5
  "odd? should work with filter")

(test-assert 
  (= (first odds-from-iota) 1)
  "odd? filter should find correct odd numbers - first")

(test-assert 
  (= (first (rest (rest odds-from-iota))) 5)
  "odd? filter should find correct odd numbers - last")

; Test 7: odd? with map
(define oddness-map (map odd? (list 1 2 3 4)))
; Test the Church Boolean results
(test-assert 
  (= ((first oddness-map) "odd" "even") "odd")  ; 1 is odd
  "odd? should work with map - first result")

(test-assert 
  (= ((first (rest oddness-map)) "odd" "even") "even")  ; 2 is even
  "odd? should work with map - second result")

; Test 8: Consistency with even? - they should be opposites
(test-assert 
  (= (odd? 42) (not (even? 42)))
  "odd? should be opposite of even? for even numbers")

(test-assert 
  (= (odd? 43) (not (even? 43)))
  "odd? should be opposite of even? for odd numbers")

; Test 9: odd? error conditions
(test-error (odd?) "odd? should require exactly 1 argument")
(test-error (odd? 3 5) "odd? should require exactly 1 argument")
(test-error (odd? "not-number") "odd? should reject non-numeric arguments")

; Test 10: odd? with apply
(test-assert 
  (= ((apply odd? (list 9)) "yes" "no") "yes")
  "odd? should work with apply")

; Test 11: Complementary behavior of even? and odd?
(define test-numbers (iota 10))
(define evens (filter even? test-numbers))
(define odds (filter odd? test-numbers))
(test-assert 
  (= (+ (length evens) (length odds)) 10)
  "even? and odd? should partition all numbers")

; Test 12: odd? with fold operations
(define count-odds (foldl (lambda (acc n) ((odd? n) (+ acc 1) acc)) 0 (iota 7)))
(test-assert 
  (= count-odds 3)  ; 1, 3, 5 are odd in (0 1 2 3 4 5 6)
  "odd? should work in fold operations")

;------------------------------------------------------------------------------
; <=> (spaceship operator) tests
(lndisplayln "<=>/!=/</>/<=/>= tests")

; Test 1: Basic spaceship operator functionality
(test-assert 
  (= (<=> 1 2) -1)
  "<=> should return -1 when first argument is less than second")

(test-assert 
  (= (<=> 5 5) 0)
  "<=> should return 0 when arguments are equal")

(test-assert 
  (= (<=> 10 3) 1)
  "<=> should return 1 when first argument is greater than second")

; Test 2: Spaceship with zero
(test-assert 
  (= (<=> 0 1) -1)
  "<=> should work with zero - less than")

(test-assert 
  (= (<=> 0 0) 0)
  "<=> should work with zero - equal")

(test-assert 
  (= (<=> 1 0) 1)
  "<=> should work with zero - greater than")

; Test 3: Spaceship with negative numbers
(test-assert 
  (= (<=> -5 -3) -1)
  "<=> should work with negative numbers - less than")

(test-assert 
  (= (<=> -7 -7) 0)
  "<=> should work with negative numbers - equal")

(test-assert 
  (= (<=> -2 -8) 1)
  "<=> should work with negative numbers - greater than")

; Test 4: Spaceship with mixed positive/negative
(test-assert 
  (= (<=> -5 3) -1)
  "<=> should work with negative vs positive - less than")

(test-assert 
  (= (<=> 5 -3) 1)
  "<=> should work with positive vs negative - greater than")

; Test 5: Spaceship with larger numbers
(test-assert 
  (= (<=> 1000 2000) -1)
  "<=> should work with large numbers - less than")

(test-assert 
  (= (<=> 9999 9999) 0)
  "<=> should work with large numbers - equal")

(test-assert 
  (= (<=> 50000 30000) 1)
  "<=> should work with large numbers - greater than")

; Test 6: Spaceship with computed values
(test-assert 
  (= (<=> (+ 2 3) (* 2 3)) -1)
  "<=> should work with computed values - 5 < 6")

(test-assert 
  (= (<=> (* 3 4) (+ 6 6)) 0)
  "<=> should work with computed values - 12 = 12")

(test-assert 
  (= (<=> (+ 10 5) (- 20 10)) 1)
  "<=> should work with computed values - 15 > 10")

; Test 7: Spaceship error conditions
(test-error (<=> 5) "<=> should require exactly 2 arguments")
(test-error (<=> 1 2 3) "<=> should require exactly 2 arguments")
(test-error (<=> "hello" 5) "<=> should reject non-numeric arguments")
(test-error (<=> 5 "world") "<=> should reject non-numeric arguments")
(test-error (<=> true false) "<=> should reject non-numeric arguments")

; Test 8: Spaceship with mutable bindings
(define-mutable spaceship-var1 10)
(define-mutable spaceship-var2 20)
(test-assert 
  (= (<=> spaceship-var1 spaceship-var2) -1)
  "<=> should work with mutable bindings")

(set! spaceship-var1 20)
(test-assert 
  (= (<=> spaceship-var1 spaceship-var2) 0)
  "<=> should work with updated mutable bindings")

;------------------------------------------------------------------------------
; != tests (derived from =)

; Test 1: Basic != functionality
(test-assert 
  (!= 1 2)
  "!= should return true for different numbers")

(test-assert 
  (not (!= 5 5))
  "!= should return false for equal numbers")

; Test 2: != with different data types
(test-assert 
  (!= "hello" "world")
  "!= should work with different strings")

(test-assert 
  (not (!= "test" "test"))
  "!= should work with equal strings")

; Test 3: != with symbols
(test-assert 
  (!= (q hello) (q world))
  "!= should work with different symbols")

(test-assert 
  (not (!= (q test) (q test)))
  "!= should work with equal symbols")

; Test 4: != as Church Boolean
(test-assert 
  (= ((!= 1 2) "different" "same") "different")
  "!= should work as Church Boolean - different case")

(test-assert 
  (= ((!= 3 3) "different" "same") "same")
  "!= should work as Church Boolean - same case")

; Test 5: != with computed values
(test-assert 
  (!= (+ 1 2) (* 2 2))
  "!= should work with computed values - 3 != 4")

(test-assert 
  (not (!= (* 3 3) (+ 4 5)))
  "!= should work with computed values - 9 == 9")

; Test 6: != with zero
(test-assert 
  (!= 0 1)
  "!= should work with zero")

(test-assert 
  (not (!= 0 0))
  "!= should work with zero equality")

; Test 7: != with negative numbers
(test-assert 
  (!= -5 -3)
  "!= should work with negative numbers")

(test-assert 
  (not (!= -7 -7))
  "!= should work with equal negative numbers")

;------------------------------------------------------------------------------
; < tests (derived from <=>)

; Test 1: Basic < functionality
(test-assert 
  (< 1 2)
  "< should return true when first < second")

(test-assert 
  (not (< 5 5))
  "< should return false when first == second")

(test-assert 
  (not (< 10 3))
  "< should return false when first > second")

; Test 2: < with zero
(test-assert 
  (< -5 0)
  "< should work with negative vs zero")

(test-assert 
  (< 0 5)
  "< should work with zero vs positive")

(test-assert 
  (not (< 0 0))
  "< should return false for zero vs zero")

; Test 3: < with negative numbers
(test-assert 
  (< -10 -5)
  "< should work with negative numbers")

(test-assert 
  (< -3 2)
  "< should work with negative vs positive")

(test-assert 
  (not (< 2 -3))
  "< should return false for positive vs negative")

; Test 4: < as Church Boolean
(test-assert 
  (= ((< 3 5) "less" "not-less") "less")
  "< should work as Church Boolean - true case")

(test-assert 
  (= ((< 7 4) "less" "not-less") "not-less")
  "< should work as Church Boolean - false case")

; Test 5: < with computed values
(test-assert 
  (< (+ 1 2) (* 2 3))
  "< should work with computed values - 3 < 6")

(test-assert 
  (not (< (* 4 2) (+ 2 3)))
  "< should work with computed values - 8 not < 5")

; Test 6: < with larger numbers
(test-assert 
  (< 1000 2000)
  "< should work with large numbers")

(test-assert 
  (not (< 5000 3000))
  "< should work with large numbers - false case")

;------------------------------------------------------------------------------
; > tests (derived from <=>)

; Test 1: Basic > functionality
(test-assert 
  (> 10 3)
  "> should return true when first > second")

(test-assert 
  (not (> 5 5))
  "> should return false when first == second")

(test-assert 
  (not (> 1 2))
  "> should return false when first < second")

; Test 2: > with zero
(test-assert 
  (> 5 0)
  "> should work with positive vs zero")

(test-assert 
  (> 0 -5)
  "> should work with zero vs negative")

(test-assert 
  (not (> 0 0))
  "> should return false for zero vs zero")

; Test 3: > with negative numbers
(test-assert 
  (> -2 -8)
  "> should work with negative numbers")

(test-assert 
  (> 3 -2)
  "> should work with positive vs negative")

(test-assert 
  (not (> -3 2))
  "> should return false for negative vs positive")

; Test 4: > as Church Boolean
(test-assert 
  (= ((> 7 4) "greater" "not-greater") "greater")
  "> should work as Church Boolean - true case")

(test-assert 
  (= ((> 3 5) "greater" "not-greater") "not-greater")
  "> should work as Church Boolean - false case")

; Test 5: > with computed values
(test-assert 
  (> (* 3 4) (+ 2 3))
  "> should work with computed values - 12 > 5")

(test-assert 
  (not (> (+ 1 2) (* 2 3)))
  "> should work with computed values - 3 not > 6")

;------------------------------------------------------------------------------
; <= tests (derived from < and =)

; Test 1: Basic <= functionality
(test-assert 
  (<= 1 2)
  "<= should return true when first < second")

(test-assert 
  (<= 5 5)
  "<= should return true when first == second")

(test-assert 
  (not (<= 10 3))
  "<= should return false when first > second")

; Test 2: <= with zero
(test-assert 
  (<= -5 0)
  "<= should work with negative vs zero")

(test-assert 
  (<= 0 0)
  "<= should work with zero vs zero")

(test-assert 
  (<= 0 5)
  "<= should work with zero vs positive")

; Test 3: <= with negative numbers
(test-assert 
  (<= -10 -5)
  "<= should work with negative numbers - less")

(test-assert 
  (<= -7 -7)
  "<= should work with negative numbers - equal")

(test-assert 
  (not (<= -2 -8))
  "<= should return false when first > second (negatives)")

; Test 4: <= as Church Boolean
(test-assert 
  (= ((<= 3 5) "less-equal" "greater") "less-equal")
  "<= should work as Church Boolean - true case")

(test-assert 
  (= ((<= 7 4) "less-equal" "greater") "greater")
  "<= should work as Church Boolean - false case")

; Test 5: <= with computed values
(test-assert 
  (<= (+ 1 2) (* 2 3))
  "<= should work with computed values - 3 <= 6")

(test-assert 
  (<= (* 2 3) (+ 3 3))
  "<= should work with computed values - 6 <= 6")

(test-assert 
  (not (<= (* 4 2) (+ 2 3)))
  "<= should work with computed values - 8 not <= 5")

;------------------------------------------------------------------------------
; >= tests (derived from > and =)

; Test 1: Basic >= functionality
(test-assert 
  (>= 10 3)
  ">= should return true when first > second")

(test-assert 
  (>= 5 5)
  ">= should return true when first == second")

(test-assert 
  (not (>= 1 2))
  ">= should return false when first < second")

; Test 2: >= with zero
(test-assert 
  (>= 5 0)
  ">= should work with positive vs zero")

(test-assert 
  (>= 0 0)
  ">= should work with zero vs zero")

(test-assert 
  (>= 0 -5)
  ">= should work with zero vs negative")

; Test 3: >= with negative numbers
(test-assert 
  (>= -2 -8)
  ">= should work with negative numbers - greater")

(test-assert 
  (>= -7 -7)
  ">= should work with negative numbers - equal")

(test-assert 
  (not (>= -10 -5))
  ">= should return false when first < second (negatives)")

; Test 4: >= as Church Boolean
(test-assert 
  (= ((>= 7 4) "greater-equal" "less") "greater-equal")
  ">= should work as Church Boolean - true case")

(test-assert 
  (= ((>= 3 5) "greater-equal" "less") "less")
  ">= should work as Church Boolean - false case")

; Test 5: >= with computed values
(test-assert 
  (>= (* 3 4) (+ 2 3))
  ">= should work with computed values - 12 >= 5")

(test-assert 
  (>= (+ 3 3) (* 2 3))
  ">= should work with computed values - 6 >= 6")

(test-assert 
  (not (>= (+ 1 2) (* 2 3)))
  ">= should work with computed values - 3 not >= 6")

;------------------------------------------------------------------------------
; Comparison operator integration tests

; Test 1: All operators with same values
(define test-val1 5)
(define test-val2 5)
(test-assert 
  (and (= test-val1 test-val2)
       (not (!= test-val1 test-val2))
       (not (< test-val1 test-val2))
       (not (> test-val1 test-val2))
       (<= test-val1 test-val2)
       (>= test-val1 test-val2))
  "all comparison operators should be consistent for equal values")

; Test 2: All operators with different values (first < second)
(define small-val 3)
(define large-val 8)
(test-assert 
  (and (not (= small-val large-val))
       (!= small-val large-val)
       (< small-val large-val)
       (not (> small-val large-val))
       (<= small-val large-val)
       (not (>= small-val large-val)))
  "all comparison operators should be consistent for first < second")

; Test 3: All operators with different values (first > second)
(test-assert 
  (and (not (= large-val small-val))
       (!= large-val small-val)
       (not (< large-val small-val))
       (> large-val small-val)
       (not (<= large-val small-val))
       (>= large-val small-val))
  "all comparison operators should be consistent for first > second")

; Test 4: Transitivity properties
(define val-a 2)
(define val-b 5)
(define val-c 8)
(test-assert 
  (and (< val-a val-b) (< val-b val-c) (< val-a val-c))
  "< should be transitive")

(test-assert 
  (and (> val-c val-b) (> val-b val-a) (> val-c val-a))
  "> should be transitive")

; Test 5: Comparison operators with library functions
(define comparison-list (list 10 5 15 3 12))
(define max-val (foldl (lambda (acc x) ((> x acc) x acc)) (first comparison-list) (rest comparison-list)))
(define min-val (foldl (lambda (acc x) ((< x acc) x acc)) (first comparison-list) (rest comparison-list)))

(test-assert 
  (= max-val 15)
  "comparison operators should work in finding maximum")

(test-assert 
  (= min-val 3)
  "comparison operators should work in finding minimum")

; Test 6: Comparison operators with filter
(define numbers (iota 10))  ; (0 1 2 3 4 5 6 7 8 9)
(define small-numbers (filter (lambda (x) (< x 5)) numbers))
(define large-numbers (filter (lambda (x) (>= x 5)) numbers))

(test-assert 
  (= (length small-numbers) 5)
  "comparison operators should work with filter - small numbers")

(test-assert 
  (= (length large-numbers) 5)
  "comparison operators should work with filter - large numbers")

; Test 7: Complex comparison expressions
(test-assert 
  (and (<= 1 2) (<= 2 3) (<= 3 4))
  "chained comparisons should work")

(test-assert 
  (or (< 5 3) (= 5 5) (> 5 7))
  "comparison operators should work in logical expressions")

; Test 8: Comparison with mutable variables
(define-mutable comp-var 10)
(test-assert 
  (> comp-var 5)
  "comparison should work with mutable variables")

(set! comp-var 2)
(test-assert 
  (< comp-var 5)
  "comparison should work with updated mutable variables")

; Test 9: Comparison operators used in sorting-like operations
(define insert-sorted
  (lambda (lyst x)
    (cond ((nil? lyst) (list x))
          ((<= x (first lyst)) (cons x lyst))
          (else (cons (first lyst) (insert-sorted (rest lyst) x))))))

(define unsorted (list 5 2 8 1 9))
(define sorted-list (foldl insert-sorted () unsorted))

(test-assert 
  (= (first sorted-list) 1)
  "comparison operators should work for sorting - minimum")

(test-assert 
  (< (first sorted-list) (first (rest sorted-list)))
  "comparison operators should work for sorting - order check")

; Test 10: Edge cases with comparison operators
(test-assert 
  (and (not (< 0 0)) (not (> 0 0)) (<= 0 0) (>= 0 0))
  "comparison operators should handle zero correctly")

(test-assert 
  (and (< -10 -5) (> -5 -10) (<= -10 -5) (>= -5 -10))
  "comparison operators should handle negative numbers correctly")

; Test 11: Comparison operators with apply
(test-assert 
  (apply < (list 3 7))
  "< should work with apply")

(test-assert 
  (apply >= (list 10 10))
  ">= should work with apply")

; Test 12: Error propagation in derived operators
(test-error (< 5) "< should propagate spaceship operator errors - too few args")
(test-error (> 1 2 3) "> should propagate spaceship operator errors - too many args")
(test-error (<= "hello" 5) "<= should propagate spaceship operator errors - wrong types")
(test-error (>= 5 "world") ">= should propagate spaceship operator errors - wrong types")

;------------------------------------------------------------------------------
; modulo tests
(lndisplayln "modulo tests")

(test-assert (= (modulo 22/7 1/3)
                0.(142857))
             "modulo should work with non-integer values")

(test-assert (= (modulo 7 3)
                1)
             "modulo should give the same result as remainder for positive values")

(test-assert (= (modulo -7 3)
                2)
             "modulo should give a different result than remainder for negative dividend and positive modulus")

(test-assert (= (modulo 7 -3)
                -2)
             "modulo should give a different result than remainder for positive dividend and negative modulus")

(test-assert (= (modulo -7 -3)
                -1)
             "modulo should give the same result as remainder for negative values")

;------------------------------------------------------------------------------
; string->list/list->string tests  
(lndisplayln "string->list/list->string tests")

; Test 1: Basic string decomposition
(test-assert (= (length (string->list "hello")) 5)
  "string->list should return correct length for ASCII")

(test-assert (= (first (string->list "A")) 65)
  "string->list should return correct codepoint for 'A'")

; Test 2: Empty string handling
(test-assert (= (string->list "") ())
  "string->list should return empty list for empty string")

(test-assert (= (list->string ()) "")
  "list->string should return empty string for empty list")

; Test 3: Round-trip conversion
(test-assert (= (list->string (string->list "test")) "test")
  "round-trip conversion should preserve string")

; Test 4: Unicode support
(define unicode-test "Hello, 世界! 🌍")
(test-assert (= (list->string (string->list unicode-test)) unicode-test)
  "round-trip should work with Unicode text")

; Test 5: String primitives enable library functions
(test-assert (= (string-length "hello") 5)
  "string-length should work using string->list")

(test-assert (= (string-length "😀🌍") 2)
  "string-length should count Unicode characters correctly")

; Test 6: String concatenation via list operations
(test-assert (= (string-append "hello" " " "world") "hello world")
  "string-append should work using list operations")

; Test 7: Character access
(test-assert (= (string-nth "hello" 1) "e")
  "string-ref should return correct character")

; Test 8: String filtering (remove spaces)
(define remove-spaces
  (lambda (s)
    (list->string 
      (filter (lambda (cp) (not (= cp 32))) (string->list s)))))

(test-assert (= (remove-spaces "a b c") "abc")
  "string filtering should work with codepoint operations")

; Test 9: Case conversion framework (uppercase A-Z)
(define char-upcase-codepoint
  (lambda (cp)
    (if (and (>= cp 97) (<= cp 122))  ; lowercase a-z
        (- cp 32)  ; convert to uppercase
        cp)))

(define string-upcase
  (lambda (s)
    (list->string (map char-upcase-codepoint (string->list s)))))

(test-assert (= (string-upcase "hello") "HELLO")
  "string case conversion should work with codepoint mapping")

;------------------------------------------------------------------------------
; substring tests
(lndisplayln "substring tests")

; Test 1: Basic substring with start index only
(test-assert 
  (= (substring "hello" 0) "hello")
  "substring with start 0 should return whole string")

(test-assert 
  (= (substring "hello" 1) "ello")
  "substring with start 1 should drop first character")

(test-assert 
  (= (substring "hello" 3) "lo")
  "substring with start 3 should return suffix")

; Test 2: Basic substring with start and end indices
(test-assert 
  (= (substring "hello" 0 3) "hel")
  "substring with start 0 end 3 should return first 3 characters")

(test-assert 
  (= (substring "hello" 1 4) "ell")
  "substring with start 1 end 4 should return middle section")

(test-assert 
  (= (substring "hello" 2 5) "llo")
  "substring with start 2 end 5 should return suffix")

; Test 3: Empty string cases
(test-assert 
  (= (substring "" 0) "")
  "substring of empty string should return empty string")

(test-assert 
  (= (substring "" 0 0) "")
  "substring of empty string with start and end should return empty string")

; Test 4: Single character string
(test-assert 
  (= (substring "a" 0) "a")
  "substring of single char with start 0 should return the character")

(test-assert 
  (= (substring "a" 0 1) "a")
  "substring of single char with start 0 end 1 should return the character")

(test-assert 
  (= (substring "a" 1) "")
  "substring of single char with start 1 should return empty string")

(test-assert 
  (= (substring "a" 0 0) "")
  "substring with start equals end should return empty string")

; Test 5: Start index at end of string
(test-assert 
  (= (substring "hello" 5) "")
  "substring with start at string length should return empty string")

(test-assert 
  (= (substring "test" 4) "")
  "substring with start at string length should return empty string")

; Test 6: Start index beyond string length (should clamp)
(test-assert 
  (= (substring "hello" 10) "")
  "substring with start beyond string length should return empty string")

(test-assert 
  (= (substring "test" 100) "")
  "substring with large start index should return empty string")

; Test 7: End index beyond string length (should clamp)
(test-assert 
  (= (substring "hello" 2 100) "llo")
  "substring with end beyond string length should clamp to string length")

(test-assert 
  (= (substring "test" 0 50) "test")
  "substring with large end should return from start to end of string")

; Test 8: Start equals end cases
(test-assert 
  (= (substring "hello" 2 2) "")
  "substring with start equals end should return empty string")

(test-assert 
  (= (substring "hello" 0 0) "")
  "substring with start 0 end 0 should return empty string")

(test-assert 
  (= (substring "hello" 5 5) "")
  "substring with start and end at string length should return empty string")

; Test 9: Start greater than end (should return empty)
(test-assert 
  (= (substring "hello" 3 1) "")
  "substring with start > end should return empty string")

(test-assert 
  (= (substring "hello" 4 2) "")
  "substring with start > end should return empty string")

; Test 10: Extract single characters
(test-assert 
  (= (substring "hello" 0 1) "h")
  "substring extracting first character")

(test-assert 
  (= (substring "hello" 1 2) "e")
  "substring extracting second character")

(test-assert 
  (= (substring "hello" 4 5) "o")
  "substring extracting last character")

; Test 11: Unicode support
(test-assert 
  (= (substring "Hello, 世界!" 7 9) "世界")
  "substring should work with Unicode characters")

(test-assert 
  (= (substring "🌍🌎🌏" 1 2) "🌎")
  "substring should work with emoji characters")

(test-assert 
  (= (substring "café" 2 4) "fé")
  "substring should work with accented characters")

; Test 12: Longer strings
(define long-string "The quick brown fox jumps over the lazy dog")
(test-assert 
  (= (substring long-string 0 9) "The quick")
  "substring should work with longer strings - beginning")

(test-assert 
  (= (substring long-string 10 15) "brown")
  "substring should work with longer strings - middle")

(test-assert 
  (= (substring long-string 35) "lazy dog")
  "substring should work with longer strings - end")

; Test 13: Whitespace and special characters
(test-assert 
  (= (substring "  hello  " 2 7) "hello")
  "substring should handle whitespace correctly")

(test-assert 
  (= (substring "a\nb\tc" 0 5) "a\nb\tc")
  "substring should handle newlines and tabs")

(test-assert 
  (= (substring "hello\nworld" 6) "world")
  "substring should handle strings with newlines")

; Test 14: Boundary conditions
(test-assert 
  (= (substring "abc" 0 3) "abc")
  "substring covering entire string should return original")

(test-assert 
  (= (substring "abc" 1 3) "bc")
  "substring from middle to end")

(test-assert 
  (= (substring "abc" 0 2) "ab")
  "substring from start excluding last character")

; Test 15: Error conditions - wrong number of arguments
(test-error (substring) "substring should require at least 2 arguments")
(test-error (substring "hello") "substring should require at least 2 arguments")

; Test 16: Error conditions - wrong argument types
(test-error (substring 123 0) "substring should reject non-string first argument")
(test-error (substring "hello" "start") "substring should reject non-numeric start index")
(test-error (substring "hello" 0 "end") "substring should reject non-numeric end index")

; Test 17: Error conditions - negative indices
(test-error (substring "hello" -1) "substring should reject negative start index")
(test-error (substring "hello" 0 -1) "substring should reject negative end index")

; Test 18: Error conditions - non-integer indices
(test-error (substring "hello" 1.5) "substring should reject non-integer start index")
(test-error (substring "hello" 0 2.5) "substring should reject non-integer end index")

; Test 19: Composition with other string functions
(test-assert 
  (= (string-length (substring "hello world" 6)) 5)
  "substring should compose with string-length")

(test-assert 
  (= (substring (string-append "hello" " " "world") 0 5) "hello")
  "substring should work with string-append results")

; Test 20: substring used in higher-order functions
(define extract-prefix (lambda (str) (substring str 0 3)))
(test-assert 
  (= (extract-prefix "testing") "tes")
  "substring should work in higher-order functions")

(define string-list (list "apple" "banana" "cherry"))
(define prefixes (map (lambda (s) (substring s 0 2)) string-list))
(test-assert 
  (= (first prefixes) "ap")
  "substring should work with map - first result")

(test-assert 
  (= (first (rest prefixes)) "ba")
  "substring should work with map - second result")

; Test 21: substring with conditional logic
(define safe-substring
  (lambda (str start end)
    (let ((len (string-length str)))
      ((and (>= start 0) (< start len))
       (substring str start ((nil? end) len end))
       ""))))

(test-assert 
  (= (safe-substring "hello" 2 4) "ll")
  "conditional substring should work normally")

(test-assert 
  (= (safe-substring "hello" 10 15) "")
  "conditional substring should handle out-of-bounds safely")

; Test 22: substring for string parsing patterns
(define get-file-extension
  (lambda (filename)
    (let ((dot-pos (string-length filename)))  ; Simplified - assume extension exists
      (substring filename (- dot-pos 3)))))   ; Get last 3 chars

(test-assert 
  (= (get-file-extension "test.txt") "txt")
  "substring should work for file extension extraction")

; Test 23: Empty substring in middle of string
(test-assert 
  (= (substring "hello" 2 2) "")
  "substring with equal start and end should return empty string")

(test-assert 
  (= (substring "world" 3 3) "")
  "substring with equal indices should return empty string")

; Test 24: substring with string->list round trip
(define manual-substring
  (lambda (str start end)
    (let ((chars (string->list str)))
      (list->string (take (- end start) (drop start chars))))))

(test-assert 
  (= (manual-substring "hello" 1 4) (substring "hello" 1 4))
  "substring should match manual implementation using string->list")

; Test 25: Performance with longer strings
(define very-long-string 
  (apply string-append (map (lambda (n) "hello ") (iota 10))))

(test-assert 
  (= (substring very-long-string 0 5) "hello")
  "substring should work efficiently with longer strings")

(test-assert 
  (= (string-length (substring very-long-string 10)) (- (string-length very-long-string) 10))
  "substring should preserve correct length with longer strings")

; Test 26: Multiple substring operations
(define test-string "abcdefghijk")
(define first-half (substring test-string 0 5))
(define second-half (substring test-string 5))
(test-assert 
  (= (string-append first-half second-half) test-string)
  "splitting and rejoining with substring should preserve original")

; Test 27: substring with apply
(test-assert 
  (= (apply substring (list "hello" 1 3)) "el")
  "substring should work with apply")

; Test 28: Edge case - very small strings
(test-assert 
  (= (substring "x" 0) "x")
  "substring should work with very small strings")

(test-assert 
  (= (substring "ab" 1 2) "b")
  "substring should extract single character from two-character string")

; Test 29: Clamping behavior verification
(test-assert 
  (= (substring "test" 2 100) (substring "test" 2))
  "substring with large end should equal substring with no end")

(test-assert 
  (= (substring "test" 100 200) "")
  "substring with both indices beyond string should return empty")

; Test 30: Unicode edge cases
(define mixed-unicode "ASCII🌍中文")
(test-assert 
  (= (substring mixed-unicode 5 6) "🌍")
  "substring should correctly handle mixed ASCII and Unicode")

(test-assert 
  (= (substring mixed-unicode 6) "中文")
  "substring should handle Unicode at end of mixed string")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Show test results
(if (= test-failures 0)
    "All library tests passed!"
    (do
      (define message "Library tests failed!")
      test-failures))
