; This is the "standard library" for my fexpr interpreter.
; Note that, by convention, `_` indicates an ignored value.
; NOTE THAT nil IS SPELT ()

; TODO: Rewrite any uses of if into Church boolean form.

; TODO: Do we need this? Is it correct?
(define get-current-environment
  (vau () env env))

; quote
; Use of this is not encouraged as it shouldn't be needed in a fexpr-based
; language.
(define q (vau (operand) _ operand))

; Library implementation of do
(define do-helper
  (vau (remaining last-result env) _
    ((nil? remaining)
     last-result
     (invoke do-helper 
            (cons (rest remaining) 
                  (cons (eval (first remaining) env) 
                        (cons env ())))))))

(define do
  (vau expressions env
    ((nil? expressions)
     ()
     (invoke do-helper 
            (cons (rest expressions) 
                  (cons (eval (first expressions) env) 
                        (cons env ())))))))

; A convenience function.
; Since we use Church booleans, you can essentially just remove the if.
; (if (nil? lyst) 0 1) -> ((nil? lyst) 0 1)
; Candidate for being replaced by a macro in the future.
(define if
  (vau (test consequent alternate) env
    (do 
      (define selector (eval test env))
      ; Pass the actual operative values, not variables
      (invoke (selector 
                (vau () _ (eval consequent env))
                (vau () _ (eval alternate env))) 
              ()))))

; Construct a list from the arguments without evaluating them
(define unevaluated-list (vau args env args))

; Evaluates a list of items in the given env
(define eval-list
  (vau (lyst env-expr) current-env
    (do
      ; First, evaluate our arguments
      (define target-env (eval env-expr current-env))
      (define actual-list (eval lyst current-env))
      ; Then, make a helper to do the actual evaluation of lyst's elements
      (define eval-list-helper
        (vau (remaining) _
          (if (nil? remaining)
            ()
            (cons (eval (first remaining) target-env)
                  ; Because `invoke` unpacks the argument list, we need to use
                  ; `cons` to wrap our single argument so it becomes one
                  ; argument when unpacked.
                  (invoke eval-list-helper (cons (rest remaining) ()))))))
      ; Again, use `cons` to wrap the argument
      (invoke eval-list-helper (cons actual-list ())))))

; wrap takes an operative and returns a new operative that evaluates its arguments
(define wrap
  ; Here, the implicit env is the env where `define` was evaluated
  ; when loading the library.
  ; i.e. The global env
  (vau (operative) wrap-call-env
    ; Here, the implicit env is still the global env (the closure env of this
    ; vau).
    ; When this outer vau is called, i.e. when `wrap` is called, it creates a
    ; new env with the global env as its parent, `wrap-call-env` bound to the
    ; env where `wrap` was called, and `operative` bound to the argument of
    ; `wrap`. This new env becomes the implicit env.
    (do
      ; Evaluate the operative once when wrap is called
      (define resolved-operative (eval operative wrap-call-env))
      (vau unevaluated-args wrapped-call-env
        ; Here, the implicit env is the closure environment of this inner vau.
        ; This environment was created by the `do` block when the outer vau was
        ; called, and contains `resolved-operative` as well as access to the
        ; global environment. When this inner vau is called, it creates a new
        ; environment extending this closure environment, with
        ; `wrapped-call-env` bound to the calling environment and
        ; `unevaluated-args` bound to the arguments.
        (do
          (define evaluated-args (eval-list unevaluated-args wrapped-call-env))
          (invoke resolved-operative evaluated-args))))))

; This version of lambda, like primitive vau, only supports a single expression
; body and doesn't support the (head . tail) style of variadic parameters.
(define lambda
  ; We don't support (head . tail) style of parameters.
  ; But we also don't support multiple expressions in the body of a vau or lambda.
  ; So, (formals body) for us is equivalent to (formals . body) for Kernel except
  ; that our body won't be a list.
  (vau (formals body) env
    (wrap (eval
            ; Kernel uses list* here and its last parameter is a list.
            ; So, in Kernel, this part...
            ;    (list* $vau formals #ignore body)
            ; ...is equivalent to...
            ;    (cons $vau (cons formals (cons #ignore body)))
            ; We use () for #ignored and body is not a list, so our equivalent is:
            (cons vau (cons formals (cons () (cons body ()))))
            env))))

; A version of lambda that supports multiple body expressions
(define lambda*
  (vau operands dyn-env
    (do (define formals (first operands))
        (define body (prepend do (rest operands)))
        (wrap (eval (list vau formals () body) dyn-env)))))

; Lambda makes implementing list trivial.
(define list (lambda args args))

; This is the equivalent of Kernel's list*.
; It prepends its arguments to the list that is the final argument.
; The $lambda-based implementation of list* given in the Kernel report doesn't
; look to match the expected behavior in use. It would evaluate its arguments
; multiple times during the recursion, but uses seem to expect that its
; arguments would only be evaluated once. To achieve that, this implementation
; uses an inner fexpr for the recursion.
(define prepend
  (do (define recurse
              (vau operands _
                (if (nil? operands)
                    ()
                    (do (define head (first operands))
                        (define tail (rest operands))
                        (if (nil? tail)
                            head
                            (cons head (invoke recurse tail)))))))
      (lambda args (invoke recurse args))))

(define newline (lambda () (display "\n")))

; An example of a macro-like fexpr:
;($define! $when
;   ($vau (test . body) env
;      (eval (list $if test (list* $sequence body) #inert)
;            env)))
; Test: (when (nil? ()) (display "true"))
; Needs more tests
(define when
  (vau args env
    (do
      (define test (first args))
      (define body (rest args))
      (define if-expr (list if test (cons do body) ()))
      (eval if-expr env))))

; TODO: for-each* that can handle n-ary procedures?
(define for-each (lambda (procedure lyst)
                   (if (nil? lyst)
                       ()
                       (do (procedure (first lyst))
                           (for-each procedure (rest lyst))))))

; Should optionally take a separator?
(define displayln
  (lambda* args
    (for-each display args)
    (newline)))

(define second (lambda (lyst) (first (rest lyst))))

; foldr applies a binary function to the elements of a list from right to left
; foldr : (a -> b -> b) -> b -> [a] -> b
; Example: (foldr + (list 1 2 3) 0) => 6
; Example: (foldr cons (list 1 2 3) ()) => (1 2 3)
(define foldr
  (lambda (func lyst init)
    ((nil? lyst)
      init
      (func (first lyst) 
            (foldr func (rest lyst) init)))))

; Example of how cond is transformed into a chain of Church booleans:
#skip
(cond ((= 2 0) 0)
      ((= 2 1) 1)
      ((= 2 2) 2)
      (else 3))
; or
(cond ((= 2 0) 0) ((= 2 1) 1) ((= 2 2) 2) (else 3))
; becomes
((= 2 0) 0
         ((= 2 1) 1
                  ((= 2 2) 2
                           3)))
; or
((= 2 0) 0 ((= 2 1) 1 ((= 2 2) 2 3)))
#end

; Example of using bare Church booleans:
#skip
(cond (false 0)
      (true 1))
; becomes
(false 0 (true 1 ()))
#end

; A macro-like transformer for cond clauses
(define cond-transformer
  (lambda* (clauses)
    (foldr
      (lambda (clause acc)
        ((= (q else) (first clause))
         (second clause)
         (list (first clause) (second clause) acc)))
      clauses
      (); error?
    )))

; This forwards its arguments to cond-transformer to do the syntax
; transformation. Then it evaluates the transformed syntax.
(define cond
  (vau cond-clauses cond-dyn-env
    (do (define transformed (cond-transformer cond-clauses))
        (eval transformed cond-dyn-env))))

(define cond-test
  (lambda (n)
    (cond ((= n 0) 0)
          ((= n 1) 1)
          ((= n 2) 2)
          (else 3))))