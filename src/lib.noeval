; This is the "standard library" for my fexpr interpreter.
; Note that, by convention, `_` indicates an ignored value.
; NOTE THAT nil IS SPELT ()

(define get-current-environment
  (vau () env env))

; quote
; Use of this is not encouraged as it shouldn't be needed in a fexpr-based
; language.
(define q (vau (operand) _ operand))

#skip
; Library implementation of do
; Using invoke is likely incorrect here because the recursive call should get
; the same dynamic environment as the caller.
(define do-helper
  (vau (remaining last-result env) _
    ((nil? remaining)
     last-result
     (invoke do-helper 
            (cons (rest remaining) 
                  (cons (eval (first remaining) env) 
                        (cons env ())))))))

; Currently using the primitive do instead of this one.
; Using invoke is likely incorrect here because the recursive call should get
; the same dynamic environment as the caller.
(define do
  (vau expressions env
    ((nil? expressions)
     ()
     (invoke do-helper 
            (cons (rest expressions) 
                  (cons (eval (first expressions) env) 
                        (cons env ())))))))
#end

; A convenience function.
; Since we use Church Booleans, you can essentially just remove the if.
; (if (nil? lyst) 0 1) -> ((nil? lyst) 0 1)
; Which is what this implementation does.
; Candidate for being replaced by a macro in the future.
(define if (vau operands env (eval operands env)))

; Construct a list from the arguments without evaluating them
(define unevaluated-list (vau args env args))

; or operative - short-circuiting logical or
; Returns the first truthy value, or the last value if all are falsy
; Uses Church Boolean evaluation for short-circuiting
(define or
  (vau operands env
    ((nil? operands)
     false  ; Empty or is false
     ((eval (first operands) env)
      true
      (eval (cons or (rest operands)) env)))))

; Evaluates a list of items in the given env
(define eval-list
  (vau (lyst env-expr) current-env
    (do
      ; First, evaluate our arguments
      (define target-env (eval env-expr current-env))
      (define actual-list (eval lyst current-env))
      ((or (nil? actual-list) (= (q cons-cell) (typeof actual-list)))
       ()
       (raise "eval-list's first argument must be a list"))
      ; Then, make a helper to do the actual evaluation of lyst's elements
      (define eval-list-helper
        (vau (remaining) _
          (if (nil? remaining)
            ()
            (cons (eval (first remaining) target-env)
                  ; Because `invoke` unpacks the argument list, we need to use
                  ; `cons` to wrap our single argument so it becomes one
                  ; argument when unpacked.
                  (invoke eval-list-helper (cons (rest remaining) ()))))))
      ; Again, use `cons` to wrap the argument
      (invoke eval-list-helper (cons actual-list ())))))

; wrap takes an operative and returns a new operative that evaluates its arguments
(define wrap
  ; Here, the implicit env is the env where `define` was evaluated
  ; when loading the library.
  ; i.e. The global env
  (vau (operative) wrap-call-env
    ; Here, the implicit env is still the global env (the closure env of this
    ; vau).
    ; When this outer vau is called, i.e. when `wrap` is called, it creates a
    ; new env with the global env as its parent, `wrap-call-env` bound to the
    ; env where `wrap` was called, and `operative` bound to the argument of
    ; `wrap`. This new env becomes the implicit env.
    (do
      ; Evaluate the operative once when wrap is called
      (define resolved-operative (eval operative wrap-call-env))
      ((= (q operative) (typeof resolved-operative))
       ()
       (raise "wrap can only be applied to operatives"))
      (vau unevaluated-args wrapped-call-env
        ; Here, the implicit env is the closure environment of this inner vau.
        ; This environment was created by the `do` block when the outer vau was
        ; called, and contains `resolved-operative` as well as access to the
        ; global environment. When this inner vau is called, it creates a new
        ; environment extending this closure environment, with
        ; `wrapped-call-env` bound to the calling environment and
        ; `unevaluated-args` bound to the arguments.
        (do
          (define evaluated-args (eval-list unevaluated-args wrapped-call-env))
          (eval (cons resolved-operative evaluated-args) wrapped-call-env))))))

; This version of lambda, like primitive vau, only supports a single expression
; body and doesn't support the (head . tail) style of variadic parameters.
(define lambda
  ; We don't support (head . tail) style of parameters.
  ; But we also don't support multiple expressions in the body of a vau or lambda.
  ; So, (formals body) for us is equivalent to (formals . body) for Kernel except
  ; that our body won't be a list.
  (vau (formals body) env
    (wrap (eval
            ; Kernel uses list* here and its last parameter is a list.
            ; So, in Kernel, this part...
            ;    (list* $vau formals #ignore body)
            ; ...is equivalent to...
            ;    (cons $vau (cons formals (cons #ignore body)))
            ; We use () for #ignored and body is not a list, so our equivalent is:
            (cons vau (cons formals (cons () (cons body ()))))
            env))))

; A version of lambda that supports multiple body expressions
(define lambda*
  (vau operands dyn-env
    (do (define formals (first operands))
        (define body (cons do (rest operands)))
        (wrap (eval (list vau formals () body) dyn-env)))))

; A version of vau that supports multiple body expressions
(define vau*
  (vau operands dyn-env
    (do (define formals (first operands))
        (define env-param (second operands))
        (define body (cons do (rest (rest operands))))
        (eval (list vau formals env-param body) dyn-env))))

; Lambda makes implementing list trivial.
(define list (lambda args args))

; This is the equivalent of Kernel's list*.
; It prepends its arguments to the list that is the final argument.
; The $lambda-based implementation of list* given in the Kernel report doesn't
; look to match the expected behavior in use. It would evaluate its arguments
; multiple times during the recursion, but uses seem to expect that its
; arguments would only be evaluated once. To achieve that, this implementation
; uses an inner fexpr for the recursion.
(define prepend
  (do (define recurse
              (vau operands _
                (if (nil? operands)
                    ()
                    (do (define head (first operands))
                        (define tail (rest operands))
                        (if (nil? tail)
                            head
                            (cons head (invoke recurse tail)))))))
      (lambda args (invoke recurse args))))

(define newline (lambda () (display "\n")))

(define number? (lambda (x) (= (q number) (typeof x))))
(define integer? (lambda (x) (and (number? x) (= 1 (denominator x)))))
(define non-negative-integer? (lambda (x) (and (integer? x) (>= x 0))))
(define string? (lambda (x) (= (q string) (typeof x))))
(define symbol? (lambda (x) (= (q symbol) (typeof x))))
(define list? (lambda (x) (or (nil? x) (= (q cons-cell) (typeof x)))))
(define operative? (lambda (x) (= (q operative) (typeof x))))
(define environment? (lambda (x) (= (q environment) (typeof x))))

; An example of a macro-like fexpr:
;($define! $when
;   ($vau (test . body) env
;      (eval (list $if test (list* $sequence body) #inert)
;            env)))
; Test: (when (nil? ()) (display "true"))
; Needs more tests
(define when
  (vau args env
    (do
      (define test (first args))
      (define body (rest args))
      (define if-expr (list if test (cons do body) ()))
      (eval if-expr env))))

(define unless
  (vau args env
    (do
      (define test (first args))
      (define body (rest args))
      (define if-expr (list if test () (cons do body)))
      (eval if-expr env))))

(define for-each (lambda* (procedure lyst)
                   (unless (operative? procedure)
                     (raise "for-each's first argument must be callable"))
                   (unless (list? lyst)
                     (raise "for-each's second argument must be a list"))
                   (define loop (lambda (loop-lyst)
                                  ((nil? loop-lyst)
                                   ()
                                   (do (procedure (first loop-lyst))
                                       (loop (rest loop-lyst))))))
                   (loop lyst)))

; Should optionally take a separator?
(define displayln
  (lambda* args
    (for-each display args)
    (newline)))

(define lndisplayln
  (lambda* args
    (newline)
    (apply displayln args)))

(define second (lambda (lyst) (first (rest lyst))))
(define third (lambda (lyst) (first (rest (rest lyst)))))

; foldl applies a binary function to the elements of a list from left to right
; (foldl + 1 (list 2 3 4)) -> (+ (+ (+ 1 2) 3) 4)
(define foldl
  (lambda* (func init lyst)
    (unless (operative? func)
     (raise "foldl's first argument must be callable"))
    (unless (list? lyst)
     (raise "foldl's second argument must be a list"))
    (define loop
      (lambda (init lyst)
        ((nil? lyst)
         init
         (loop (func init (first lyst))
               (rest lyst)))))
    (loop init lyst)))

; foldr applies a binary function to the elements of a list from right to left
; foldr : (a -> b -> b) -> b -> [a] -> b
; Example: (foldr + (list 1 2 3) 0) => 6
; Example: (foldr cons (list 1 2 3) ()) => (1 2 3)
(define foldr
  (lambda* (func lyst init)
    (unless (operative? func)
     (raise "foldr's first argument must be callable"))
    (unless (list? lyst)
     (raise "foldr's second argument must be a list"))
    (define loop
      (lambda (lyst)
        ((nil? lyst)
         init
         (func (first lyst) 
               (loop (rest lyst))))))
    (loop lyst)))

(define last (lambda* (lyst)
               (define loop (lambda (head tail)
                              ((nil? tail) head
                                           (loop (first tail)
                                                 (rest tail)))))
               ((nil? lyst) ()
                            (loop (first lyst)
                                  (rest lyst)))))

; Returns 0 if not found.
; Otherwise, returns the 1-based index.
(define list-index
  (lambda* (predicate lyst)
    (define loop
      (lambda (index head tail)
        ((predicate head)
         index
         ((nil? tail)
          0
          (loop (+ index 1)
                (first tail)
                (rest tail))))))
    ((nil? lyst)
     0
     (loop 1
           (first lyst)
           (rest lyst)))))

; Example of how cond is transformed into a chain of Church Booleans:
#skip
(cond ((= 2 0) 0)
      ((= 2 1) 1)
      ((= 2 2) 2)
      (else 3))
; or
(cond ((= 2 0) 0) ((= 2 1) 1) ((= 2 2) 2) (else 3))
; becomes
((= 2 0) 0
         ((= 2 1) 1
                  ((= 2 2) 2
                           3)))
; or
((= 2 0) 0 ((= 2 1) 1 ((= 2 2) 2 3)))
#end

; Example of using bare Church Booleans:
#skip
(cond (false 0)
      (true 1))
; becomes
(false 0 (true 1 ()))
#end

; A macro-like transformer for cond clauses
(define cond-transformer
  (lambda* (clauses)
    (foldr
      (lambda* (clause acc)
        (unless (list? clause)
          (raise "cond clause must be a list"))
        (unless (> (length clause) 0)
          (raise "cond clauses must have a test"))
        (define clause-head (first clause))
        (define body (rest clause))
        (define body-expr ((> (length body) 1)
                           (cons (q do) body)
                           ((nil? body)
                            ()
                            (first body))))
        ((and (symbol? clause-head)
              (= (q else) clause-head))
         ((nil? acc)
          body-expr
          (raise "else clause must be the last clause"))
         (list clause-head body-expr acc)))
      clauses
      ())))

; This forwards its arguments to cond-transformer to do the syntax
; transformation. Then it evaluates the transformed syntax.
; (cond) returns ()
; Each clause must have a test.
; An empty body returns ().
; Multiple expressions are allowed in clause bodies.
; Validate that there is only one else clause.
; Validate that any else clause is the last clause.
(define cond
  (vau cond-clauses cond-dyn-env
    (do (define transformed (cond-transformer cond-clauses))
        (eval transformed cond-dyn-env))))

; and operative - short-circuiting logical and
; Returns the first falsy value, or the last value if all are truthy
; Uses Church Boolean evaluation for short-circuiting
(define and
  (vau operands env
    ((nil? operands)
     true  ; Empty and is true
     ((eval (first operands) env)
      (eval (cons and (rest operands)) env)
      false))))

; not operative - logical negation
; Returns the Church Boolean opposite of its argument
(define not
  (vau (operand) env
    (do
      (define val (eval operand env))
      (val false true))))

(define λ lambda)
(define ∧ and)
(define ∨ or)
(define ¬ not)
(define × *)
(define ÷ /)

(define != (λ (x y) (¬ (= x y))))
(define <> !=)
(define <  (λ (x y)
             ((and (number? x)
                   (number? y))
              (= -1 (<=> x y))
              (raise "< can only be applied to numbers"))))
(define >  (λ (x y)
             ((and (number? x)
                   (number? y))
              (= 1 (<=> x y))
              (raise "> can only be applied to numbers"))))

(define <= (λ (x y) (∨ (< x y) (= x y))))
(define >= (λ (x y) (∨ (> x y) (= x y))))
(define ≤  <=)
(define ≥  >=)

; ×÷∧∨¬≤≥λ
; option + /: ÷
; option + =: ≠
; option + ,: ≤
; option + .: ≥
; option + l: ¬

; Using "Unicode shortcuts" VS Code extension...
; Type backslash character-name shift+space
; \lambda λ
; \not ¬
; \and ∧
; \or ∨
; \neq ≠
; \le ≤
; \ge ≥

; No way to type ×?

(define map
  (lambda* (proc lyst)
    (unless (operative? proc)
     (raise "map's first argument must be callable"))
    (unless (list? lyst)
     (raise "map's second argument must be a list"))
    (define loop
      (lambda (lyst)
        ((nil? lyst)
         ()
         (cons (proc (first lyst))
               (loop (rest lyst))))))
    (loop lyst)))

#skip
; Example let transformation:
(let ((x 10)
      (y 2))
  (displayln (* x y))
  (displayln (/ x y)))
; becomes
((lambda* (x y)
   (displayln (* x y))
   (displayln (/ x y)))
 10 2)
#end

(define let
  (vau* operands dyn-env
    (define bindings (first operands))
    (eval (cons (prepend lambda*
                         (map first bindings)
                         (rest operands))
                (map second bindings))
          dyn-env)))

; apply: The applicative version of invoke
; Takes an applicative and a list of arguments,
; applies the applicative to the arguments
(define apply
  (lambda (applicative arg-list)
     (cond ((not (operative? applicative))
            (raise "apply's first argument must be an applicative"))
           ((not (list? arg-list))
            (raise "apply's second argument must be a list"))
           (else
            (eval (cons applicative (map (lambda (arg) (list q arg)) arg-list))
            (get-current-environment))))))

(define length
  (lambda* (lyst)
    (unless (list? lyst)
      (raise "length's argument must be a list"))
    (foldl (lambda (n element)
             (+ n 1))
           0
           lyst)))

(define nth
  (lambda* (lyst n)
    (unless (list? lyst)
            (raise "nth's first argument must be a list"))
    (unless (and (integer? n)
                 (>= n 0))
            (raise "nth's second argument must be a non-negative integer"))
    (define loop
      (lambda (lyst n)
        ((nil? lyst)
         (raise "nth: index out of bounds")
         ((= n 0)
          (first lyst)
          (loop (rest lyst)
                (- n 1))))))
    (loop lyst n)))

(define snoc (lambda (tail head) (cons head tail)))

(define reverse (lambda (lyst)
                  ((list? lyst)
                   (foldl snoc () lyst)
                   (raise "reverse's argument must be a list"))))

(define any?
  (lambda* (predicate lyst)
    (unless (operative? predicate)
      (raise "The first argument to any? must be a predicate"))
    (unless (list? lyst)
      (raise "The second argument to any? must be a list"))
    (define loop
      (lambda (lyst)
        ((nil? lyst)
         false
        ((predicate (first lyst))
         true
         (loop (rest lyst))))))
    (loop lyst)))

(define all?
  (lambda* (predicate lyst)
    (unless (operative? predicate)
      (raise "The first argument to all? must be a predicate"))
    (unless (list? lyst)
      (raise "The second argument to all? must be a list"))
    (define loop
      (lambda (lyst)
        ((nil? lyst)
         true
         ((predicate (first lyst))
          (loop (rest lyst))
          false))))
    (loop lyst)))

(define append (lambda* lists
                 (unless (all? list? lists)
                   (raise "the arguments to append must all be lists"))
                 (define append2 (lambda (list1 list2)
                                   ((nil? list1)
                                   list2
                                   (cons (first list1)
                                         (append2 (rest list1)
                                                   list2)))))
                 (foldl append2 () lists)))

(define filter (lambda* (predicate lyst)
                 (unless (operative? predicate)
                   (raise "filter's first argument must be callable predicate"))
                 (unless (list? lyst)
                   (raise "filter's second argument must be a list"))
                 (foldl (lambda (accumulator element)
                          ((predicate element)
                           (cons element accumulator)
                           accumulator))
                        ()
                        (reverse lyst))))

(define iota (lambda* (count)
               (unless (number? count)
                 (raise "iota's argument must be a number"))
               ; "iota" backwards is "atoi"
               (define atoi (lambda (count)
                              ((<= count 0)
                               ()
                               (let ((next (- count 1)))
                                 (cons next (atoi next))))))
               (reverse (atoi count))))

; Q&D test of even?: (map even? (map (lambda (x) (- x 9)) (iota 19)))
; TODO: Fix this after we upgrade numbers from int to boost::cpp_rational.
(define even? (lambda* (x)
                ((integer? x)
                 (= 0 (remainder x 2))
                 (raise "even? can only be applied to integers"))))

(define odd? (lambda (x)
               ((integer? x)
                (not (even? x))
                (raise "odd? can only be applied to integers"))))

(define abs (lambda (x)
              ((< x 0)
               (- 0 x)
               x)))

(define modulo (lambda (x y)
                 (let ((r (remainder x y)))
                   ((= r 0)
                    0
                    ((< (* r y) 0)
                     (+ r y)
                     r)))))

(define drop
  (lambda* (n lyst)
    (unless (and (integer? n)
                 (>= n 0))
      (raise "drop's first argument must be a non-negative integer"))
    (unless (list? lyst)
      (raise "drop's second argument must be a list"))
    (define loop
      (lambda (n lyst)
        ((or (nil? lyst)
             (<= n 0))
         lyst
         (loop (- n 1)
               (rest lyst)))))
    (loop n lyst)))

(define take
  (lambda* (n lyst)
    (unless (and (integer? n)
                 (>= n 0))
      (raise "take's first argument must be a non-negative integer"))
    (unless (list? lyst)
      (raise "take's second argument must be a list"))
    (define loop
      (lambda (n lyst)
        ((or (nil? lyst)
             (<= n 0))
         ()
         (cons (first lyst)
               (loop (- n 1)
                     (rest lyst))))))
    (loop n lyst)))

(define string-length (lambda (s) (length (string->list s))))

(define string-append 
  (lambda strings
    (list->string (apply append (map string->list strings)))))

(define strings->string
  (lambda (strings)
    (apply string-append strings)))

(define string-nth
  (lambda (s n)
    (list->string (list (nth (string->list s)
                             n)))))

; Maybe a helper for lambda argument validation?
(define check
  (lambda (val pred msg)
          ((pred val)
           val
           (raise msg))))

(define clamp
  (lambda (input lower higher)
    (cond ((< input lower)
           lower)
          ((> input higher)
           higher)
          (else input))))

(define substring
  (lambda* args
    (define nargs (length args))
    (unless (or (= nargs 2)
                (= nargs 3))
            (raise "must have 2 or 3 args"))
    (define lyst (string->list (check (first args)
                                      string?
                                      "1st arg must be a string")))
    (define len (length lyst))
    (define start (clamp (check (second args)
                                non-negative-integer?
                                "start must be a non-negative integer")
                         0
                         len))
    (define dropped (drop start lyst))
    (define end ((= nargs 2)
                 len
                 (clamp (check (third args)
                               non-negative-integer?
                               "3rd arg must be a non-negative integer")
                        start
                        len)))
    (list->string ((= end len)
                   dropped
                   (take (- end start)
                          dropped)))))

(define string->codepoint-strings
  (lambda (s)
    (cond ((not (string? s))
           (raise "string->codepoint-strings' argument must be a string"))
          (else
           (map list->string (map list (string->list s)))))))

(define countdown
  (lambda (n)
    ((number? n)
     ((<= n 0)
      ()
      (do (displayln n)
          (countdown (- n 1))))
     (raise "countdown's argument must be a number"))))

(define factorial
  (lambda* (n)
    (unless (number? n)
      (raise "factorial can only be calculated for numbers"))
    (unless (>= n 0)
      (raise "factorial is only defined for non-negative integers"))
    (define iter
      (lambda (n acc)
        ((<= n 0)
         acc
         (iter (- n 1)
               (* n acc)))))
    (iter n 1)))