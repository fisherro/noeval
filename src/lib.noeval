; This is the "standard library" for my fexpr interpreter.
; Note that, by convention, `_` indicates an ignored value.
; NOTE THAT nil IS SPELT ()

; TODO: Do we need this?
(define get-current-environment
  (vau () env env))

; quote
(define q (vau (operand) _ operand))

(define if
  (vau (test consequent alternate) env
    (do 
      (define selector (eval test env))
      ; Pass the actual operative values, not variables
      (invoke (selector 
                (vau () _ (eval consequent env))
                (vau () _ (eval alternate env))) 
              ()))))

; TODO cond
; (cond (test1 exp1 exp2)
;       (test2 exp3 exp4)
;       (test3 exp5 exp6))
; ...becomes...
; (test1 (vau () _ (do exp1 exp2))
;        (test2 (vau () _ (do exp3 exp4)))
;               (test3 (vau () _ (do exp5 exp6))))

; This does the syntax transformation of turning the arguments passed to cond
; into chained Church booleans.
; Although at the moment we only have a stub implementation.
(define cond-macro
  (vau (clauses) env
    (do (define clause (first clauses))
        (define test (first clause))
        (define then (first (rest clause)))
        (define else (first (rest clauses)))
        (test then else))))

; This forwards its arguments to cond-macro to do the syntax transformation.
; Then it evaluates the transformed syntax.
(define cond
  (vau clauses env
    (eval (cond-macro (eval clauses env) env))))

; list evaluates its arguments and returns them as a list
; But this is broken. I'm not sure how exactly, but this broke the when
; implementation below.
(define list-bad
  (vau args env
    (if (nil? args)
        ()
        (cons (eval (first args) env)
              (invoke list-bad (rest args))))))

; Construct a list from the arguments without evaluating them
(define unevaluated-list (vau args env args))

; Evaluates a list of items in the given env
(define eval-list
  (vau (lyst env-expr) current-env
    (do
      ; First, evaluate our arguments
      (define target-env (eval env-expr current-env))
      (define actual-list (eval lyst current-env))
      ; Then, make a helper to do the actual evaluation of lyst's elements
      (define eval-list-helper
        (vau (remaining) _
          (if (nil? remaining)
            ()
            (cons (eval (first remaining) target-env)
                  ; Because `invoke` unpacks the argument list, we need to use
                  ; `cons` to wrap our single argument so it becomes one
                  ; argument when unpacked.
                  (invoke eval-list-helper (cons (rest remaining) ()))))))
      ; Again, use `cons` to wrap the argument
      (invoke eval-list-helper (cons actual-list ())))))

; wrap takes an operative and returns a new operative that evaluates its arguments
(define wrap
  ; Here, the implicit env is the env where `define` was evaluated
  ; when loading the library.
  ; i.e. The global env
  (vau (operative) wrap-call-env
    ; Here, the implicit env is still the global env (the closure env of this
    ; vau).
    ; When this outer vau is called, i.e. when `wrap` is called, it creates a
    ; new env with the global env as its parent, `wrap-call-env` bound to the
    ; env where `wrap` was called, and `operative` bound to the argument of
    ; `wrap`. This new env becomes the implicit env.
    (do
      ; Evaluate the operative once when wrap is called
      (define resolved-operative (eval operative wrap-call-env))
      (vau unevaluated-args wrapped-call-env
        ; Here, the implicit env is the closure environment of this inner vau.
        ; This environment was created by the `do` block when the outer vau was
        ; called, and contains `resolved-operative` as well as access to the
        ; global environment. When this inner vau is called, it creates a new
        ; environment extending this closure environment, with
        ; `wrapped-call-env` bound to the calling environment and
        ; `unevaluated-args` bound to the arguments.
        (do
          (define evaluated-args (eval-list unevaluated-args wrapped-call-env))
          (invoke resolved-operative evaluated-args))))))

; Kernel:
; ($define! $lambda
;   ($vau (formals . body) env
;         (wrap (eval (list* $vau formals #ignore body)
;                env))))
; Note that Kernel's list* can create improper lists if the last argument is
; not itself a list. I don't think this matters in our case.

; We're OK with lambda only supporting a single expression body.

(define lambda
  ; We don't support (head . tail) style of parameters.
  ; But we also don't support multiple expressions in the body of a vau or lambda.
  ; So, (formals body) for us is equivalent to (formals . body) for Kernel except
  ; that our body won't be a list.
  (vau (formals body) env
    (wrap (eval
            ; Kernel uses list* here and its last parameter is a list.
            ; So, in Kernel, this part...
            ;    (list* $vau formals #ignore body)
            ; ...is equivalent to...
            ;    (cons $vau (cons formals (cons #ignore body)))
            ; We use () for #ignored and body is not a list, so our equivalent is:
            (cons vau (cons formals (cons () (cons body ()))))
            env))))

(define list (lambda args args))

; This is the equivalent of Kernel's list*.
; It prepends its arguments to the list that is the final argument.
; The $lambda-based implementation of list* given in the Kernel report doesn't
; look to match the expected behavior in use. It would evaluate its arguments
; multiple times during the recursion, but uses seem to expect that its
; arguments would only be evaluated once. To achieve that, this implementation
; uses an inner fexpr for the recursion.
; TODO: We could rewrite lambda and prepend so that lambda depended upon
;       prepend rather than prepend depending on lambda.
(define prepend
  (do (define recurse
              (vau operands _
                (if (nil? operands)
                    ()
                    (do (define head (first operands))
                        (define tail (rest operands))
                        (if (nil? tail)
                            head
                            (cons head (invoke recurse tail)))))))
      (lambda args (invoke recurse args))))

(define square (lambda (x) (* x x)))

(define newline (lambda () (display "\n")))

; An example of a macro-like fexpr:
;($define! $when
;   ($vau (test . body) env
;      (eval (list $if test (list* $sequence body) #inert)
;            env)))
; Test: (when (nil? ()) (display "true"))
; Needs more tests
(define when
  (vau args env
    (do
      (define test (first args))
      (define body (rest args))
      (define if-expr (list if test (cons do body) ()))
      (eval if-expr env))))

#skip
(define displayln
  (lambda* args
    (foreach display args)
    (newline)))
#end
